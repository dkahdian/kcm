# Graph Validation & Propagation (Level 1)

This document specifies the **Level‑1 semantic validator** and **propagator** for the Knowledge Compilation Map adjacency matrix.

Scope:
- Covers *only* succinctness/compilation edges (the adjacency matrix).
- Does **not** cover Level‑2 semantics (queries/transformations implication propagation).

Terminology:
- A directed edge is a `DirectedSuccinctnessRelation` stored in `adjacencyMatrix.matrix[i][j]`.
- Each edge has a `status` string.

**Design goal**: Users add only the claims made by paper authors; all trivial/transitive/implicit facts propagate automatically. This improves UX and simplifies data entry.

## Canonical statuses and intended meaning

The canonical dataset uses these statuses (see `relationTypes` in `src/lib/data/database.json`):

| Status | Meaning | Guarantees | Witness description phrase |
| --- | --- | --- | --- |
| `poly` | Polynomial transformation exists | poly exists; quasi exists | "in polynomial time" |
| `unknown-poly-quasi` | Quasi exists, poly unknown | quasi exists | "in at worst quasipolynomial time" |
| `no-poly-quasi` | Quasi exists and poly is impossible (optimal quasi) | quasi exists; poly does not exist | "in quasipolynomial time" |
| `unknown-both` | Both poly and quasi are unknown | none | *(cannot appear in witness path)* |
| `no-poly-unknown-quasi` | Poly is impossible; quasi unknown | poly does not exist | *(cannot appear in witness path)* |
| `no-quasi` | No quasi-polynomial transformation exists | quasi does not exist; poly does not exist | *(cannot appear in witness path)* |

Notes:
- Additional relation types exist in `database.json` (e.g. `unknown`, `not-poly`) but are **view-only** (generated by filters) and rejected by `validateDatasetStructure`.
- The diagonal `A → A` is never examined by the frontend. The validator/propagator should **completely ignore** diagonal entries (do not validate, do not traverse).

## `null` vs `unknown-both`

The matrix can have `null` (no edge stored) or an explicit `unknown-both` relation.

Semantic distinction:
- `null`: "We (app creators) haven't recorded anything about this pair."
- `unknown-both`: "This is an open problem; no one on Earth knows."

Algorithmic treatment:
- **Treat identically** for reachability and upgrade/downgrade logic.
- **Preserve identity**: `null` stays `null` and `unknown-both` stays `unknown-both` unless the propagator performs an upgrade or downgrade.
- If the propagator resolves an `unknown-both` edge (i.e., solves an open problem), emit an **alert** to the caller so this can be surfaced to the user.

## Level‑1 semantic model

We model each directed edge `A → B` as constraints about existence of two kinds of transforms:

- `P(A,B)`: a polynomial transform exists.
- `Q(A,B)`: a quasi-polynomial transform exists.

Assumptions (axioms):
- Poly implies quasi: `P(A,B) ⇒ Q(A,B)`.
- Transitivity under composition:
  - `P(A,B) ∧ P(B,C) ⇒ P(A,C)`
  - `Q(A,B) ∧ Q(B,C) ⇒ Q(A,C)`
  - Mixed composition is quasi: `P ∘ Q` and `Q ∘ P` imply quasi.

The Level‑1 validator is implemented using *reachability* on two directed graphs:
- `G_P`: edges where `P` is guaranteed (status `poly`).
- `G_Q`: edges where `Q` is guaranteed (statuses `poly`, `unknown-poly-quasi`, `no-poly-quasi`).

## Derived edge schema

When the propagator creates or upgrades an edge, it populates these fields:

| Field | Value |
| --- | --- |
| `status` | the upgraded status (`poly` or `unknown-poly-quasi`) |
| `description` | witness path as formatted string (see below) |
| `refs` | **union** of all `refs` arrays from edges in the witness path |
| `separatingFunctionIds` | `undefined` |
| `hidden` | `false` (derived edges are visible; hiding is a UI filter concern) |
| `derived` | `true` *(new field)* |

### Witness description format

Example: `"Derived: A transforms to B in polynomial time. B transforms to C in at worst quasipolynomial time."`

Use the "witness description phrase" from the status table above for each hop.

### New type field

Add to `DirectedSuccinctnessRelation`:

```ts
/** True if this edge was inferred by the propagator rather than manually authored. */
derived?: boolean;
```

This enables future filters like "hide all derived edges".

## Two validators: consistency vs closure

We maintain two related validators because they serve different UX roles.

### 1) `validateAdjacencyConsistency` (sound consistency)

Purpose:
- Detect **hard contradictions** (e.g. a `no-quasi` edge contradicts a discovered quasi path).
- Useful as an early guardrail and inside contradiction search.
- **Run before Phase 1** to reject invalid inputs early.

Algorithm:
1. Build `G_P` and `G_Q` from guaranteed edges.
2. Compute reachability with witnesses using **DFS** (parent pointers on the stack):
   - For each source `s`, run DFS on `G_P` to compute `reachP[s][*]` and reconstruct paths.
   - For each source `s`, run DFS on `G_Q` to compute `reachQ[s][*]` and reconstruct paths.
3. For each ordered pair `(A,C)` with `A ≠ C` (skip diagonal):
   - If `reachP[A][C]` is true and the stored status asserts "no poly" (e.g. `no-poly-unknown-quasi`, `no-poly-quasi`, `no-quasi`), return invalid with the witness path in `G_P`.
   - If `reachQ[A][C]` is true and the stored status asserts "no quasi" (`no-quasi`), return invalid with the witness path in `G_Q`.
4. **Fail-fast**: Return the **first** error encountered; do not accumulate all errors.

Witness format:
- Return a formatted description string, e.g.:
  - `"Contradiction: B transforms to C in polynomial time. C transforms to A in polynomial time. Therefore B→A must have poly, but B→A is marked no-quasi."`

Complexity:
- With `V` languages, `E` edges, and DFS-from-each-source, time is `O(V·(V+E))` for each of `G_P` and `G_Q`.

### 2) `validateAdjacencyClosure` (consistency + completion)

Purpose:
- Enforce that the matrix is a **fixed point** under Level‑1 implications.
- This is what users intuit as "the matrix already includes all trivial implied facts."

Algorithm:
- Compute reachability as above (DFS).
- For each `(A,C)` with `A ≠ C`:
  - If `reachP[A][C]` then the status must be exactly `poly`.
  - Else if `reachQ[A][C]` then status must be one of `{ poly, unknown-poly-quasi, no-poly-quasi }`.

Example (direct proof):
- If `A→B` has quasi and `B→C` is poly, then `A→C` must have quasi.
- Therefore `A→C = unknown-both` is invalid under closure.

This validator is what Phase 1 propagation aims to satisfy.

## Propagator: two phases

### Execution order

1. Run `validateAdjacencyConsistency` on input data. If invalid, abort with error.
2. Run Phase 1 (direct build).
3. Run Phase 2 (contradiction discovery).
4. Return propagated data + any alerts (e.g. open problems solved).

### Phase 1: Direct build (monotone upgrades)

Goal:
- Make the dataset satisfy `validateAdjacencyClosure` without guessing negative information.
- Only adds/strengthens **positive** information (poly/quasi existence).

Fixed-point loop (required):
```
changed = true
while changed:
    changed = false
    recompute reachQ, reachP via DFS-from-each-source
    for each (A, C) with A ≠ C:
        attempt upgrades (below); if any applied, changed = true
```

Upgrade rules:
- **Quasi upgrade**: If `reachQ[A][C]` and current status does *not* guarantee quasi:
  - `null` or `unknown-both` ⇒ set to `unknown-poly-quasi` (with `derived: true`, witness description, refs union).
  - `no-poly-unknown-quasi` ⇒ set to `no-poly-quasi`.
- **Poly upgrade**: If `reachP[A][C]` and current status is not `poly`:
  - `null`, `unknown-both`, `unknown-poly-quasi` ⇒ set to `poly`.

Important guard:
- If an upgrade would overwrite a status that asserts a contradiction (e.g. upgrading to `poly` when the cell is `no-poly-quasi`), the propagator should **stop and report an inconsistency**. This indicates the input data was semantically inconsistent (should have been caught by prior consistency check, but serves as a safety net).

Provenance:
- Use DFS parent pointers to reconstruct the witness path.
- Format description using the witness description phrases.
- Collect `refs` as the union of all edge refs along the path.

### Phase 2: Contradiction discovery (monotone downgrades)

Goal:
- Infer negative facts (`no-poly-*`, `no-quasi`) by showing that assuming a stronger edge leads to inconsistency.

Loop structure: **Repeat-until-stable**
```
changed = true
while changed:
    changed = false
    for each edge (A, C) in matrix:
        if tryDowngrade(A, C):
            changed = true
```

This is simpler to implement correctly than a worklist approach and avoids missing transitive domino effects.

#### `tryDowngrade(A, C)` logic

Depends on current status:

**Case: `null` or `unknown-both`**
1. Trial: temporarily set status to `poly`.
2. Run `validateAdjacencyConsistency`.
3. If inconsistent:
   - Downgrade to `no-poly-unknown-quasi` (preserve `null` → create new edge; preserve `unknown-both` → keep as `unknown-both` base but change status).
  - Record witness: `"Assuming A→C is poly produces contradiction: [witness]. Therefore A→C is not poly."`
  - Set `derived: true`; set `hidden: false`; set `separatingFunctionIds: undefined`; set `refs` to the witness-path union.
   - Continue to step 4.
4. Trial: temporarily set status to `unknown-poly-quasi` (assert quasi exists).
5. Run `validateAdjacencyConsistency`.
6. If inconsistent:
  - Downgrade to `no-quasi`.
  - Record witness; set `derived: true`; set `hidden: false`; set `refs` to witness-path union.
   - Return true (changed).
7. If neither trial failed, return false.

**Case: `unknown-poly-quasi`**
1. Trial: temporarily set status to `poly`.
2. If inconsistent:
  - Downgrade to `no-poly-quasi`.
  - Record witness; set `derived: true`; set `hidden: false`; set `refs` to witness-path union.
   - Return true.
3. Return false.

**Case: `no-poly-unknown-quasi`**
1. Trial: temporarily set status to `no-poly-quasi` (assert quasi exists).
2. If inconsistent:
  - Downgrade to `no-quasi`.
  - Record witness; set `derived: true`; set `hidden: false`; set `refs` to witness-path union.
   - Return true.
3. Return false.

**All other statuses**: Return false (nothing to downgrade).

#### Witness format for downgrades

Example: `"Derived (contradiction): Assuming A→C is poly leads to: B transforms to A in polynomial time, A transforms to C in polynomial time, implying B→C is poly. But B→C is marked no-poly-quasi. Therefore A→C cannot be poly."`

Termination and runtime:
- Each edge can downgrade at most 2 times (see ladder).
- Each iteration scans all `O(E)` edges.
- Total: `O(E² · V²)` worst case, but with `V ≈ 20` this is still sub-second.

## Implementation placement

- Level‑0 (structural) validation: `validateDatasetStructure` in `src/lib/data/validation.ts` (already exists).
- Level‑1 semantic validation: add `validateAdjacencyConsistency` and `validateAdjacencyClosure` in `src/lib/data/semantic-validation.ts` (new file).
- Propagator: extend or replace `propagateImplicitRelations` in `src/lib/data/propagation.ts` with the two-phase algorithm.
- Type update: add `derived?: boolean` to `DirectedSuccinctnessRelation` in `src/lib/types.ts`.

## Return types

```ts
interface SemanticValidationResult {
  ok: boolean;
  /** If not ok, a formatted description of the contradiction */
  error?: string;
  /** The witness path as language IDs (for programmatic use) */
  witnessPath?: string[];
}

interface PropagationResult {
  data: GraphData;
  /** Number of edges upgraded in Phase 1 */
  upgradesApplied: number;
  /** Number of edges downgraded in Phase 2 */
  downgradesApplied: number;
  /** Alerts, e.g. if an open problem (unknown-both) was resolved */
  alerts: string[];
}
```

## Future (Level 2)

A Level‑2 validator/propagator would additionally enforce:
- If `A→B` is poly and `B` answers a query in poly, then `A` also answers it in poly.
- Similar closure rules for transformation operations.

This should be layered separately to keep Level‑1 fast and conceptually clean.
