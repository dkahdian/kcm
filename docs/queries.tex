% =============================
% Knowledge Compilation Map - Query Support Claims
% Auto-generated from database.json
% Generated: 2026-02-18T00:54:53.263Z
%
% EDITING INSTRUCTIONS:
% - Claims (\begin{claim}...\end{claim}) are auto-generated. Do NOT edit.
% - Descriptions (\begin{claimdescription}...\end{claimdescription}) are EDITABLE.
% - Derived entries are omitted; they will be regenerated by propagation.
% - To sync back to JSON, run: npx tsx scripts/latex-bijection.ts --to-json
% =============================
\documentclass[11pt]{article}

% -------- Packages --------
\usepackage[margin=1in]{geometry}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{xcolor}
\usepackage{natbib}

% -------- Hyperref setup --------
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  citecolor=blue,
  urlcolor=blue
}

% -------- Theorem styles --------
\theoremstyle{plain}
\newtheorem{claim}{Claim}[section]

\theoremstyle{definition}
\newtheorem{definition}[claim]{Definition}

% -------- Description environment --------
\newenvironment{claimdescription}{%
  \par\noindent\ignorespaces
}{\par}

% -------- Handy macros --------
\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\eps}{\varepsilon}

% -------- Title info --------
\title{Knowledge Compilation Map: Query Support}
\date{\today}

\begin{document}
\maketitle

\tableofcontents
\newpage

% =============================
\section{A. Darwiche and P. Marquis, "A Knowledge Compilation Map," Journal of Artificial...}
% Reference ID: Darwiche_2002
% =============================
% lang=lang_89649e36, op=CO
\begin{claim}
$CNF$ supports Consistency not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Consistency checking for $CNF$ is NP-complete (the classic SAT problem). This is one of the foundational intractability results (\citet{Darwiche_2002}, Proposition 4.1, Table 16).
\end{claimdescription}

% lang=lang_89649e36, op=IM
\begin{claimdescription}
To check whether a consistent term $\alpha$ implies a $CNF$ sentence $\Sigma$, it suffices to verify that each clause of $\Sigma$ is either a tautology or shares at least one true literal with $\alpha$. This requires only a single pass over the formula and runs in linear time (\citet{Darwiche_2002}, Proposition 4.1, Table 21).
\end{claimdescription}

% lang=lang_89649e36, op=VA
\begin{claim}
$CNF$ supports Validity in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
A $CNF$ sentence is valid iff every clause in it is valid (i.e., contains a complementary pair of literals). This can be checked in linear time (\citet{Darwiche_2002}, Proposition 4.1, Table 21).
\end{claimdescription}

% lang=lang_4c204bf3, op=VA
\begin{claim}
$DNF$ supports Validity not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Validity checking for $DNF$ is coNP-complete. A $DNF$ is valid iff every assignment satisfies at least one term, which requires checking that term coverage is complete (\citet{Darwiche_2002}, Proposition 4.1, Table 16).
\end{claimdescription}

% lang=lang_6ae90adc, op=CT
\begin{claim}
$IP$ supports Model Counting not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
By duality with $PI$: the negation of a formula in prime implicate form is in prime implicant ($IP$) form. The number of models of $\neg\Sigma$ over $\text{Vars}(\Sigma)$ is $2^n$ minus the model count of $\Sigma$. Hence the \#P-hardness of counting for $PI$ transfers to $IP$ (\citet{Darwiche_2002}, Proposition 4.1, Table 24).
\end{claimdescription}

% lang=lang_6ae90adc, op=IM
\begin{claim}
$IP$ supports Implicant in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
By definition, $IP$ is the set of prime implicants of a formula. A consistent term $\alpha$ implies $\Sigma$ iff $\alpha$ entails some prime implicant of $\Sigma$. This entailment check between terms runs in polynomial time (\citet{Darwiche_2002}, Proposition 4.1, Table 24).
\end{claimdescription}

% lang=lang_6ae90adc, op=SE
\begin{claimdescription}
Although $IP \subseteq DNF$ (where SE is generally hard), $IP$ supports SE in polynomial time. To check if $\Sigma_1 \models \Sigma_2$, we just need to verify that every term in $\Sigma_1$ implies $\Sigma_2$. Since testing if a term implies an $IP$ formula is an Implicant (IM) query, and $IP$ supports IM in polynomial time, the entire SE check reduces to a polynomial number of IM checks (\citet{Darwiche_2002}, Proposition 4.1).
\end{claimdescription}

% lang=lang_e02902d0, op=CO
\begin{claim}
$MODS$ supports Consistency in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
A sentence $\Sigma$ is consistent iff it has at least one model. In a $MODS$ representation, the number of models is given by the number of edges outgoing from the or-node. Accordingly, CO can be achieved in polynomial time by checking if this count is nonzero (\citet{Darwiche_2002}, Proposition 4.1, Table 18).
\end{claimdescription}

% lang=lang_e02902d0, op=CT
\begin{claim}
$MODS$ supports Model Counting in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
The number of models of $\Sigma$ is given by the number of edges outgoing from the or-node in any $MODS$ representation. Accordingly, CT can be achieved in polynomial time by counting these edges (\citet{Darwiche_2002}, Proposition 4.1, Table 18).
\end{claimdescription}

% lang=lang_e02902d0, op=VA
\begin{claim}
$MODS$ supports Validity in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
A sentence $\Sigma$ is valid iff it has $2^n$ models, where $n = |\text{Vars}(\Sigma)|$. In $MODS$, the model count is directly available. Thus VA can be achieved in polynomial time by checking if this count equals $2^n$ (\citet{Darwiche_2002}, Proposition 4.1, Table 18).
\end{claimdescription}

% lang=lang_b9d72a7c, op=CO
\begin{claim}
$OBDD$ supports Consistency in polynomial time \citet{Bryant_1986,Darwiche_2002}
\end{claim}
\begin{claimdescription}
Any query concerning $OBDD$ is equivalent to the corresponding query concerning $OBDD_<$ when only one DAG is involved. Since $OBDD_<$ satisfies CO, VA and CT, so does $OBDD$ (\citet{Darwiche_2002}, Proposition 4.1, Table 20).
\end{claimdescription}

% lang=lang_b9d72a7c, op=CT
\begin{claim}
$OBDD$ supports Model Counting in polynomial time \citet{Bryant_1986,Darwiche_2002}
\end{claim}
\begin{claimdescription}
Any query concerning $OBDD$ is equivalent to the corresponding query concerning $OBDD_<$ when only one DAG is involved. Since $OBDD_<$ satisfies CO, VA and CT, so does $OBDD$ (\citet{Darwiche_2002}, Proposition 4.1, Table 20).
\end{claimdescription}

% lang=lang_b9d72a7c, op=EQ
\begin{claim}
$OBDD$ supports Equivalence in polynomial time \citet{Meinel_Theobald_1998,Darwiche_2002}
\end{claim}
\begin{claimdescription}
$OBDD$ satisfies EQ (Theorem 8.11, Meinel \& Theobald 1998). Any equivalence query on a single $OBDD$ reduces to the corresponding query on $OBDD_<$, and $OBDD_<$ supports EQ (\citet{Darwiche_2002}, Proposition 4.1, Table 20).
\end{claimdescription}

% lang=lang_b9d72a7c, op=VA
\begin{claim}
$OBDD$ supports Validity in polynomial time \citet{Bryant_1986,Darwiche_2002}
\end{claim}
\begin{claimdescription}
Any query concerning $OBDD$ is equivalent to the corresponding query concerning $OBDD_<$ when only one DAG is involved. Since $OBDD_<$ satisfies CO, VA and CT, so does $OBDD$ (\citet{Darwiche_2002}, Proposition 4.1, Table 20).
\end{claimdescription}

% lang=lang_d69995dd, op=CE
\begin{claim}
$OBDD_<$ supports Clausal Entailment in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
$OBDD_<$ satisfies CO and CD. By Lemma A.4, CO and CD imply CE: to test $\Sigma \models \alpha$ for clause $\alpha$, condition on $\neg\alpha$ and check consistency (\citet{Darwiche_2002}, Proposition 4.1, Table 20).
\end{claimdescription}

% lang=lang_d69995dd, op=IM
\begin{claim}
$OBDD_<$ supports Implicant in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
$OBDD_<$ satisfies VA and CD. By Lemma A.7, VA and CD imply IM: to test whether term $\alpha \models \Sigma$, condition on $\alpha$ and check validity (\citet{Darwiche_2002}, Proposition 4.1, Table 20).
\end{claimdescription}

% lang=lang_d69995dd, op=SE
\begin{claim}
$OBDD_<$ supports Sentential Entailment in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Since $OBDD_<$ satisfies CO, $\neg$C and $\land$BC, checking $\Sigma_1 \models \Sigma_2$ reduces to checking whether $\Sigma_1 \land \neg\Sigma_2$ is inconsistent, which can be computed in polytime (\citet{Darwiche_2002}, Proposition 4.1, Table 20).
\end{claimdescription}

% lang=lang_27fffab2, op=CE
\begin{claim}
$PI$ supports Clausal Entailment in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
By definition, $PI$ is the set of prime implicates of a formula. A clause $\gamma$ is entailed by $\Sigma$ iff $\gamma$ subsumes (is a weakening of) some prime implicate of $\Sigma$. This subsumption check runs in polynomial time (\citet{Darwiche_2002}, Proposition 4.1, Table 24).
\end{claimdescription}

% lang=lang_27fffab2, op=CT
\begin{claim}
$PI$ supports Model Counting not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002,Roth_1996}
\end{claim}
\begin{claimdescription}
The model counting problem for monotone Krom formulas (conjunctions of clauses with at most two positive literals) is \#P-complete \citet{Roth_1996}. Such formulas can be converted to prime implicates form in polynomial time, so $PI$ does not satisfy CT (\citet{Darwiche_2002}, Proposition 4.1, Table 24).
\end{claimdescription}

% lang=lang_27fffab2, op=SE
\begin{claim}
$PI$ supports Sentential Entailment in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
$PI \subseteq CNF$ and $PI$ satisfies CE, so checking $\Sigma_1 \models \Sigma_2$ for $CNF$ $\Sigma_2$ reduces to checking each clause of $\Sigma_2$ against the prime implicates of $\Sigma_1$. Two formulas are equivalent iff they share the same prime implicates (canonical form), giving SE (\citet{Darwiche_2002}, Proposition 4.1, Table 24).
\end{claimdescription}


% =============================
\section{R. E. Bryant, "Graph-based algorithms for boolean function manipulation," Comput...}
% Reference ID: Bryant_1986
% =============================
% lang=lang_d69995dd, op=CO
\begin{claim}
$OBDD_<$ supports Consistency in polynomial time \citet{Bryant_1986}
\end{claim}
\begin{claimdescription}
Consistency is trivial for OBDDs: check if the diagram root is not the terminal 0 node \citet{Bryant_1986}.
\end{claimdescription}

% lang=lang_d69995dd, op=CT
\begin{claim}
$OBDD_<$ supports Model Counting in polynomial time \citet{Bryant_1986}
\end{claim}
\begin{claimdescription}
Model counting on OBDDs can be done in polynomial time by a single bottom-up pass \citet{Bryant_1986, Bryant_1992}.
\end{claimdescription}

% lang=lang_d69995dd, op=EQ
\begin{claim}
$OBDD_<$ supports Equivalence in polynomial time \citet{Bryant_1986,Bryant_1992,Meinel_Theobald_1998}
\end{claim}
\begin{claimdescription}
OBDDs with a fixed variable ordering are canonical: two functions are equivalent iff their reduced OBDDs are identical. This makes EQ trivial (structural isomorphism check) \citet{Bryant_1986, Bryant_1992, Meinel_Theobald_1998} (Theorem 8.11).
\end{claimdescription}

% lang=lang_d69995dd, op=ME
\begin{claim}
$OBDD_<$ supports Model Enumeration in polynomial time \citet{Bryant_1986}
\end{claim}
\begin{claimdescription}
Models of an OBDD can be enumerated in time polynomial in the output size by traversing all root-to-1-sink paths. Each path corresponds to a (partial) assignment that can be expanded to full models.
\end{claimdescription}

% lang=lang_d69995dd, op=VA
\begin{claim}
$OBDD_<$ supports Validity in polynomial time \citet{Bryant_1986}
\end{claim}
\begin{claimdescription}
Validity is trivial for OBDDs: check if the diagram root equals the terminal 1 node \citet{Bryant_1986}.
\end{claimdescription}


% =============================
\section{J. Gergov and C. Meinel, "Efficient Boolean manipulation with OBDD's can be exte...}
% Reference ID: Gergov_1994
% =============================
% lang=lang_684b1ca7, op=CO
\begin{claim}
$FBDD$ supports Consistency in polynomial time \citet{Gergov_1994}
\end{claim}
\begin{claimdescription}
$FBDD$ satisfies CO \citet{Gergov_1994, Darwiche_2002}. Consistency is polynomial: check if the BDD root is not the terminal 0 node.
\end{claimdescription}

% lang=lang_684b1ca7, op=CT
\begin{claim}
$FBDD$ supports Model Counting in polynomial time \citet{Gergov_1994}
\end{claim}
\begin{claimdescription}
$FBDD$ satisfies CT \citet{Gergov_1994, Darwiche_2002}. Model counting on FBDDs can be done in polynomial time by a single bottom-up pass counting satisfying assignments at each node.
\end{claimdescription}

% lang=lang_684b1ca7, op=VA
\begin{claim}
$FBDD$ supports Validity in polynomial time \citet{Gergov_1994}
\end{claim}
\begin{claimdescription}
$FBDD$ satisfies VA \citet{Gergov_1994, Darwiche_2002}. Validity is polynomial: check if the BDD root equals the terminal 1 node.
\end{claimdescription}


% =============================
\section{C. Meinel and T. Theobald, "Algorithms and Data Structures in VLSI Design: OBDD ...}
% Reference ID: Meinel_Theobald_1998
% =============================
% lang=lang_b9d72a7c, op=SE
\begin{claim}
$OBDD$ supports Sentential Entailment not in polynomial time (quasi-polynomial unknown) \citet{Meinel_Theobald_1998}
\end{claim}
\begin{claimdescription}
Checking sentential entailment for $OBDD$ formulas is coNP-complete. Since $OBDD$ satisfies $\neg$C, $\alpha \land \beta$ is consistent iff $\alpha \not\models \neg\beta$. Checking consistency of two $OBDD_<$ formulas with different variable orderings is NP-complete (Lemma 8.14, Meinel \& Theobald 1998), so SE for $OBDD$ is coNP-complete (\citet{Darwiche_2002}, Proposition 4.1, Table 20).
\end{claimdescription}


% =============================
\section{A. Darwiche, "On the Tractable Counting of Theory Models and its Application to ...}
% Reference ID: Darwiche_2001b
% =============================
% lang=lang_6c130090, op=CT
\begin{claim}
$d$-$DNNF$ supports Model Counting in polynomial time \citet{Darwiche_2001b}
\end{claim}
\begin{claimdescription}
$d$-$DNNF$ satisfies CT: model counting can be performed in polynomial time by exploiting decomposability (multiplying counts at $\land$-nodes) and determinism (adding counts at $\lor$-nodes). This is the key tractability result motivating $d$-$DNNF$ as a compilation target \citet{Darwiche_2001b} (\citet{Darwiche_2002}, Proposition 4.1, Table 26).
\end{claimdescription}


% =============================
\section{Adnan Darwiche, "Decomposable Negation Normal Form," Journal of the ACM, vol. 48...}
% Reference ID: Darwiche_2001a
% =============================
% lang=lang_3bebcab7, op=CE
\begin{claim}
$DNNF$ supports Clausal Entailment in polynomial time \citet{Darwiche_2001a}
\end{claim}
\begin{claimdescription}
$DNNF$ supports clause entailment (CE) in polynomial time \citet{Darwiche_2001a}. To test $\Sigma \models \gamma$ for clause $\gamma$, it suffices to test whether $\Sigma | \neg\gamma$ is inconsistent. Since $DNNF$ satisfies CD and CO, this can be done in polytime.
\end{claimdescription}

% =============================
\section{Alexis de Colnet and Kuldeep S. Meel, "An FPRAS for Model Counting for Non-Dete...}
% Reference ID: Colnet_2025
% =============================
% lang=lang_1df07cc3, op=CT
\begin{claim}
$nFBDD$ supports Model Counting not in polynomial time (quasi-polynomial unknown) \citet{Colnet_2025}
\end{claim}
\begin{claimdescription}
Exact model counting for non-deterministic read-once branching programs ($nFBDD$) is \#P-hard. This is because non-determinism allows multiple computational paths to satisfy the same assignment, making the counting of unique models significantly more difficult than in the deterministic ($FBDD$) case \citet{Colnet_2025}.
\end{claimdescription}

% =============================
% Bibliography
% =============================
\bibliographystyle{plainnat}
\bibliography{refs}

\end{document}
