% =============================
% Knowledge Compilation Map - Transformation Support Claims
% Auto-generated from database.json
% Generated: 2026-02-18T00:54:53.268Z
%
% EDITING INSTRUCTIONS:
% - Claims (\begin{claim}...\end{claim}) are auto-generated. Do NOT edit.
% - Descriptions (\begin{claimdescription}...\end{claimdescription}) are EDITABLE.
% - Derived entries are omitted; they will be regenerated by propagation.
% - To sync back to JSON, run: npx tsx scripts/latex-bijection.ts --to-json
% =============================
\documentclass[11pt]{article}

% -------- Packages --------
\usepackage[margin=1in]{geometry}
\usepackage{amsmath, amssymb, amsthm}
\usepackage{mathtools}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{xcolor}
\usepackage{natbib}

% -------- Hyperref setup --------
\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  citecolor=blue,
  urlcolor=blue
}

% -------- Theorem styles --------
\theoremstyle{plain}
\newtheorem{claim}{Claim}[section]

\theoremstyle{definition}
\newtheorem{definition}[claim]{Definition}

% -------- Description environment --------
\newenvironment{claimdescription}{%
  \par\noindent\ignorespaces
}{\par}

% -------- Handy macros --------
\newcommand{\R}{\mathbb{R}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\eps}{\varepsilon}

% -------- Title info --------
\title{Knowledge Compilation Map: Transformation Support}
\date{\today}

\begin{document}
\maketitle

\tableofcontents
\newpage

% =============================
\section{A. Darwiche and P. Marquis, "A Knowledge Compilation Map," Journal of Artificial...}
% Reference ID: Darwiche_2002
% =============================
% lang=lang_89649e36, op=NOT_C
\begin{claim}
$CNF$ supports Negation not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
The negation of a CNF formula is a DNF formula. If CNF satisfied $\neg$C, any DNF formula could be turned into an equivalent CNF in polytime (by double negation). Since DNF $\not\leq$ CNF, this is impossible (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_89649e36, op=AND_BC
\begin{claim}
$CNF$ supports Bounded Conjunction in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Immediate since CNF satisfies $\land$C: the conjunction of two CNF sentences is just the union of their clauses (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_89649e36, op=AND_C
\begin{claim}
$CNF$ supports Conjunction in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Conjunction of CNF sentences is trivially another CNF sentence: simply take the union of all clauses (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_89649e36, op=OR_BC
\begin{claim}
$CNF$ supports Bounded Disjunction in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
The disjunction of two CNF sentences $\alpha_1 \lor \alpha_2$ can be computed by taking all cross products of one clause from $\alpha_1$ and one from $\alpha_2$, removing redundant literals and valid clauses. The result is a CNF of polynomial size (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_89649e36, op=OR_C
\begin{claim}
$CNF$ supports Disjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
It is straightforward to convert any term into an equivalent CNF formula in polynomial time. Since specific DNF formulas cannot be turned into equivalent CNF formulas in polynomial space (DNF $\not\leq$ CNF), CNF does not satisfy $\lor$C (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_89649e36, op=CD
\begin{claim}
$CNF$ supports Conditioning in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
CD is trivially satisfied: replacing literals of the conditioning term by Boolean constants in a CNF and removing valid clauses preserves the CNF property (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_89649e36, op=FO
\begin{claim}
$CNF$ supports Forgetting not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
If CNF satisfies FO, then the consistency of any CNF sentence $\Sigma$ could be tested in polytime: compute $\exists\text{Vars}(\Sigma).\Sigma$ and check validity. Since CNF does not satisfy CO, this implies P = NP (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_89649e36, op=SFO
\begin{claim}
$CNF$ supports Singleton Forgetting in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
$\exists x.\Sigma \equiv (\Sigma|x) \lor (\Sigma|\neg x)$. Since CNF satisfies CD and $\lor$BC, singleton forgetting can be computed in polytime (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_6c130090, op=AND_BC
\begin{claim}
$d$-$DNNF$ supports Bounded Conjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Since OBDD $\subseteq$ d-DNNF and d-DNNF satisfies CO, the NP-completeness of consistency checking for two OBDDs (which may possess different underlying orderings) (Lemma 8.14, Meinel \& Theobald 1998) implies d-DNNF does not satisfy $\land$BC unless P = NP (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_6c130090, op=AND_C
\begin{claim}
$d$-$DNNF$ supports Conjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Direct from the fact that d-DNNF does not satisfy $\land$BC unless P = NP (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_6c130090, op=OR_BC
\begin{claim}
$d$-$DNNF$ supports Bounded Disjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Consistency checking for two OBDDs (which may possess different underlying orderings) is NP-complete. Since OBDD satisfies $\neg$C and OBDD $\subseteq$ d-DNNF, if d-DNNF satisfied $\lor$BC then $\neg\alpha_1 \lor \neg\alpha_2$ could be computed in polytime and its validity tested (d-DNNF satisfies VA), solving an NP-hard problem (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_6c130090, op=OR_C
\begin{claim}
$d$-$DNNF$ supports Disjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Immediate from the fact that d-DNNF does not satisfy $\lor$BC unless P = NP (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_6c130090, op=CD
\begin{claim}
$d$-$DNNF$ supports Conditioning in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Conditioning preserves both decomposability and determinism. If $\alpha \land \beta \models \bot$ then $(\alpha|\gamma) \land (\beta|\gamma) \models \bot$ for any consistent term $\gamma$, since $((\alpha \land \beta)|\gamma) \land \gamma \models \bot$ and $\gamma$ is consistent (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_6c130090, op=FO
\begin{claim}
$d$-$DNNF$ supports Forgetting not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
If d-DNNF satisfies FO, then every DNF can be compiled to an equivalent d-DNNF of polynomial size (using fresh selector variables and then applying FO). Since DNF $\not\leq$ d-DNNF, this is impossible (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_6c130090, op=SFO
\begin{claim}
$d$-$DNNF$ supports Singleton Forgetting not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
If d-DNNF satisfies SFO, then it satisfies $\lor$BC (since $\alpha_1 \lor \alpha_2 \equiv \exists x . ((x \land \alpha_1) \lor (\neg x \land \alpha_2))$ for fresh $x$). But d-DNNF does not satisfy $\lor$BC unless P = NP (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_4c204bf3, op=NOT_C
\begin{claim}
$DNF$ supports Negation not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
The negation of a DNF formula is a CNF formula. If DNF satisfied $\neg$C, any CNF formula could be turned into an equivalent DNF in polytime (by double negation). Since CNF $\not\leq$ DNF, this is impossible (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_4c204bf3, op=AND_BC
\begin{claim}
$DNF$ supports Bounded Conjunction in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
The conjunction of two DNF sentences $\alpha_1 \land \alpha_2$ can be computed by taking all cross products of one term from $\alpha_1$ and one from $\alpha_2$, removing redundant literals and inconsistent terms. The result is a DNF of polynomial size (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_4c204bf3, op=AND_C
\begin{claim}
$DNF$ supports Conjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
It is straightforward to convert a clause into an equivalent DNF formula in polynomial time. Since specific CNF formulas cannot be turned into equivalent DNF formulas in polynomial space (CNF $\not\leq$ DNF), DNF does not satisfy $\land$C (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_4c204bf3, op=OR_BC
\begin{claim}
$DNF$ supports Bounded Disjunction in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Immediate since DNF satisfies $\lor$C: the disjunction of DNF sentences trivially produces another DNF (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_4c204bf3, op=OR_C
\begin{claim}
$DNF$ supports Disjunction in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Disjunction of DNF sentences is trivially another DNF sentence: simply take the union of all terms (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_4c204bf3, op=CD
\begin{claim}
$DNF$ supports Conditioning in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
CD is trivially satisfied: replacing literals of the conditioning term by Boolean constants in a DNF and removing inconsistent terms preserves the DNF property (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_4c204bf3, op=SFO
\begin{claim}
$DNF$ supports Singleton Forgetting in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Immediate since DNF satisfies FO: singleton forgetting is a special case of forgetting (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_3bebcab7, op=NOT_C
\begin{claim}
$DNNF$ supports Negation not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
If DNNF satisfies $\neg$C, then any CNF formula could be converted to DNNF in polytime (negate a DNF equivalent of $\neg\Sigma$). Since DNNF satisfies CO, this would give P = NP (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_3bebcab7, op=AND_BC
\begin{claim}
$DNNF$ supports Bounded Conjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Checking consistency of two OBDDs (which may possess different underlying variable orderings) is NP-complete (Lemma 8.14, Meinel \& Theobald 1998). Since OBDD $\subseteq$ DNNF and DNNF satisfies CO, if DNNF satisfied $\land$BC then consistency of two OBDDs could be tested in polytime, implying P = NP (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_3bebcab7, op=AND_C
\begin{claim}
$DNNF$ supports Conjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Direct from the fact that DNNF does not satisfy $\land$BC unless P = NP (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_3bebcab7, op=OR_BC
\begin{claim}
$DNNF$ supports Bounded Disjunction in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Immediate since DNNF satisfies $\lor$C: disjunction trivially preserves decomposability (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_3bebcab7, op=OR_C
\begin{claim}
$DNNF$ supports Disjunction in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Disjunction trivially preserves decomposability since decomposability only constrains $\land$-nodes. Every NNF formula can be smoothed in polytime, preserving decomposability (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_3bebcab7, op=CD
\begin{claim}
$DNNF$ supports Conditioning in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Conditioning preserves decomposability: if $\alpha$ and $\beta$ do not share variables, then $\alpha|\gamma$ and $\beta|\gamma$ do not share variables either, since $\text{Vars}(\alpha|\gamma) \subseteq \text{Vars}(\alpha)$ (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_3bebcab7, op=SFO
\begin{claim}
$DNNF$ supports Singleton Forgetting in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Immediate since DNNF satisfies FO: singleton forgetting is a special case of forgetting (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_684b1ca7, op=NOT_C
\begin{claim}
$FBDD$ supports Negation in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Negation of an FBDD is achieved by switching the labels of the 0-sink and 1-sink. The decision property and read-once property are preserved (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_684b1ca7, op=AND_BC
\begin{claim}
$FBDD$ supports Bounded Conjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Since OBDD $\subseteq$ FBDD and FBDD satisfies CO, the NP-completeness of consistency checking for two OBDDs (which may possess different underlying orderings) implies FBDD does not satisfy $\land$BC unless P = NP (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_684b1ca7, op=AND_C
\begin{claim}
$FBDD$ supports Conjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
It is straightforward to convert a clause into an equivalent FBDD formula in polynomial time. Since specific CNF formulas cannot be turned into equivalent FBDD formulas in polynomial space (CNF $\not\leq$ FBDD), FBDD does not satisfy $\land$C (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_684b1ca7, op=OR_BC
\begin{claim}
$FBDD$ supports Bounded Disjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Since OBDD satisfies $\neg$C and OBDD $\subseteq$ FBDD, if FBDD satisfied $\lor$BC then $\neg\alpha_1 \lor \neg\alpha_2$ could be computed and checked for validity in polytime. Since d-DNNF satisfies VA and FBDD $\subseteq$ d-DNNF, this would solve an NP-hard problem (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_684b1ca7, op=OR_C
\begin{claim}
$FBDD$ supports Disjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
It is straightforward to convert any term into an equivalent FBDD formula in polynomial time. Since specific DNF formulas cannot be turned into equivalent FBDD formulas in polynomial space (DNF $\not\leq$ FBDD), FBDD does not satisfy $\lor$C (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_684b1ca7, op=CD
\begin{claim}
$FBDD$ supports Conditioning in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Conditioning on FBDD is the restrict operation: replace each node labeled by a variable in the conditioning term with one of its children. This preserves the free (read-once) property (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_684b1ca7, op=FO
\begin{claim}
$FBDD$ supports Forgetting not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
If FBDD satisfies FO, then every DNF can be compiled to an equivalent FBDD of polynomial size. Since DNF $\not\leq$ FBDD, this is impossible (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_684b1ca7, op=SFO
\begin{claim}
$FBDD$ supports Singleton Forgetting not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
If FBDD satisfies SFO, then it satisfies $\lor$BC (since disjunction can be encoded via SFO with a fresh variable). But FBDD does not satisfy $\lor$BC unless P = NP (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_6ae90adc, op=NOT_C
\begin{claim}
$IP$ supports Negation not in quasi-polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Dual of PI: $\Sigma_n = \bigvee_{i=0}^{n-1}(x_{2i} \land x_{2i+1})$ is in IP form but has $2^n$ prime implicates. Its negation has $2^n$ prime implicants. Hence IP cannot satisfy $\neg$C (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_6ae90adc, op=AND_BC
\begin{claim}
$IP$ supports Bounded Conjunction in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
$\text{IP}(\alpha_1 \land \alpha_2) = \max(\{\beta_1 \land \beta_2 \mid \beta_1 \in \text{IP}(\alpha_1), \beta_2 \in \text{IP}(\alpha_2)\}, \models)$ (dual of Proposition 40, Marquis 2000). The maximization removes subsuming terms, yielding an IP form in polytime (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_6ae90adc, op=AND_C
\begin{claim}
$IP$ supports Conjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
It is straightforward to convert a clause into an equivalent IP formula in polynomial time. Since specific CNF formulas cannot be turned into equivalent IP formulas in polynomial space (CNF $\not\leq$ IP), IP does not satisfy $\land$C (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_6ae90adc, op=OR_BC
\begin{claim}
$IP$ supports Bounded Disjunction not in quasi-polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Combining prime implicants via disjunction requires distributing and re-minimizing terms, which can lead to an exponential explosion of new prime implicants. Let $\alpha_1 = \bigwedge_{i=1}^k p_i$ (one prime implicant) and $\alpha_2 = \bigvee_{i=1}^k \bigvee_{j=1}^m (\neg p_i \land q_{i,j})$ ($mk$ prime implicants). Then $\alpha_1 \lor \alpha_2$ has $(m+1)^k + mk$ prime implicants, an exponential blowup \citet{Chandra_1978} (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_6ae90adc, op=OR_C
\begin{claim}
$IP$ supports Disjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
It is straightforward to convert any term into an equivalent IP formula in polynomial time. Since specific DNF formulas cannot be turned into equivalent IP formulas in polynomial space (DNF $\not\leq$ IP), IP does not satisfy $\lor$C (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_6ae90adc, op=CD
\begin{claim}
$IP$ supports Conditioning in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Given IP formula $\Sigma = \bigvee \gamma_i$, conditioning on $\gamma$ gives $\bigvee (\gamma_i|\gamma)$. Keeping only the logically weakest surviving terms yields a prime implicants formula equivalent to $\Sigma|\gamma$. This requires $O(n^2)$ entailment tests among terms, each polytime (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_6ae90adc, op=FO
\begin{claim}
$IP$ supports Forgetting not in quasi-polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
IP does not satisfy FO since it does not satisfy SFO: the number of prime implicants can blow up exponentially when forgetting even a single variable \citet{Chandra_1978} (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_6ae90adc, op=SFO
\begin{claim}
$IP$ supports Singleton Forgetting not in quasi-polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
The number of prime implicants of $\exists x.\Sigma$ can be exponentially greater than the number of prime implicants of $\Sigma$ \citet{Chandra_1978}. A specific construction with $mk+1$ prime implicants produces $(m+1)^k + mk$ prime implicants after forgetting one variable (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_e02902d0, op=NOT_C
\begin{claim}
$MODS$ supports Negation not in quasi-polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
$\Sigma = \bigwedge_{i=1}^n x_i$ has only one model over $\{x_1,\ldots,x_n\}$ but its negation $\neg\Sigma$ has $2^n - 1$ models. Hence MODS cannot satisfy $\neg$C (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_e02902d0, op=AND_BC
\begin{claim}
$MODS$ supports Bounded Conjunction in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
The bounded conjunction of two MODS formulas (over the same variables) is simply taking the intersection of their model sets. If the variables differ, it is the intersection of their cylindrical extensions. The result is a MODS sentence in polytime (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_e02902d0, op=AND_C
\begin{claim}
$MODS$ supports Conjunction not in quasi-polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Let $\Sigma_i = (x_{i,1} \lor x_{i,2})$ for $i = 1,\ldots,n$. Each $\Sigma_i$ has 3 models. But $\Sigma = \bigwedge_{i=1}^n \Sigma_i$ has $3^n$ models, so no polynomial-size MODS representation exists (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_e02902d0, op=OR_BC
\begin{claim}
$MODS$ supports Bounded Disjunction not in quasi-polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Since MODS cannot satisfy $\lor$C, it also cannot satisfy $\lor$BC (bounded disjunction is weaker than unbounded disjunction, but the model count blow-up argument still applies) (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_e02902d0, op=OR_C
\begin{claim}
$MODS$ supports Disjunction not in quasi-polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Let $\alpha_1 = \bigwedge_{i=1}^n x_i$ (1 model) and $\alpha_2 = y$ (1 model). Then $\alpha_1 \lor \alpha_2$ has $2^n + 1$ models over $\text{Vars}(\alpha_1) \cup \text{Vars}(\alpha_2)$. Hence MODS cannot satisfy $\lor$C (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_e02902d0, op=CD
\begin{claim}
$MODS$ supports Conditioning in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
MODS satisfies CD as a direct consequence of satisfying $\land$BC and FO. By Lemma A.12, $\Sigma|\gamma \equiv \exists\text{Vars}(\gamma).(\Sigma \land \gamma)$ (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_e02902d0, op=FO
\begin{claim}
$MODS$ supports Forgetting in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Given a MODS formula $\Sigma$ and a set $X$, the MODS representation of $\exists X.\Sigma$ is obtained by removing every leaf node labeled by a literal $x$ or $\neg x$ with $x \in X$ (Propositions 18 and 20, Lang et al. 2000). See also the polytime FO operation on DNNF from \citet{Darwiche_2001a} (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_e02902d0, op=SFO
\begin{claim}
$MODS$ supports Singleton Forgetting in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Immediate since MODS satisfies FO: singleton forgetting is a special case of forgetting (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_5bf00851, op=NOT_C
\begin{claim}
$NNF$ supports Negation in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
NNF trivially satisfies $\neg$C since any propositional sentence can be converted to NNF by pushing negations to literals and this preserves the NNF property (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_5bf00851, op=AND_BC
\begin{claim}
$NNF$ supports Bounded Conjunction in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Immediate since NNF satisfies $\land$C: the conjunction of NNF sentences trivially produces another NNF (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_5bf00851, op=AND_C
\begin{claim}
$NNF$ supports Conjunction in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Taking the conjunction of NNF sentences $\alpha_1 \land \alpha_2 \land \ldots$ trivially produces another NNF sentence, since NNF places no restrictions on $\land$-nodes (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_5bf00851, op=OR_BC
\begin{claim}
$NNF$ supports Bounded Disjunction in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Immediate since NNF satisfies $\lor$C: the disjunction of NNF sentences trivially produces another NNF sentence (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_5bf00851, op=OR_C
\begin{claim}
$NNF$ supports Disjunction in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Taking the disjunction of NNF sentences $\alpha_1 \lor \alpha_2 \lor \ldots$ trivially produces another NNF sentence, since NNF places no restrictions on $\lor$-nodes (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_5bf00851, op=CD
\begin{claim}
$NNF$ supports Conditioning in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
CD is trivially satisfied by NNF: replacing literals of the conditioning term by Boolean constants preserves the NNF property (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_5bf00851, op=FO
\begin{claim}
$NNF$ supports Forgetting not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
If NNF satisfies FO, then every CNF sentence $\Sigma$ could be tested for consistency in polytime: convert to NNF (trivial), compute $\exists \text{Vars}(\Sigma).\Sigma$ in polytime, and check if the result is valid. Since CNF consistency is NP-hard, NNF does not satisfy FO unless P = NP (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_5bf00851, op=SFO
\begin{claim}
$NNF$ supports Singleton Forgetting in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
$\exists x.\Sigma \equiv (\Sigma|x) \lor (\Sigma|\neg x)$. Since NNF satisfies CD and $\lor$BC, singleton forgetting can be computed in polytime (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_b9d72a7c, op=NOT_C
\begin{claim}
$OBDD$ supports Negation in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Negation of an OBDD is achieved by switching the labels of the 0-sink and 1-sink. The ordered variable property is preserved since the single ordering is not affected (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_b9d72a7c, op=AND_BC
\begin{claim}
$OBDD$ supports Bounded Conjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Checking consistency of two OBDDs (which may possess different underlying orderings) is NP-complete (Lemma 8.14, Meinel \& Theobald 1998). Since OBDD satisfies CO, if OBDD satisfied $\land$BC consistency could be tested in polytime, implying P = NP (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_b9d72a7c, op=AND_C
\begin{claim}
$OBDD$ supports Conjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
It is straightforward to convert a clause into an equivalent OBDD formula in polynomial time. Since specific CNF formulas cannot be turned into equivalent OBDD formulas in polynomial space (CNF $\not\leq$ OBDD), OBDD does not satisfy $\land$C (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_b9d72a7c, op=OR_BC
\begin{claim}
$OBDD$ supports Bounded Disjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Since OBDD satisfies $\neg$C, $\alpha_1 \land \alpha_2$ is inconsistent iff $\neg\alpha_1 \lor \neg\alpha_2$ is valid. If OBDD satisfied $\lor$BC, the disjunction could be computed in polytime and validity tested (OBDD satisfies VA). Since consistency of two OBDDs with different orderings is NP-hard, P = NP would follow (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_b9d72a7c, op=OR_C
\begin{claim}
$OBDD$ supports Disjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
It is straightforward to convert any term into an equivalent OBDD formula in polynomial time. Since specific DNF formulas cannot be turned into equivalent OBDD formulas in polynomial space (DNF $\not\leq$ OBDD), OBDD does not satisfy $\lor$C (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_b9d72a7c, op=CD
\begin{claim}
$OBDD$ supports Conditioning in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Since OBDD $\subseteq$ FBDD and FBDD satisfies CD (the restrict operation), OBDD also satisfies CD. The variable ordering is preserved under conditioning (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_b9d72a7c, op=FO
\begin{claim}
$OBDD$ supports Forgetting not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
If OBDD satisfies FO, then every DNF can be compiled to an equivalent OBDD of polynomial size. Since DNF $\not\leq$ OBDD, this is impossible (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_b9d72a7c, op=SFO
\begin{claim}
$OBDD$ supports Singleton Forgetting in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Since only one OBDD sentence is considered in the transformation, and OBDD$_<$ satisfies SFO, OBDD also satisfies SFO (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_d69995dd, op=AND_C
\begin{claim}
$OBDD_<$ supports Conjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
It is straightforward to convert a clause into an equivalent OBDD$_<$ formula in polynomial time. Since specific CNF formulas cannot be turned into equivalent OBDD$_<$ formulas in polynomial space (CNF $\not\leq$ OBDD$_<$), OBDD$_<$ does not satisfy $\land$C (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_d69995dd, op=OR_C
\begin{claim}
$OBDD_<$ supports Disjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
It is straightforward to convert any term into an equivalent OBDD$_<$ formula in polynomial time. Since specific DNF formulas cannot be turned into equivalent OBDD$_<$ formulas in polynomial space (DNF $\not\leq$ OBDD$_<$), OBDD$_<$ does not satisfy $\lor$C (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_d69995dd, op=FO
\begin{claim}
$OBDD_<$ supports Forgetting not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
If OBDD$_<$ satisfies FO, then every DNF sentence $\Gamma$ can be compiled to an equivalent OBDD$_<$ of polynomial size (using fresh selector variables and then applying FO). Since DNF $\not\leq$ OBDD$_<$, this is impossible (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_d69995dd, op=SFO
\begin{claim}
$OBDD_<$ supports Singleton Forgetting in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
$\exists x . \Sigma \equiv (\Sigma|x) \lor (\Sigma|\neg x)$. Since OBDD$_<$ satisfies CD and $\lor$BC, singleton forgetting can be computed in polytime \citet{Bryant_1986, Darwiche_2002} (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_27fffab2, op=NOT_C
\begin{claim}
$PI$ supports Negation not in quasi-polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
The formula $\Sigma_n = \bigwedge_{i=0}^{n-1}(x_{2i} \lor x_{2i+1})$ is in PI form but has $2^n$ prime implicants. Its negation has $2^n$ prime implicates. Hence PI cannot satisfy $\neg$C (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_27fffab2, op=AND_BC
\begin{claim}
$PI$ supports Bounded Conjunction not in quasi-polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Combining prime implicates via conjunction requires distributing and re-minimizing clauses, which can lead to an exponential explosion of new prime implicates. Let $\alpha_1 = \bigvee_{i=1}^k p_i$ (one prime implicate) and $\alpha_2 = \bigwedge_{i=1}^k \bigwedge_{j=1}^m (\neg p_i \lor q_{i,j})$ ($mk$ prime implicates). Then $\alpha_1 \land \alpha_2$ has $(m+1)^k + mk$ prime implicates, an exponential blowup \citet{Chandra_1978} (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_27fffab2, op=AND_C
\begin{claim}
$PI$ supports Conjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
It is straightforward to convert a clause into an equivalent PI formula in polynomial time. Since specific CNF formulas cannot be turned into equivalent PI formulas in polynomial space (CNF $\not\leq$ PI), PI does not satisfy $\land$C (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_27fffab2, op=OR_BC
\begin{claim}
$PI$ supports Bounded Disjunction in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
$\text{PI}(\alpha_1 \lor \alpha_2) = \min(\{\beta_1 \lor \beta_2 \mid \beta_1 \in \text{PI}(\alpha_1), \beta_2 \in \text{PI}(\alpha_2)\}, \models)$ (Proposition 40, Marquis 2000). The minimization removes subsumed clauses, yielding a PI form in polytime (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_27fffab2, op=OR_C
\begin{claim}
$PI$ supports Disjunction not in polynomial time (quasi-polynomial unknown) \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
It is straightforward to convert any term into an equivalent PI formula in polynomial time. Since specific DNF formulas cannot be turned into equivalent PI formulas in polynomial space (DNF $\not\leq$ PI), PI does not satisfy $\lor$C (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_27fffab2, op=CD
\begin{claim}
$PI$ supports Conditioning in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
The prime implicates of $\Sigma \land \gamma$ can be computed in polytime when $\Sigma$ is in PI form and $\gamma$ is a term (Proposition 36, Marquis 2000). Since PI satisfies FO, the prime implicates of $\Sigma|\gamma \equiv \exists\text{Vars}(\gamma).(\Sigma \land \gamma)$ follow in polytime (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_27fffab2, op=FO
\begin{claim}
$PI$ supports Forgetting in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
The prime implicates of $\exists X.\Sigma$ are exactly the prime implicates of $\Sigma$ that do not contain any variable from $X$ (Proposition 55, Marquis 2000). Hence FO for PI simply filters out clauses containing forgotten variables (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}

% lang=lang_27fffab2, op=SFO
\begin{claim}
$PI$ supports Singleton Forgetting in polynomial time \citet{Darwiche_2002}
\end{claim}
\begin{claimdescription}
Immediate since PI satisfies FO: singleton forgetting is a special case of forgetting (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}


% =============================
\section{R. E. Bryant, "Graph-based algorithms for boolean function manipulation," Comput...}
% Reference ID: Bryant_1986
% =============================
% lang=lang_d69995dd, op=NOT_C
\begin{claim}
$OBDD_<$ supports Negation in polynomial time \citet{Bryant_1986}
\end{claim}
\begin{claimdescription}
Negation of an OBDD$_<$ is achieved by switching the labels of the 0-sink and 1-sink. The result is an OBDD$_<$ of identical size \citet{Bryant_1986}.
\end{claimdescription}

% lang=lang_d69995dd, op=AND_BC
\begin{claim}
$OBDD_<$ supports Bounded Conjunction in polynomial time \citet{Bryant_1986}
\end{claim}
\begin{claimdescription}
The Apply algorithm computes the conjunction of two OBDD$_<$ sentences sharing the same variable ordering in polynomial time. The result is a reduced OBDD$_<$ \citet{Bryant_1986}.
\end{claimdescription}

% lang=lang_d69995dd, op=OR_BC
\begin{claim}
$OBDD_<$ supports Bounded Disjunction in polynomial time \citet{Bryant_1986}
\end{claim}
\begin{claimdescription}
The Apply algorithm computes the disjunction of two OBDD$_<$ sentences sharing the same variable ordering in polynomial time. The result is a reduced OBDD$_<$ \citet{Bryant_1986}.
\end{claimdescription}

% lang=lang_d69995dd, op=CD
\begin{claim}
$OBDD_<$ supports Conditioning in polynomial time \citet{Bryant_1986}
\end{claim}
\begin{claimdescription}
Conditioning (the restrict operation) on OBDD$_<$ replaces each node labeled by a variable in the conditioning term with one of its children, according to the sign of the variable. The result is a valid OBDD$_<$ \citet{Bryant_1986}.
\end{claimdescription}


% =============================
\section{J. Lang, P. Liberatore, and P. Marquis, "Propositional Independence: Formula-Var...}
% Reference ID: Lang_2000
% =============================
% lang=lang_4c204bf3, op=FO
\begin{claim}
$DNF$ supports Forgetting in polynomial time \citet{Lang_2000}
\end{claim}
\begin{claimdescription}
DNF satisfies FO \citet{Lang_2000}. Forgetting variables from a DNF sentence can be done in polytime (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}


% =============================
\section{Adnan Darwiche, "Decomposable Negation Normal Form," Journal of the ACM, vol. 48...}
% Reference ID: Darwiche_2001a
% =============================
% lang=lang_3bebcab7, op=FO
\begin{claim}
$DNNF$ supports Forgetting in polynomial time \citet{Darwiche_2001a}
\end{claim}
\begin{claimdescription}
DNNF satisfies FO: forgetting a set of variables in a DNNF sentence can be performed in polynomial time while preserving decomposability \citet{Darwiche_2001a} (\citet{Darwiche_2002}, Proposition 5.1).
\end{claimdescription}


% =============================
\section{H. Vinall-Smeeth, "Structured d-DNNF Is Not Closed Under Negation," IJCAI 2024}
% Reference ID: Vinall-Smeeth_2024
% =============================
% lang=lang_ea9b5299, op=NOT_C
\begin{claim}
$d$-$SDNNF$ supports Negation not in quasi-polynomial time \citet{Vinall-Smeeth_2024}
\end{claim}
\begin{claimdescription}
Structured deterministic DNNF ($d$-$SDNNF$) is not closed under negation. \citet{Vinall-Smeeth_2024} formally proves that there exist Boolean functions with polynomial-size $d$-$SDNNF$ representations whose exact negations require exponential-size $d$-$SDNNF$s.
\end{claimdescription}

% lang=lang_ea9b5299, op=OR_BC
\begin{claim}
$d$-$SDNNF$ supports Bounded Disjunction not in quasi-polynomial time \citet{Vinall-Smeeth_2024}
\end{claim}
\begin{claimdescription}
Unlike $OBDD$, structured $d$-$SDNNF$ does not support quasi-polynomial-time disjunction. The combination of strict determinism and a rigid vtree structure prevents tractable $\vee$BC operations without an exponential worst-case blowup \citet{Vinall-Smeeth_2024}.
\end{claimdescription}

% lang=lang_ea9b5299, op=FO
\begin{claim}
$d$-$SDNNF$ supports Forgetting not in quasi-polynomial time \citet{Vinall-Smeeth_2024}
\end{claim}
\begin{claimdescription}
Existential quantification (Forgetting) is not supported in polynomial time for $d$-$SDNNF$. Forgetting variables generally destroys the determinism of the underlying circuit. Restoring determinism while strictly adhering to the structural vtree constraints incurs an exponential blowup \citet{Vinall-Smeeth_2024}.
\end{claimdescription}

% =============================
% Bibliography
% =============================
\bibliographystyle{plainnat}
\bibliography{refs}

\end{document}
