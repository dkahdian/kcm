import{T as on,p as jn,bk as sn,Q as Se,v as P,F as Ln,w as Pn,a1 as Qe,a3 as Fn,N as Dn,O as Mn,P as Ue,R as Ie,D as ee,ai as Qn,aI as Un,A as Ce,W as Vn,bl as ye,bm as ge,U as zn,ah as Ve,aT as Bn,af as ze,aA as rn,i as Hn,X as an,Y as Yn,bn as Gn,bo as ke,q as Kn,C as cn,bp as Xn,at as Wn,bq as Zn,az as Jn,br as et,a6 as nt}from"./DyTkIbAe.js";import{d as D,b as tt,a as ot,g as it}from"./OZbp0Vnk.js";const st=!0;function Yo(e,n){return n}function rt(e,n,t){for(var o=e.items,i=[],s=n.length,r=0;r<s;r++)Zn(n[r].e,i,!0);var c=s>0&&i.length===0&&t!==null;if(c){var a=t.parentNode;Jn(a),a.append(t),o.clear(),R(e,n[0].prev,n[s-1].next)}et(i,()=>{for(var u=0;u<s;u++){var f=n[u];c||(o.delete(f.k),R(e,f.prev,f.next)),cn(f.e,!c)}})}function Go(e,n,t,o,i,s=null){var r=e,c={flags:n,items:new Map,first:null},a=(n&sn)!==0;if(a){var u=e;r=P?Se(Ln(u)):u.appendChild(on())}P&&Pn();var f=null,h=!1,d=new Map,g=Fn(()=>{var p=t();return Hn(p)?p:p==null?[]:rn(p)}),m,y;function l(){at(y,m,c,d,r,i,n,o,t),s!==null&&(m.length===0?f?an(f):f=Ce(()=>s(r)):f!==null&&Yn(f,()=>{f=null}))}jn(()=>{y??=nt,m=Qe(g);var p=m.length;if(h&&p===0)return;h=p===0;let w=!1;if(P){var $=Dn(r)===Mn;$!==(p===0)&&(r=Ue(),Se(r),Ie(!1),w=!0)}if(P){for(var v=null,b,x=0;x<p;x++){if(ee.nodeType===Qn&&ee.data===Un){r=ee,w=!0,Ie(!1);break}var q=m[x],S=o(q,x);b=Oe(ee,c,v,null,q,S,x,i,n,t),c.items.set(S,b),v=b}p>0&&Se(Ue())}if(P)p===0&&s&&(f=Ce(()=>s(r)));else if(Vn()){var I=new Set,A=zn;for(x=0;x<p;x+=1){q=m[x],S=o(q,x);var C=c.items.get(S)??d.get(S);C?(n&(ye|ge))!==0&&un(C,q,x,n):(b=Oe(null,c,null,null,q,S,x,i,n,t,!0),d.set(S,b)),I.add(S)}for(const[E,B]of c.items)I.has(E)||A.skipped_effects.add(B.e);A.add_callback(l)}else l();w&&Ie(!0),Qe(g)}),P&&(r=ee)}function at(e,n,t,o,i,s,r,c,a){var u=(r&Xn)!==0,f=(r&(ye|ge))!==0,h=n.length,d=t.items,g=t.first,m=g,y,l=null,p,w=[],$=[],v,b,x,q;if(u)for(q=0;q<h;q+=1)v=n[q],b=c(v,q),x=d.get(b),x!==void 0&&(x.a?.measure(),(p??=new Set).add(x));for(q=0;q<h;q+=1){if(v=n[q],b=c(v,q),x=d.get(b),x===void 0){var S=o.get(b);if(S!==void 0){o.delete(b),d.set(b,S);var I=l?l.next:m;R(t,l,S),R(t,S,I),Ee(S,I,i),l=S}else{var A=m?m.e.nodes_start:i;l=Oe(A,t,l,l===null?t.first:l.next,v,b,q,s,r,a)}d.set(b,l),w=[],$=[],m=l.next;continue}if(f&&un(x,v,q,r),(x.e.f&ke)!==0&&(an(x.e),u&&(x.a?.unfix(),(p??=new Set).delete(x))),x!==m){if(y!==void 0&&y.has(x)){if(w.length<$.length){var C=$[0],E;l=C.prev;var B=w[0],W=w[w.length-1];for(E=0;E<w.length;E+=1)Ee(w[E],C,i);for(E=0;E<$.length;E+=1)y.delete($[E]);R(t,B.prev,W.next),R(t,l,B),R(t,W,C),m=C,l=W,q-=1,w=[],$=[]}else y.delete(x),Ee(x,m,i),R(t,x.prev,x.next),R(t,x,l===null?t.first:l.next),R(t,l,x),l=x;continue}for(w=[],$=[];m!==null&&m.k!==b;)(m.e.f&ke)===0&&(y??=new Set).add(m),$.push(m),m=m.next;if(m===null)continue;x=m}w.push(x),l=x,m=x.next}if(m!==null||y!==void 0){for(var L=y===void 0?[]:rn(y);m!==null;)(m.e.f&ke)===0&&L.push(m),m=m.next;var Z=L.length;if(Z>0){var H=(r&sn)!==0&&h===0?i:null;if(u){for(q=0;q<Z;q+=1)L[q].a?.measure();for(q=0;q<Z;q+=1)L[q].a?.fix()}rt(t,L,H)}}u&&Kn(()=>{if(p!==void 0)for(x of p)x.a?.apply()}),e.first=t.first&&t.first.e,e.last=l&&l.e;for(var J of o.values())cn(J.e);o.clear()}function un(e,n,t,o){(o&ye)!==0&&Ve(e.v,n),(o&ge)!==0?Ve(e.i,t):e.i=t}function Oe(e,n,t,o,i,s,r,c,a,u,f){var h=(a&ye)!==0,d=(a&Gn)===0,g=h?d?Bn(i,!1,!1):ze(i):i,m=(a&ge)===0?r:ze(r),y={i:m,v:g,k:s,a:null,e:null,prev:t,next:o};try{if(e===null){var l=document.createDocumentFragment();l.append(e=on())}return y.e=Ce(()=>c(e,g,m,u),P),y.e.prev=t&&t.e,y.e.next=o&&o.e,t===null?f||(n.first=y):(t.next=y,t.e.next=y.e),o!==null&&(o.prev=y,o.e.prev=y.e),y}finally{}}function Ee(e,n,t){for(var o=e.next?e.next.e.nodes_start:t,i=n?n.e.nodes_start:t,s=e.e.nodes_start;s!==null&&s!==o;){var r=Wn(s);i.before(s),s=r}}function R(e,n,t){n===null?e.first=t:(n.next=t,n.e.next=t&&t.e),t!==null&&(t.prev=n,t.e.prev=n&&n.e)}const Ko=st,X={poly:{code:"poly",label:"Polynomial",description:"Polynomial transformation exists",notation:"$\\leq_p$",emoji:"ðŸŸ¢",color:"#22c55e",pastel:"#dcfce7",cssClass:"complexity-poly",arrow:"triangle",dashed:!1},"no-poly-unknown-quasi":{code:"no-poly-unknown-quasi",label:"No Poly, Quasi Unknown",description:"No polynomial transformation; quasi-polynomial unknown",notation:"$\\not\\leq_p$ Â· $\\leq_q^?$",emoji:"âš ï¸",color:"#ef4444",pastel:"#fee2e2",cssClass:"complexity-no-poly-unknown-quasi",arrow:"tee",dashed:!0},"no-poly-quasi":{code:"no-poly-quasi",label:"No Poly, Quasi Exists",description:"No polynomial transformation; quasi-polynomial exists",notation:"$\\not\\leq_p$ Â· $\\leq_q$",emoji:"âš¡",color:"#f97316",pastel:"#ffedd5",cssClass:"complexity-no-poly-quasi",arrow:"tee",dashed:!1},"unknown-poly-quasi":{code:"unknown-poly-quasi",label:"Poly Unknown, Quasi Exists",description:"Polynomial unknown; quasi-polynomial exists",notation:"$\\leq_p^?$ Â· $\\leq_q$",emoji:"âš¡",color:"#eab308",pastel:"#fef9c3",cssClass:"complexity-unknown-poly-quasi",arrow:"triangle-cross",dashed:!0},"unknown-both":{code:"unknown-both",label:"Unknown",description:"Both polynomial and quasi-polynomial unknown",notation:"$?$",emoji:"â”",color:"#6b7280",pastel:"#f3f4f6",cssClass:"complexity-unknown-both",arrow:"square",dashed:!0},unknown:{code:"unknown",internal:!0,label:"Unknown",description:"Unknown whether polynomial transformation exists",notation:"$?$",emoji:"â”",color:"#6b7280",pastel:"#f3f4f6",cssClass:"complexity-unknown",arrow:"square",dashed:!0},"no-quasi":{code:"no-quasi",label:"No Quasi",description:"No quasi-polynomial transformation (implies no polynomial)",notation:"$\\not\\leq_q$",emoji:"âŒ",color:"#dc2626",pastel:"#fecaca",cssClass:"complexity-no-quasi",arrow:"square",dashed:!1},"not-poly":{code:"not-poly",internal:!0,label:"Not Polynomial",description:"No polynomial transformation",notation:"$\\not\\leq$",emoji:"âŒ",color:"#ef4444",pastel:"#fee2e2",cssClass:"complexity-not-poly",arrow:"square",dashed:!1},"unknown-to-us":{code:"unknown-to-us",label:"Unknown to Us",description:"Not yet researched or documented",notation:"?",emoji:"â“",color:"#9ca3af",pastel:"#ffffff",cssClass:"complexity-unknown-to-us",arrow:"circle",dashed:!0}};function ct(e,n){const t=e["unknown-both"]??X["unknown-both"];return e[n]??t}function Be(e){return e in X}const He={arrow:"none",dashed:!1};function ut(){return Object.values(X).filter(e=>!e.internal).map(e=>({id:e.code,name:e.label,label:e.notation,description:e.description,style:{lineStyle:"solid",width:2,targetStyle:{arrow:e.arrow,dashed:e.dashed},sourceStyle:{arrow:"none",dashed:!1}},defaultVisible:!0}))}const lt=ut();function Xo(e){if(e===null)return He;const n=X[e];return n?{arrow:n.arrow,dashed:n.dashed}:He}const ln=D.operations,G=ln.queries,se=ln.transformations;function he(){return Object.keys(G)}function ft(){return Object.keys(se)}function Wo(e){for(const[n,t]of Object.entries(se))if(t.code===e)return n;return e}function Ye(e,n){const t=[];for(const[o,i]of Object.entries(n)){const s=e?.[o]||e?.[i.code];s?t.push({code:i.code,label:i.label,complexity:s.complexity,caveat:s.caveat,refs:s.refs,description:s.description,derived:s.derived,dimmed:s.dimmed,explicit:s.explicit}):t.push({code:i.code,label:i.label,complexity:"unknown-to-us",refs:[]})}return t}function dt(e,n){return{queries:Ye(e,G),transformations:Ye(n,se)}}const pt=D.languages;function mt(e){const n=new Set;return e.definitionRefs&&e.definitionRefs.forEach(t=>n.add(t)),e.properties?.queries&&Object.values(e.properties.queries).forEach(t=>{t.refs&&t.refs.forEach(o=>n.add(o))}),e.properties?.transformations&&Object.values(e.properties.transformations).forEach(t=>{t.refs&&t.refs.forEach(o=>n.add(o))}),e.tags&&e.tags.forEach(t=>{t.refs&&t.refs.forEach(o=>n.add(o))}),{...e,references:tt(...Array.from(n))}}const yt=pt.map(mt),fn=D.adjacencyMatrix,dn=fn.languageIds,gt=fn.matrix,ht=Object.fromEntries(dn.map((e,n)=>[e,n])),wt={languageIds:dn,indexByLanguage:ht,matrix:gt},vt=D.separatingFunctions??[],xt="metadata"in D?D.metadata:void 0,bt={languages:yt,adjacencyMatrix:wt,relationTypes:lt,complexities:X,references:ot,separatingFunctions:vt,metadata:xt},$t=new Set(["poly","no-poly-unknown-quasi","no-poly-quasi","unknown-poly-quasi","unknown-both","no-quasi"]),qt=new Set(Object.keys(X)),St=new Set(he()),It=new Set(ft()),kt=new Set(Object.values(se).map(e=>e.code)),Et=/\$/g;function je(e){return(e??"").replace(Et,"").trim()}function oe(e,n,t,o){if(e!==void 0){if(!Array.isArray(e)){o.push(`${n}: references must be an array of IDs`);return}for(const i of e){if(typeof i!="string"||!i.trim()){o.push(`${n}: reference identifiers must be non-empty strings`);continue}t.has(i)||o.push(`${n}: unknown reference "${i}"`)}}}function At(e,n){const t=new Map;for(const o of e){if(!o.id||typeof o.id!="string"){n.push(`Encountered language without a valid id (name: ${o.name})`);continue}if(!o.name||typeof o.name!="string"){n.push("Encountered language without a valid name");continue}const i=je(o.id);if(!i){n.push(`Language "${o.name}" (id: "${o.id}") resolves to an empty identifier after normalization`);continue}if(t.has(i)){const s=t.get(i);n.push(`Language ID collision: "${o.id}" (${o.name}) conflicts with "${s}" after normalization`)}else t.set(i,o.name)}return t}function Tt(e){const n=new Set;if(!e)return n;for(const t of e)t?.id&&n.add(t.id);return n}function Ct(e,n,t){const{languageIds:o,indexByLanguage:i,matrix:s}=e,r=new Map;o.forEach((a,u)=>{const f=je(a);if(!f){t.push(`Adjacency matrix entry at index ${u} has an empty identifier`);return}if(r.has(f)){const h=r.get(f);t.push(`Adjacency matrix contains duplicate identifier "${a}" (conflicts with index ${h})`)}else r.set(f,u);n.has(f)||t.push(`Adjacency matrix references unknown language "${a}"`)});for(const[a,u]of n.entries())r.has(a)||t.push(`Language "${u}" is missing from the adjacency matrix`);s.length!==o.length&&t.push("Adjacency matrix must be square (rows must match number of languages)"),o.forEach((a,u)=>{const f=s[u];if(!Array.isArray(f)){t.push(`Adjacency matrix row ${u} is not an array`);return}f.length!==o.length&&t.push(`Adjacency matrix row ${u} length (${f.length}) does not match language count (${o.length})`)});const c=Object.entries(i);c.length!==o.length&&t.push("Adjacency matrix indexByLanguage must map every language exactly once");for(const[a,u]of c){if(typeof u!="number"||Number.isNaN(u)){t.push(`indexByLanguage entry for "${a}" is not a valid number`);continue}if(u<0||u>=o.length){t.push(`indexByLanguage entry for "${a}" is out of bounds (${u})`);continue}o[u]!==a&&t.push(`indexByLanguage mismatch: position ${u} stores "${o[u]}" instead of "${a}"`)}}function Ge(e,n,t,o,i){if(t)for(const[s,r]of Object.entries(t)){const c=n==="query"?St:It,a=n==="query"?void 0:kt;!c.has(s)&&!a?.has(s)&&i.push(`Language "${e}" references unknown ${n} code "${s}"`),(!r||typeof r.complexity!="string"||!qt.has(r.complexity))&&i.push(`Language "${e}" ${n} "${s}" must have a valid complexity code`),oe(r?.refs,`Language "${e}" ${n} "${s}" refs`,o,i)}}function Ot(e,n,t,o){if(Array.isArray(e.references))for(const i of e.references){if(!i?.id){o.push(`Language "${e.name}" contains a reference without an id`);continue}t.has(i.id)||o.push(`Language "${e.name}" references unknown id "${i.id}"`)}if(oe(e.definitionRefs,`Language "${e.name}" definitionRefs`,t,o),Ge(e.name,"query",e.properties?.queries,t,o),Ge(e.name,"transformation",e.properties?.transformations,t,o),Array.isArray(e.tags)){const i=new Set;for(const s of e.tags){if(!s?.label){o.push(`Language "${e.name}" has a tag without a label`);continue}i.has(s.label)?o.push(`Language "${e.name}" has duplicate tag label "${s.label}"`):i.add(s.label),oe(s.refs,`Language "${e.name}" tag "${s.label}" refs`,t,o)}}if(Array.isArray(e.subsets))for(const i of e.subsets){const s=je(i);(!s||!n.has(s))&&o.push(`Language "${e.name}" subset "${i}" does not reference a known language`)}}function Rt(e,n,t){const o=new Set;for(const i of e){if(!i.shortName){t.push("Separating function is missing a shortName");continue}o.has(i.shortName)?t.push(`Duplicate separating function shortName "${i.shortName}"`):o.add(i.shortName),oe(i.refs,`Separating function "${i.shortName}" refs`,n,t)}return o}function _t(e,n,t,o,i,s){if($t.has(e.status)||s.push(`Edge ${n} -> ${t} has unknown status "${e.status}"`),oe(e.refs,`Edge ${n} -> ${t} refs`,o,s),e.separatingFunctionIds!==void 0)if(!Array.isArray(e.separatingFunctionIds))s.push(`Edge ${n} -> ${t}: separatingFunctionIds must be an array`);else for(const r of e.separatingFunctionIds){if(typeof r!="string"||!r.trim()){s.push(`Edge ${n} -> ${t}: separatingFunctionIds must contain string IDs`);continue}i.has(r)||s.push(`Edge ${n} -> ${t} references unknown separating function "${r}"`)}}function Nt(e,n,t,o){const{languageIds:i,matrix:s}=e;for(let r=0;r<i.length;r+=1)for(let c=0;c<i.length;c+=1){const a=s[r]?.[c];a&&_t(a,i[r],i[c],n,t,o)}}function pn(e){const n=[],t=At(e.languages,n);Ct(e.adjacencyMatrix,t,n);const o=Tt(e.references);for(const s of e.languages)Ot(s,t,o,n);const i=Rt(e.separatingFunctions??[],o,n);return Nt(e.adjacencyMatrix,o,i,n),n.length>0?{ok:!1,errors:n}:{ok:!0}}const mn=new Set(["poly"]),yn=new Set(["poly","unknown-poly-quasi","no-poly-quasi"]),jt=new Set(["no-poly-unknown-quasi","no-poly-quasi","no-quasi"]);function Le(e,n,t){const o=e.matrix[n]?.[t];return o?o.status:null}function Lt(e){switch(e){case"poly":return"in polynomial time";case"unknown-poly-quasi":return"in at worst quasipolynomial time";case"no-poly-quasi":return"in quasipolynomial time";default:return"in unknown time"}}function Pt(e,n){return Array.from({length:e},()=>Array(e).fill(n))}function Ft(e){return Array.from({length:e},()=>Array(e).fill(-1))}function Ke(e,n){const t=e.languageIds.length,o=Pt(t,!1),i=Ft(t);for(let s=0;s<t;s+=1){const r=new Set,c=[s];for(;c.length>0;){const a=c.pop();if(r.has(a))continue;r.add(a);const u=e.matrix[a];if(u)for(let f=0;f<t;f+=1){if(f===s)continue;const h=u[f];h&&n.has(h.status)&&(o[s][f]||(o[s][f]=!0,i[s][f]=a),r.has(f)||c.push(f))}}}return{reach:o,parent:i}}function Xe(e,n,t){const o=[];let i=n;for(;i!==-1&&i!==e;)o.push(i),i=t[i];return i===e?(o.push(e),o.reverse(),o):[]}function We(e,n){return e.map(t=>n[t])}function Dt(e,n){const{languageIds:t}=n,o=[];for(let i=0;i<e.length-1;i+=1){const s=e[i],r=e[i+1],c=Le(n,s,r)??"unknown",a=Lt(c);o.push(`${t[s]} transforms to ${t[r]} ${a}.`)}return o.join(" ")}function Mt(e){return e??"missing"}function Ze(e,n,t,o,i){const s=Dt(o,i),r=i.languageIds[e],c=i.languageIds[n],a=Mt(Le(i,e,n));return`Contradiction: ${s} Therefore ${r}â†’${c} must have ${t==="poly"?"poly":"quasi"}, but ${r}â†’${c} is marked ${a}.`}function gn(e){const{adjacencyMatrix:n}=e,t=n.languageIds.length,o=Ke(n,mn),i=Ke(n,yn);for(let s=0;s<t;s+=1)for(let r=0;r<t;r+=1){if(s===r)continue;const c=Le(n,s,r);if(o.reach[s][r]&&c&&jt.has(c)){const a=Xe(s,r,o.parent[s]);return{ok:!1,error:Ze(s,r,"poly",a,n),witnessPath:We(a,n.languageIds)}}if(i.reach[s][r]&&c==="no-quasi"){const a=Xe(s,r,i.parent[s]);return{ok:!1,error:Ze(s,r,"quasi",a,n),witnessPath:We(a,n.languageIds)}}}return{ok:!0}}function Qt(e){return e!=null&&mn.has(e)}function Ut(e){return e!=null&&yn.has(e)}function fe(e,n){const t=new Set;for(let o=0;o<e.length-1;o+=1){const i=e[o],s=e[o+1],r=n.matrix[i]?.[s];if(r?.refs)for(const c of r.refs)t.add(c)}return Array.from(t)}function hn(e){let n=2166136261;for(let o=0;o<e.length;o++)n^=e.charCodeAt(o),n=Math.imul(n,16777619);return`lang_${(n>>>0).toString(16).padStart(8,"0")}`}let Re=new Map;function Vt(e){Re=new Map;for(const n of e)n.id&&Re.set(n.id,n.name)}function k(e){return Re.get(e)??e}const Ae=D.operationLemmas,Y=new Set(["poly"]),F=new Set(["poly","unknown-poly-quasi","no-poly-quasi"]);function zt(e){const n={};return e.forEach((t,o)=>{n[t]=o}),n}function Bt(e,n){return Array.from({length:e},()=>Array(e).fill(n))}function Ht(e){return Array.from({length:e},()=>Array(e).fill(-1))}function T(e,n){const t=e.languageIds.length,o=Bt(t,!1),i=Ht(t);for(let s=0;s<t;s+=1){const r=new Set,c=[s];for(;c.length>0;){const a=c.pop();if(r.has(a))continue;r.add(a);const u=e.matrix[a];if(u)for(let f=0;f<t;f+=1){if(f===s)continue;const h=u[f];h&&n.has(h.status)&&(o[s][f]||(o[s][f]=!0,i[s][f]=a),r.has(f)||c.push(f))}}}return{reach:o,parent:i}}function ne(e,n,t){const o=[];let i=n;for(;i!==-1&&i!==e;)o.push(i),i=t[i];return i===e?(o.push(e),o.reverse(),o):[]}function te(e,n,t){return e.length>=2?e:[n,t]}function ue(e){switch(e){case"poly":return"in polynomial time";case"unknown-poly-quasi":return"in at worst quasipolynomial time";case"no-poly-quasi":return"in quasipolynomial time";default:return"in unknown time"}}function Yt(e,n,t){switch(t){case"no-poly-quasi":return`This contradicts the fact that ${e} cannot transform to ${n} in polynomial time`;case"no-poly-unknown-quasi":return`This contradicts the fact that ${e} cannot transform to ${n} in polynomial time`;case"no-quasi":return`This contradicts the fact that ${e} cannot transform to ${n} in quasipolynomial time`;default:return`This contradicts the existing relationship from ${e} to ${n}`}}function _e(e){return!e||e.length===0?"":` \\citet{${e.join(",")}}`}function Ne(e){return e?` unless ${e}`:""}function we(e,n){const t=new Set;for(let o=0;o<e.length-1;o+=1){const i=e[o],s=e[o+1],r=n.matrix[i]?.[s];r?.caveat&&t.add(r.caveat)}if(t.size!==0)return Array.from(t).join(" OR ")}function de(e,n){const{languageIds:t}=n,o=[];for(let i=0;i<e.length-1;i+=1){const s=e[i],r=e[i+1],c=t.indexOf(s),a=t.indexOf(r),u=n.matrix[c]?.[a],f=u?.status??"unknown",h=u?.refs??[],d=u?.caveat;o.push(`${k(s)} transforms to ${k(r)} ${ue(f)}${Ne(d)}${_e(h)}.`)}return o.join(" ")}function wn(e,n){const t=[];return t.push("First, we show no polynomial transformation exists."),t.push(e.description),t.push(""),t.push("Now, we show a quasipolynomial transformation exists."),t.push(n.description),t.join(`
`)}function Je(e){throw new Error(e)}function Gt(e){return e?e.noPolyDescription?e.noPolyDescription:e.status==="no-poly-unknown-quasi"||e.status==="no-poly-quasi"?{description:e.description??"",refs:e.refs??[],derived:e.derived??!1}:null:null}function Kt(e){return e?e.quasiDescription?e.quasiDescription:e.status==="unknown-poly-quasi"||e.status==="no-poly-quasi"?{description:e.description??"",refs:e.refs??[],derived:e.derived??!1}:null:null}function en(e,n,t,o){if(n.length===0)return;const{languageIds:i}=e,s=n[0],r=n[n.length-1],c=fe(n,e),a=we(n,e),u=n.map(d=>i[d]),h=`${de(u,e)} ${o}`.trim();e.matrix[s][r]={status:t,refs:c,caveat:a,separatingFunctionIds:void 0,hidden:!1,derived:!0,description:h}}function Xt(e,n,t,o,i){const{languageIds:s}=e,r=k(s[n]),c=k(s[t]),a=Gt(i)??{description:i.description??"",refs:i.refs??[],derived:i.derived??!1},u=o.map(v=>s[v]),h=`${de(u,e)} Therefore a quasi-polynomial transformation exists from ${r} to ${c}.`,d=fe(o,e),g={description:h,refs:d,derived:!0},m=[...new Set([...a.refs,...g.refs])],y=we(o,e),l=i.caveat,p=new Set;if(l&&p.add(l),y)for(const v of y.split(" OR "))p.add(v.trim());const w=p.size>0?Array.from(p).join(" OR "):void 0,$=a.derived&&g.derived;e.matrix[n][t]={status:"no-poly-quasi",refs:m,caveat:w,separatingFunctionIds:i.separatingFunctionIds,hidden:!1,derived:$,noPolyDescription:a,quasiDescription:g,description:wn(a,g)}}function Wt(e,n,t){const{languageIds:o}=e,i=o.length;let s=0;for(let r=0;r<i;r+=1)for(let c=0;c<i;c+=1){if(r===c)continue;const a=e.matrix[r][c],u=a?.status??null,f=k(o[r]),h=k(o[c]);if(t.reach[r][c]&&!Ut(u)){if(u==="no-quasi"){const y=te(ne(r,c,t.parent[r]),r,c).map(p=>o[p]),l=de(y,e);Je(`Contradiction: ${l} Therefore ${f} transforms to ${h} in quasipolynomial time, but ${f} is marked as not transforming to ${h} in quasipolynomial time.`)}const d=te(ne(r,c,t.parent[r]),r,c),g=u==="no-poly-unknown-quasi"?"no-poly-quasi":"unknown-poly-quasi";if(u==="no-poly-unknown-quasi"&&a)Xt(e,r,c,d,a);else{const m=`Therefore a quasi-polynomial transformation exists from ${f} to ${h}.`;en(e,d,g,m)}s+=1;continue}if(n.reach[r][c]&&!Qt(u)){if(u==="no-poly-quasi"||u==="no-poly-unknown-quasi"||u==="no-quasi"){const y=te(ne(r,c,n.parent[r]),r,c).map(p=>o[p]),l=de(y,e);Je(`Contradiction: ${l} Therefore ${f} transforms to ${h} in polynomial time, but ${f} is marked as not transforming to ${h} in polynomial time.`)}const d=te(ne(r,c,n.parent[r]),r,c),g=`Therefore a polynomial transformation exists from ${f} to ${h}.`;en(e,d,"poly",g),s+=1}}return s}function Zt(e,n,t,o,i){const{adjacencyMatrix:s}=e,r=s.matrix[n][t],c=r?.status??null,a=s.languageIds,u=k(a[n]),f=k(a[t]),h=l=>{const p=s.matrix[n][t];s.matrix[n][t]={status:l,refs:p?.refs??[],hidden:p?.hidden??!1,derived:!0,description:p?.description,separatingFunctionIds:void 0};const w=gn(e);return s.matrix[n][t]=p??null,w},d=(l,p,w)=>{if(p.length<2)return`If ${u} transforms to ${f} ${ue(l)}, a contradiction arises.`;const $=p[0],v=p[p.length-1],b=k($),x=k(v),q=a.indexOf($),S=a.indexOf(v),I=s.matrix[q]?.[S],A=I?.status??"unknown",C=I?.refs??[],E=[];for(let H=0;H<p.length-1;H++){const J=p[H],$e=p[H+1];if(J===a[n]&&$e===a[t])continue;const Cn=a.indexOf(J),On=a.indexOf($e),qe=s.matrix[Cn]?.[On],Rn=qe?.status??"unknown",_n=qe?.refs??[],Nn=qe?.caveat;E.push(`${k(J)} transforms to ${k($e)} ${ue(Rn)}${Ne(Nn)}${_e(_n)}`)}const B=E.length>0?E.join(". ")+". ":"",W=ue(l),L=l==="poly"?"in polynomial time":"in at most quasi-polynomial time",Z=Yt(b,x,A);return`${B}If ${u} transforms to ${f} ${W}, then ${b} transforms to ${x} ${L}. ${Z}${Ne(w)}${_e(C)}.`},g=l=>{const p=l.map(A=>a.indexOf(A)).filter(A=>A>=0),w=we(p,s),$=l[0],v=l[l.length-1],b=a.indexOf($),x=a.indexOf(v),S=s.matrix[b]?.[x]?.caveat,I=new Set;if(w)for(const A of w.split(" OR "))I.add(A.trim());return S&&I.add(S),I.size>0?Array.from(I).join(" OR "):void 0},m=(l,p,w)=>{const $=w.map(q=>a.indexOf(q)).filter(q=>q>=0),v=fe($,s),b=g(w),x=d(p,w,b);s.matrix[n][t]={status:l,refs:v,caveat:b,hidden:!1,derived:!0,separatingFunctionIds:void 0,description:x.trim()}},y=l=>{const p=Kt(r)??{description:r?.description??"",refs:r?.refs??[],derived:r?.derived??!1},w=l.map(E=>a.indexOf(E)).filter(E=>E>=0),$=g(l),v=r?.caveat,b=new Set;if(v&&b.add(v),$)for(const E of $.split(" OR "))b.add(E.trim());const x=b.size>0?Array.from(b).join(" OR "):void 0,q=d("poly",l,x),S=fe(w,s),I={description:q,refs:S,derived:!0},A=[...new Set([...I.refs,...p.refs])],C=I.derived&&p.derived;s.matrix[n][t]={status:"no-poly-quasi",refs:A,caveat:x,hidden:!1,derived:C,separatingFunctionIds:r?.separatingFunctionIds,noPolyDescription:I,quasiDescription:p,description:wn(I,p)}};if(c===null||c==="unknown-both"){const l=h("poly");if(!l.ok){const w=l.witnessPath??[a[n],a[t]];return m("no-poly-unknown-quasi","poly",w),!0}const p=h("unknown-poly-quasi");if(!p.ok){const w=p.witnessPath??[a[n],a[t]];return m("no-quasi","unknown-poly-quasi",w),!0}return s.matrix[n][t]=r??null,!1}if(c==="unknown-poly-quasi"){const l=h("poly");if(!l.ok){const p=l.witnessPath??[a[n],a[t]];return y(p),!0}return s.matrix[n][t]=r,!1}if(c==="no-poly-unknown-quasi"){const l=h("no-poly-quasi");if(!l.ok){const p=l.witnessPath??[a[n],a[t]];return m("no-quasi","no-poly-quasi",p),!0}return s.matrix[n][t]=r,!1}return!1}function M(...e){const n=new Set;for(const t of e)t&&n.add(t);if(n.size!==0)return Array.from(n).join(" OR ")}function pe(e,n,t,o){const i=ne(e,n,t[e]),s=te(i,e,n);return we(s,o)}const Jt=new Set(["no-poly-unknown-quasi","no-poly-quasi","no-quasi"]),eo=new Set(["no-quasi","no-poly-quasi"]);function O(e,n){return e.properties?.queries?.[n]??e.properties?.transformations?.[n]}function Q(e,n,t){e.properties||(e.properties={}),e.properties.queries||(e.properties.queries={}),e.properties.queries[n]=t}function N(e,n){return e.properties?.queries?.[n]?.complexity??"unknown-to-us"}function U(e){return e==="poly"}function V(e){return F.has(e)}function K(e){return Jt.has(e)}function z(e){return eo.has(e)}function nn(e,n,t,o){let i=!1;const{adjacencyMatrix:s,languages:r}=e,c=he();for(const a of c)for(let u=0;u<r.length;u++){const f=r[u],h=f.id,d=s.indexByLanguage[h];if(d===void 0)continue;const g=N(f,a);if(o&&U(g)){const m=O(f,a);for(let y=0;y<r.length;y++){const l=r[y],p=l.id,w=s.indexByLanguage[p];if(w!==void 0&&w!==d&&n.reach[w][d]){const $=N(l,a);if(!U($)){const v=k(p),b=k(h),x=`${v} transforms to ${b} in polynomial time, and ${b} supports ${a} in polynomial time. Therefore ${v} supports ${a} in polynomial time.`,q=pe(w,d,n.parent,s),S=m?.caveat,I=M(q,S);Q(l,a,{complexity:"poly",refs:f.properties?.queries?.[a]?.refs??[],derived:!0,description:x,...I&&{caveat:I}}),i=!0}}}}if(!o&&V(g)){const m=O(f,a);for(let y=0;y<r.length;y++){const l=r[y],p=l.id,w=s.indexByLanguage[p];if(w!==void 0&&w!==d&&t.reach[w][d]){const $=N(l,a);if(V($)||z($))continue;const v=k(p),b=k(h),x=$==="no-poly-unknown-quasi"?"no-poly-quasi":"unknown-poly-quasi",q=`${v} transforms to ${b} in quasi-polynomial time, and ${b} supports ${a}. Therefore ${v} supports ${a} in at most quasi-polynomial time.`,S=pe(w,d,t.parent,s),I=m?.caveat,A=M(S,I);Q(l,a,{complexity:x,refs:f.properties?.queries?.[a]?.refs??[],derived:!0,description:q,...A&&{caveat:A}}),i=!0}}}}return i}function tn(e,n,t){let o=!1;for(const i of e.languages)for(const s of n){let r=!0,c="poly";const a=[];for(const g of s.antecedent){const m=O(i,g);if(!m){r=!1;break}a.push(m.caveat);const y=m.complexity;if(t){if(!U(y)){r=!1;break}}else{if(!V(y)){r=!1;break}(y==="unknown-poly-quasi"||y==="no-poly-quasi")&&(c=y)}}if(!r)continue;const f=O(i,s.consequent)?.complexity??"unknown-to-us",h=t?"poly":c;if(t?!U(f):!V(f)){const g=k(i.id),m=s.antecedent.join(", "),y=`Since ${g} supports ${m}, it also supports ${s.consequent}. ${s.description}`,l=M(...a);s.consequent in(G??{})?Q(i,s.consequent,{complexity:h,refs:s.refs,derived:!0,description:y,...l&&{caveat:l}}):(i.properties||(i.properties={}),i.properties.transformations||(i.properties.transformations={}),i.properties.transformations[s.consequent]={complexity:h,refs:s.refs,derived:!0,description:y,...l&&{caveat:l}}),o=!0}}return o}function no(e,n,t){let o=!1;const{adjacencyMatrix:i,languages:s}=e,r=he();for(const c of r)for(const a of s){const u=i.indexByLanguage[a.id];if(u===void 0)continue;const f=N(a,c),h=k(a.id);if(K(f)){const d=O(a,c);for(const g of s){if(g.id===a.id)continue;const m=i.indexByLanguage[g.id];if(m===void 0||!n.reach[u][m])continue;const y=N(g,c);if(K(y))continue;const l=k(g.id),p=`${h} does not support ${c} in polynomial time, and ${h} transforms to ${l} in polynomial time. If ${l} supported ${c} in polynomial time, then ${h} could too by transforming first. Therefore ${l} does not support ${c} in polynomial time.`,w=pe(u,m,n.parent,i),$=d?.caveat,v=M(w,$);Q(g,c,{complexity:"no-poly-unknown-quasi",refs:a.properties?.queries?.[c]?.refs??[],derived:!0,description:p,...v&&{caveat:v}}),o=!0}}if(z(f)){const d=O(a,c);for(const g of s){if(g.id===a.id)continue;const m=i.indexByLanguage[g.id];if(m===void 0||!t.reach[u][m])continue;const y=N(g,c);if(z(y))continue;const l=k(g.id),p=`${h} does not support ${c} in quasi-polynomial time, and ${h} transforms to ${l} in quasi-polynomial time. If ${l} supported ${c}, then ${h} could too by transforming first. Therefore ${l} does not support ${c} in quasi-polynomial time.`,w=pe(u,m,t.parent,i),$=d?.caveat,v=M(w,$);Q(g,c,{complexity:"no-quasi",refs:a.properties?.queries?.[c]?.refs??[],derived:!0,description:p,...v&&{caveat:v}}),o=!0}}}return o}function to(e,n){let t=!1;for(const o of e.languages){const i=k(o.id);for(const s of n){const r=O(o,s.consequent),c=r?.complexity??"unknown-to-us";if(K(c))for(let a=0;a<s.antecedent.length;a++){const u=s.antecedent[a],h=O(o,u)?.complexity??"unknown-to-us";if(K(h))continue;let d=!0;const g=[],m=[];for(let $=0;$<s.antecedent.length;$++){if($===a)continue;const v=s.antecedent[$];g.push(v);const b=O(o,v),x=b?.complexity??"unknown-to-us";if(!U(x)){d=!1;break}m.push(b?.caveat)}if(!d)continue;const y=g.length>0?` Since ${g.join(" and ")} ${g.length===1?"is":"are"} supported in polynomial time,`:"",l=`Since ${s.antecedent.join(" âˆ§ ")} â†’ ${s.consequent},${y} if ${i} cannot support ${s.consequent} in polynomial time, it cannot support ${u} in polynomial time either.`,p=M(r?.caveat,...m);u in(G??{})?Q(o,u,{complexity:"no-poly-unknown-quasi",refs:r?.refs??s.refs,derived:!0,description:l,...p&&{caveat:p}}):(o.properties||(o.properties={}),o.properties.transformations||(o.properties.transformations={}),o.properties.transformations[u]={complexity:"no-poly-unknown-quasi",refs:r?.refs??s.refs,derived:!0,description:l,...p&&{caveat:p}}),t=!0}if(z(c))for(let a=0;a<s.antecedent.length;a++){const u=s.antecedent[a],h=O(o,u)?.complexity??"unknown-to-us";if(z(h))continue;let d=!0;const g=[],m=[];for(let $=0;$<s.antecedent.length;$++){if($===a)continue;const v=s.antecedent[$];g.push(v);const b=O(o,v),x=b?.complexity??"unknown-to-us";if(!V(x)){d=!1;break}m.push(b?.caveat)}if(!d)continue;const y=g.length>0?` Since ${g.join(" and ")} ${g.length===1?"is":"are"} supported in quasi-polynomial time,`:"",l=`Since ${s.antecedent.join(" âˆ§ ")} â†’ ${s.consequent},${y} if ${i} cannot support ${s.consequent} in quasi-polynomial time, it cannot support ${u} in quasi-polynomial time either.`,p=M(r?.caveat,...m);u in(G??{})?Q(o,u,{complexity:"no-quasi",refs:r?.refs??s.refs,derived:!0,description:l,...p&&{caveat:p}}):(o.properties||(o.properties={}),o.properties.transformations||(o.properties.transformations={}),o.properties.transformations[u]={complexity:"no-quasi",refs:r?.refs??s.refs,derived:!0,description:l,...p&&{caveat:p}}),t=!0}}}return t}function oo(e){const{adjacencyMatrix:n,languages:t}=e,o=T(n,Y),i=T(n,F),s=he();for(const r of s)for(let c=0;c<t.length;c++){const a=t[c],u=a.id,f=n.indexByLanguage[u];if(f===void 0)continue;const h=N(a,r);for(let d=0;d<t.length;d++){const g=t[d],m=g.id,y=n.indexByLanguage[m];if(y===void 0||f===y)continue;const l=N(g,r),p=k(u),w=k(m);if(o.reach[f][y]){if(U(l)&&K(h))return{ok:!1,error:`Contradiction: ${p} transforms to ${w} in polynomial time, and ${w} supports ${r} in polynomial time, but ${p} is marked as not supporting ${r} in polynomial time.`};if(K(h)&&U(l))return{ok:!1,error:`Contradiction: ${p} does not support ${r} in polynomial time and transforms to ${w} in polynomial time, but ${w} is marked as supporting ${r} in polynomial time.`}}if(i.reach[f][y]){if(V(l)&&z(h))return{ok:!1,error:`Contradiction: ${p} transforms to ${w} in quasi-polynomial time, and ${w} supports ${r} in quasi-polynomial time, but ${p} is marked as not supporting ${r} in quasi-polynomial time.`};if(z(h)&&V(l))return{ok:!1,error:`Contradiction: ${p} does not support ${r} in quasi-polynomial time and transforms to ${w} in quasi-polynomial time, but ${w} is marked as supporting ${r} in quasi-polynomial time.`}}}}return{ok:!0}}function vn(e){const{adjacencyMatrix:n}=e;n.indexByLanguage=zt(n.languageIds),Vt(e.languages);const t=gn(e);if(!t.ok)throw new Error(t.error??"Adjacency consistency validation failed");let o=!0;for(;o;){const s=T(n,F),r=T(n,Y);o=Wt(n,r,s)>0}let i=!0;for(;i;){i=!1,T(n,F),T(n,Y);for(let s=0;s<n.languageIds.length;s+=1)for(let r=0;r<n.languageIds.length;r+=1)s!==r&&Zt(e,s,r)&&(i=!0)}return io(e),e}function io(e){const{adjacencyMatrix:n}=e;let t=!0;for(;t;){const r=T(n,Y),c=T(n,F);t=!1,nn(e,r,c,!0)&&(t=!0),tn(e,Ae,!0)&&(t=!0)}let o=!0;for(;o;){const r=T(n,Y),c=T(n,F);o=!1,nn(e,r,c,!1)&&(o=!0),tn(e,Ae,!1)&&(o=!0)}let i=!0;for(;i;){const r=T(n,Y),c=T(n,F);i=!1,no(e,r,c)&&(i=!0),to(e,Ae)&&(i=!0)}const s=oo(e);if(!s.ok)throw new Error(s.error??"Query consistency validation failed after propagation")}const so=pn,ro=vn;function ao(e){e.errors?.length&&console.warn("transformData validity check failed:",e.errors)}function re(e){return JSON.parse(JSON.stringify(e))}function co(e,n){const t={},o=n.map((i,s)=>{t[i]=s;const r=e.indexByLanguage[i],c=r!==void 0?e.matrix[r]:void 0;return n.map(a=>{if(!c)return null;const u=e.indexByLanguage[a];return u===void 0?null:c[u]??null})});return{languageIds:n,indexByLanguage:t,matrix:o}}function ae(e,n){const t=re(e),o=[];let i=!1;for(const s of t.languages){const r=n(s);r?o.push(r):i=!0}if(t.languages=o,i){const s=new Set(o.map(c=>c.id)),r=t.adjacencyMatrix.languageIds.filter(c=>s.has(c));t.adjacencyMatrix=co(t.adjacencyMatrix,r)}return t}function j(e,n){const t=re(e),{languageIds:o,matrix:i}=t.adjacencyMatrix;for(let s=0;s<o.length;s+=1){const r=o[s];for(let c=0;c<o.length;c+=1){const a=o[c];i[s][c]=n(i[s][c],r,a)}}return t}function Zo(e,n,t={},o={}){const i=re(e),s=n(i);if(t.checkValidity){const c=(o.validate??so)(s);if(!c.ok)return(o.onInvalid??ao)(c),null}return t.propagateImplicit?(o.propagate??ro)(s):s}function uo(e,n){return(t,o)=>o?ae(t,i=>{const s=dt(i.properties.queries,i.properties.transformations),c=(n==="query"?s.queries:s.transformations)?.find(f=>f.code===e);if(!c)return i;const u=`
${ct(t.complexities,c.complexity).emoji} ${e}`;return{...i,visual:{...i.visual,labelSuffix:(i.visual?.labelSuffix||"")+u}}}):t}function lo(e){return e.languages.map(n=>({id:`select-${n.name}`,name:n.name,description:`Show ${n.fullName}`,category:"Show Languages",defaultParam:!0,controlType:"checkbox",lambda:(t,o)=>o?t:ae(t,i=>i.name===n.name?null:i)}))}function fo(){return{id:"fill-unknown-operations",name:"Fill Unknown Operations",description:"Normalizes operation keys without adding unknown entries",hidden:!0,defaultParam:!0,lambda:(e,n)=>n?ae(e,t=>{const o=(i,s)=>{const r={};if(!i)return r;for(const[c,a]of Object.entries(s)){const u=i[c]||i[a.code];u&&(r[a.code]={complexity:u.complexity,...u.caveat&&{caveat:u.caveat},refs:u.refs??[],...u.description&&{description:u.description},...u.derived!=null&&{derived:u.derived},...u.dimmed!=null&&{dimmed:u.dimmed},...u.explicit!=null&&{explicit:u.explicit}})}return r};return{...t,properties:{queries:o(t.properties.queries,G),transformations:o(t.properties.transformations,se)}}}):e}}function Jo(e){const n=e.filter(i=>i.category),t=new Map;return n.forEach(i=>{const s=i.category;t.has(s)||t.set(s,[]),t.get(s).push(i)}),Array.from(t.entries()).map(([i,s])=>({name:i,filters:s}))}function xn(e,n,t){const o=`visualize-${e.code.toLowerCase().replace(/[^a-z0-9]/g,"-")}`,i=e.description||`Display ${e.name} (${e.code}) status on nodes`;return{id:o,name:`${e.name} (${e.code})`,description:i,category:t,defaultParam:!1,controlType:"checkbox",lambda:uo(e.code,n)}}function po(e){return e.map(n=>xn(n,"query","Visualize Queries"))}function mo(e){return e.map(n=>xn(n,"transformation","Visualize Transformations"))}const yo=po([{code:"CO",name:"Consistency"},{code:"VA",name:"Validity"},{code:"CE",name:"Clausal Entailment"},{code:"CT",name:"Model Counting"}]),go=mo([{code:"CD",name:"Conditioning"},{code:"FO",name:"Forgetting"},{code:"âˆ§C",name:"Conjunction"},{code:"Â¬C",name:"Negation"}]);function bn(e,n){const{indexByLanguage:t,matrix:o}=n.adjacencyMatrix;return(i,s,r)=>{if(!i)return null;const c=e(i),a=t[s],u=t[r];if(a===void 0||u===void 0)return i;const f=o[u]?.[a]??null,h=e(f);return c&&h?null:i}}const ho={id:"poly-display",name:"Polynomial Display",description:"Control how polynomial and quasipolynomial complexity edges are shown",category:"Visibility",defaultParam:"polytime-vs-not",controlType:"dropdown",options:[{value:"include-quasipolynomial",label:"Also include quasipolynomial time",description:"Show all edge types as-is"},{value:"polytime-vs-not",label:"Polytime vs not polytime",description:"Collapse to polynomial, not polynomial, or unknown"}],lambda:(e,n)=>{if(n==="include-quasipolynomial")return e;const t=j(e,i=>{if(!i)return null;let s=i.status;switch(i.status){case"poly":break;case"no-poly-unknown-quasi":case"no-poly-quasi":case"no-quasi":s="not-poly";break;case"unknown-poly-quasi":case"unknown-both":s="unknown";break}return s===i.status?i:{...i,status:s}}),o=t.complexities.poly;return o&&(t.complexities={...t.complexities,poly:{...o,notation:"$\\leq$"}}),t}},wo={id:"manage-unknowns",name:"Manage Unknowns",description:"Control how edges with unknown status are treated",category:"Visibility",defaultParam:"omit-all",defaultParamMatrix:"expressively",controlType:"dropdown",options:[{value:"omit-all",label:"Omit all",description:"Hide edges with unknown or partially unknown status"},{value:"expressively",label:"Expressively",description:"Show unknown edges without modification"},{value:"optimistically",label:"Optimistically",description:"Assume unknown edges behave as positively as possible"},{value:"pessimistically",label:"Pessimistically",description:"Assume unknown edges behave as restrictively as possible"}],lambda:(e,n)=>n==="expressively"?e:j(e,t=>{if(!t)return null;switch(n){case"omit-all":return t.status!=="unknown-poly-quasi"&&t.status!=="unknown-both"&&t.status!=="no-poly-unknown-quasi"?t:null;case"optimistically":{let o=t.status;return t.status==="no-poly-unknown-quasi"?o="no-poly-quasi":(t.status==="unknown-poly-quasi"||t.status==="unknown-both")&&(o="poly"),o===t.status?t:{...t,status:o}}case"pessimistically":{let o=t.status;return t.status==="unknown-both"||t.status==="no-poly-unknown-quasi"?o="no-quasi":t.status==="unknown-poly-quasi"&&(o="no-poly-quasi"),o===t.status?t:{...t,status:o}}default:return t}})},vo={id:"positive-results-only",name:"Positive Results Only",description:"Hide negative/unknown results (keep only edges that assert existence of a transformation)",category:"Visibility",defaultParam:!1,controlType:"checkbox",lambda:(e,n)=>n?j(e,t=>{if(!t)return null;switch(t.status){case"no-poly-unknown-quasi":case"no-quasi":case"not-poly":case"unknown-both":return null;default:return t}}):e},xo={id:"omit-incomparable",name:"Omit Incomparable",description:"Omit edges where both directions are no-quasi",category:"Edge Visibility",defaultParam:!0,defaultParamMatrix:!1,controlType:"checkbox",lambda:(e,n)=>n?j(e,bn(o=>!o||o.status==="no-quasi",e)):e},bo={id:"omit-separator-functions",name:"Omit Separator Functions",description:"Hide all separator functions from edges",category:"Visibility",defaultParam:!0,controlType:"checkbox",lambda:(e,n)=>n?j(e,t=>t?t.separatingFunctionIds&&t.separatingFunctionIds.length>0?{...t,separatingFunctionIds:[]}:t:null):e},$o={id:"omit-marked-edges",name:"Omit Marked Edges",description:"Omit edges that have been marked as hidden",category:"Edge Visibility",defaultParam:!0,controlType:"checkbox",hidden:!0,lambda:(e,n)=>n?j(e,t=>!t||t.hidden?null:t):e},qo={id:"omit-implicit-edges",name:"Omit Implicit Edges",description:"Omit edges where both directions were inferred by propagation",category:"Edge Visibility",defaultParam:!0,defaultParamMatrix:!1,controlType:"checkbox",lambda:(e,n)=>n?j(e,bn(o=>!o||o.derived===!0,e)):e},So={id:"implicit-edge-treatment",name:"Implicit Edge Treatment",description:"Control how implicit (derived) vs explicit edges are visually distinguished",category:"Visibility",defaultParam:"none",defaultParamMatrix:"gray",controlType:"dropdown",options:[{value:"none",label:"None",description:"No visual distinction between implicit and explicit edges"},{value:"gray",label:"Gray implicit",description:"Show implicit edges with gray stripes"},{value:"highlight-explicit",label:"Highlight explicit",description:"Add golden border to explicit (non-derived) edges"}],lambda:(e,n)=>{if(n==="none")return e;let t=j(e,o=>{if(!o)return null;if(n==="gray"){if(o.derived)return{...o,dimmed:!0}}else if(n==="highlight-explicit"&&!o.derived)return{...o,explicit:!0};return o});return t=ae(t,o=>{const i=s=>{const r={};for(const[c,a]of Object.entries(s))n==="gray"&&a.derived?r[c]={...a,dimmed:!0}:n==="highlight-explicit"&&!a.derived?r[c]={...a,explicit:!0}:r[c]=a;return r};return{...o,properties:{...o.properties,queries:i(o.properties.queries??{}),transformations:i(o.properties.transformations??{})}}}),t}};function Io(e,n){const{adjacencyMatrix:t}=e,o=t.indexByLanguage[n];if(o===void 0)return!1;const i=t.matrix[o];if(i){for(let s=0;s<t.languageIds.length;s++)if(i[s])return!0}for(let s=0;s<t.languageIds.length;s++)if(t.matrix[s]?.[o])return!0;return!1}const ko={id:"hide-in-progress",name:"Hide In Progress Languages",description:"Hide languages that have no edges (not yet connected to the graph)",category:"Visibility",defaultParam:!0,controlType:"checkbox",lambda:(e,n)=>n?ae(e,t=>Io(e,t.id)?t:null):e},Eo=[ko,wo,xo,qo,So,vo,ho,bo,$o];function Pe(e){return e==="poly"?"poly":e==="no-poly-quasi"||e==="unknown-poly-quasi"?"quasi":null}function $n(e){return e==="no-quasi"}function qn(e,n,t){const o=e.matrix[n]?.[t],i=e.matrix[t]?.[n];if(!o||!i||o.hidden||i.hidden)return null;const s=Pe(o.status);return!s||!$n(i.status)?null:s}const Ao={id:"omit-transitive-edges",name:"Omit Transitive Edges",description:"Hide edges that are redundant due to transitivity",category:"Edge Visibility",defaultParam:!0,defaultParamMatrix:!1,controlType:"checkbox",lambda:(e,n)=>{const t=re(e),{adjacencyMatrix:o}=t;if(!n){for(let i=0;i<o.languageIds.length;i+=1){const s=o.matrix[i];s&&s.forEach(r=>{r&&(r.hidden=!1)})}return t}To(o);for(let i=0;i<o.languageIds.length;i+=1){const s=o.matrix[i];if(!s)continue;const r=[];s.forEach((c,a)=>{if(!c||a===i||c.hidden)return;const u=Pe(c.status);u&&r.push({targetIndex:a,edgeType:u})});for(const{targetIndex:c,edgeType:a}of r){const u=o.matrix[i][c];if(!u||u.hidden)continue;const f=u.hidden??!1;u.hidden=!0,Co(o,i,c,a)||(u.hidden=f)}}return t}};function To(e){for(let n=0;n<e.languageIds.length;n+=1){const t=e.matrix[n];if(!t)continue;const o=[];for(let i=0;i<t.length;i+=1){if(i===n)continue;const s=qn(e,n,i);s&&o.push({targetIndex:i,edgeType:s})}for(const{targetIndex:i,edgeType:s}of o){const r=e.matrix[n][i];if(!r||r.hidden)continue;const c=r.hidden??!1;if(r.hidden=!0,!Oo(e,n,i,s)){r.hidden=c;continue}const u=e.matrix[i]?.[n];u&&$n(u.status)&&(u.hidden=!0)}}}function Co(e,n,t,o){const i=new Set,s=[n];for(i.add(n);s.length>0;){const r=s.shift(),c=e.matrix[r];if(c)for(let a=0;a<c.length;a++){const u=c[a];if(!u||a===n||i.has(a)||u.hidden)continue;const f=Pe(u.status);if(!f)continue;if(o==="poly"?f==="poly":f==="poly"||f==="quasi"){if(a===t)return!0;i.add(a),s.push(a)}}}return!1}function Oo(e,n,t,o){const i=new Set,s=[n];for(i.add(n);s.length>0;){const r=s.shift(),c=e.matrix[r];if(c)for(let a=0;a<c.length;a+=1){if(a===n||i.has(a))continue;const u=qn(e,r,a);if(!(!u||!(o==="poly"?u==="poly":u==="poly"||u==="quasi"))){if(a===t)return!0;i.add(a),s.push(a)}}}return!1}const Ro=[Ao],_o=[fo(),...yo,...go,...Ro],No=bt;function ei(){const e=lo(No);return[..._o,...e]}function ni(){return Eo}const Fe="kcm_contribute_queue_v1",Sn="kcm_contributor_info_v1",me="kcm_contribute_preview_dataset_v1";function ve(e){return typeof localStorage>"u"?null:localStorage.getItem(e)}function jo(e,n){typeof localStorage>"u"||localStorage.setItem(e,n)}function le(e){typeof localStorage>"u"||localStorage.removeItem(e)}function ti(){return ve(Fe)!==null}function Lo(e){if(!Array.isArray(e?.entries)||e.entries.length===0)throw new Error("Stored queue is missing ordered entries.");return e.entries}function oi(){const e=ve(Fe);if(!e)return null;try{const n=JSON.parse(e);return{entries:Lo(n),customTags:n.customTags||[],modifiedRelations:n.modifiedRelations||[],submissionId:typeof n.submissionId=="string"?n.submissionId:void 0,supersedesSubmissionId:typeof n.supersedesSubmissionId=="string"?n.supersedesSubmissionId:null}}catch(n){return console.error("Failed to load queued changes:",n),null}}function ii(){le(Fe),le(me),le(Sn)}function si(){const e=ve(Sn);if(!e)return null;try{return JSON.parse(e)}catch(n){return console.error("Failed to load contributor info:",n),null}}function ri(e){if(e===null){le(me);return}try{jo(me,JSON.stringify(e))}catch(n){console.error("Failed to persist preview dataset:",n)}}function ai(){const e=ve(me);if(!e)return null;try{return JSON.parse(e)}catch(n){return console.error("Failed to load preview dataset:",n),null}}const In="kcm_submission_history_v1",De=10,_=Array.isArray,ce=e=>!!e&&typeof e=="object";function Po(e){return ce(e)&&typeof e.name=="string"}function Fo(e){return ce(e)&&typeof e.sourceId=="string"&&typeof e.targetId=="string"&&typeof e.status=="string"&&Array.isArray(e.refs)}function kn(e){return ce(e)&&typeof e.shortName=="string"&&typeof e.name=="string"&&typeof e.description=="string"&&Array.isArray(e.refs)}function En(e){return ce(e)&&typeof e.bibtex=="string"&&typeof e.title=="string"&&typeof e.href=="string"}function ie(e){return e.map(n=>({...n,definitionRefs:[...n.definitionRefs],queries:Object.fromEntries(Object.entries(n.queries).map(([t,o])=>[t,{...o,refs:[...o.refs]}])),transformations:Object.fromEntries(Object.entries(n.transformations).map(([t,o])=>[t,{...o,refs:[...o.refs]}])),tags:n.tags.map(t=>({...t,refs:[...t.refs]})),existingReferences:[...n.existingReferences]}))}function xe(e){return e.map(n=>({...n,refs:[...n.refs],separatingFunctionIds:n.separatingFunctionIds?[...n.separatingFunctionIds]:void 0}))}function An(e){return e.map(n=>({...n,refs:[...n.refs]}))}function be(e){return e.map(n=>({...n,refs:[...n.refs]}))}function Me(e){return e.map(n=>({...n}))}function Tn(e){return e.map(n=>{switch(n.kind){case"language:new":case"language:edit":return{...n,payload:ie([n.payload])[0]};case"relationship":return{...n,payload:xe([n.payload])[0]};case"separator":return{...n,payload:be([n.payload])[0]};case"reference":return{...n,payload:Me([n.payload])[0]}}})}function Do(e){if(!_(e))return[];const n=[];let t=0;for(const o of e){if(!ce(o))continue;const i=o,s=typeof i.id=="string"?i.id:`history-entry-${t++}`,r=i.kind;switch(r){case"language:new":case"language:edit":Po(i.payload)&&n.push({id:s,kind:r,payload:ie([i.payload])[0]});break;case"relationship":Fo(i.payload)&&n.push({id:s,kind:r,payload:xe([i.payload])[0]});break;case"separator":kn(i.payload)&&n.push({id:s,kind:r,payload:be([i.payload])[0]});break;case"reference":En(i.payload)&&n.push({id:s,kind:r,payload:Me([i.payload])[0]});break}}return n}function Mo(e){if(!e||typeof e!="object")return null;const n=e,t=typeof n.id=="string"?n.id:null,o=typeof n.createdAt=="string"?n.createdAt:null;if(!t||!o)return null;const i=n.payload;if(!i||typeof i!="object")return null;const s=typeof i.submissionId=="string"?i.submissionId:t,r=typeof i.supersedesSubmissionId=="string"?i.supersedesSubmissionId:null,c=i.contributor,a=c&&typeof c=="object"?{email:typeof c.email=="string"?c.email:"",github:typeof c.github=="string"?c.github:"",note:typeof c.note=="string"?c.note:""}:{email:"",github:"",note:""},u=v=>_(v)?ie(v.filter(b=>!!b&&typeof b=="object")):[],f=v=>_(v)?xe(v.filter(b=>!!b&&typeof b=="object")):[],h=v=>_(v)?v.filter(b=>typeof b=="string"):[],d=v=>_(v)?Me(v.filter(b=>En(b))):[],g=v=>_(v)?An(v.filter(b=>!!b&&typeof b=="object")):[],m=v=>_(v)?be(v.filter(b=>kn(b))):[],y={submissionId:s,supersedesSubmissionId:r,languagesToAdd:u(i.languagesToAdd),languagesToEdit:u(i.languagesToEdit),relationships:f(i.relationships),newReferences:d(i.newReferences),newSeparatingFunctions:m(i.newSeparatingFunctions),customTags:g(i.customTags),modifiedRelations:h(i.modifiedRelations),contributor:a,queueEntries:void 0},l=Do(i.queueEntries);if(l.length===0)return console.warn("Skipping submission history entry without queue entries",t),null;y.queueEntries=l;const p=n.summary,w=p&&typeof p=="object"?{languagesToAdd:Number(p.languagesToAdd)||y.languagesToAdd.length,languagesToEdit:Number(p.languagesToEdit)||y.languagesToEdit.length,relationships:Number(p.relationships)||y.relationships.length,newReferences:Number(p.newReferences)||y.newReferences.length}:{languagesToAdd:y.languagesToAdd.length,languagesToEdit:y.languagesToEdit.length,relationships:y.relationships.length,newReferences:y.newReferences.length},$=typeof n.supersededBySubmissionId=="string"?n.supersededBySubmissionId:void 0;return{id:t,createdAt:o,summary:w,payload:y,supersedesSubmissionId:r,supersededBySubmissionId:$}}function Qo(e){return _(e)?e.map(t=>Mo(t)).filter(t=>t!==null).sort((t,o)=>t.createdAt<o.createdAt?1:-1).slice(0,De):[]}function Uo(){if(typeof localStorage>"u")return[];try{const e=localStorage.getItem(In);return e?Qo(JSON.parse(e)):[]}catch(e){return console.warn("Failed to load submission history",e),[]}}function Vo(e){if(!(typeof localStorage>"u"))try{localStorage.setItem(In,JSON.stringify(e.slice(0,De)))}catch(n){console.warn("Failed to save submission history",n)}}function zo(e){const n=new Date().toISOString();return{id:e.submissionId,createdAt:n,summary:{languagesToAdd:e.languagesToAdd.length,languagesToEdit:e.languagesToEdit.length,relationships:e.relationships.length,newReferences:e.newReferences.length},payload:{...e,languagesToAdd:ie(e.languagesToAdd),languagesToEdit:ie(e.languagesToEdit),relationships:xe(e.relationships),newReferences:[...e.newReferences],newSeparatingFunctions:be(e.newSeparatingFunctions),customTags:An(e.customTags),modifiedRelations:[...e.modifiedRelations],contributor:{...e.contributor},queueEntries:e.queueEntries?Tn(e.queueEntries):void 0},supersedesSubmissionId:e.supersedesSubmissionId??null,supersededBySubmissionId:void 0}}function ci(e){const n=Uo(),t=zo(e),o=n.filter(r=>r.id!==t.id);if(t.supersedesSubmissionId){const r=o.find(c=>c.id===t.supersedesSubmissionId);r&&(r.supersededBySubmissionId=t.id)}const s=[t,...o].slice(0,De);return Vo(s),s}function ui(e){if(!Array.isArray(e.queueEntries)||e.queueEntries.length===0)throw new Error("Submission history entry is missing queueEntries.");return Tn(e.queueEntries)}function Te(e,n){const t=[];for(const o of e.definitionRefs){const i=n.get(o);i&&t.push(i)}return{id:hn(e.name),name:e.name,fullName:e.fullName,definition:e.definition,definitionRefs:[...e.definitionRefs],properties:{queries:e.queries,transformations:e.transformations},tags:e.tags,references:t}}function li(e,n){const t=re(e),o=()=>{for(const d of t.languages){const g=d.properties?.queries;if(g&&typeof g=="object")for(const y of Object.values(g)){const l=y?.complexity;(typeof l!="string"||!Be(l))&&(y.complexity="unknown-to-us")}const m=d.properties?.transformations;if(m&&typeof m=="object")for(const y of Object.values(m)){const l=y?.complexity;(typeof l!="string"||!Be(l))&&(y.complexity="unknown-to-us")}}},i=d=>{const{adjacencyMatrix:g}=t;if(d in g.indexByLanguage)return;const m=g.languageIds.length;g.languageIds.push(d),g.indexByLanguage[d]=m;for(const y of g.matrix)y.push(null);g.matrix.push(new Array(m+1).fill(null))},s=new Map;if(t.references)for(const d of t.references)s.set(d.id,d);const r=new Set(s.keys()),c=new Map;if(t.separatingFunctions)for(const d of t.separatingFunctions)c.set(d.shortName,d);const a=new Set(n.modifiedRelations??[]),u=d=>{const g={shortName:d.shortName,name:d.name,description:d.description,refs:[...d.refs]};c.set(g.shortName,g),t.separatingFunctions=[...t.separatingFunctions??[],g]},f=d=>{i(d.sourceId),i(d.targetId);const g=t.adjacencyMatrix.indexByLanguage[d.sourceId],m=t.adjacencyMatrix.indexByLanguage[d.targetId];if(g===void 0||m===void 0)return;const y=`${d.sourceId}->${d.targetId}`;if(a.size>0&&!a.has(y)&&t.adjacencyMatrix.matrix[g]?.[m])return;if(!d.status||d.status==="unknown-to-us"){t.adjacencyMatrix.matrix[g][m]=null;return}const l=[];if(d.separatingFunctionIds&&d.separatingFunctionIds.length>0)for(const w of d.separatingFunctionIds)c.has(w)&&l.push(w);const p={status:d.status,description:d.description,caveat:d.caveat,refs:[...d.refs],separatingFunctionIds:l.length>0?l:void 0,derived:!1};t.adjacencyMatrix.matrix[g][m]=p};for(const d of n.entries)switch(d.kind){case"reference":{const g=d.payload,m=it(g.bibtex,r);r.add(m);const y={id:m,title:g.title,href:g.href,bibtex:g.bibtex};s.set(m,y),t.references=[...t.references??[],y];break}case"separator":{u(d.payload);break}case"language:new":{const g=Te(d.payload,s);t.languages.push(g),i(g.id);break}case"language:edit":{const g=hn(d.payload.name),m=t.languages.findIndex(y=>y.id===g);if(m===-1){const y=Te(d.payload,s);t.languages.push(y),i(y.id)}else t.languages[m]=Te(d.payload,s);break}case"relationship":{f(d.payload);break}}o();const h=pn(t);if(!h.ok){const d=h.errors?.join("; ")??"unknown structural error";throw new Error(`Contribution queue produced an invalid dataset: ${d}`)}return vn(t)}export{lo as A,ii as B,X as C,si as D,ci as E,G as Q,se as T,yt as a,wt as b,Ko as c,Wo as d,Go as e,Fe as f,hn as g,Sn as h,Yo as i,li as j,No as k,Uo as l,oi as m,ui as n,Xo as o,ct as p,dt as q,lt as r,ri as s,Zo as t,Jo as u,ei as v,ni as w,ti as x,ai as y,_o as z};
