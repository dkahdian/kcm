import"../chunks/DsnmJJEf.js";import"../chunks/BW010KKr.js";import{G as p,H as g,I as d,$ as h,J as s,K as e,L as i,M as a}from"../chunks/DyTkIbAe.js";import{M as u}from"../chunks/OZbp0Vnk.js";var w=p(`<div class="about-page svelte-cwls5q"><header class="about-header svelte-cwls5q"><a href="/" class="back-link svelte-cwls5q">← Back to Map</a> <h1 class="svelte-cwls5q">About the Knowledge Compilation Map</h1></header> <main class="about-content svelte-cwls5q"><section class="svelte-cwls5q"><h2 class="svelte-cwls5q">What is this?</h2> <p class="svelte-cwls5q">The Knowledge Compilation Map is an interactive tool for exploring <strong>succinctness relations</strong> and <strong>tractability results</strong> across propositional language classes used in knowledge compilation. It is based on
				the foundational work of <a href="https://doi.org/10.1613/jair.1391" target="_blank" rel="noopener" class="svelte-cwls5q">Darwiche &amp; Marquis (2002)</a> and incorporates results from subsequent research.</p></section> <section class="svelte-cwls5q"><h2 class="svelte-cwls5q">Languages</h2> <p class="svelte-cwls5q">The map covers roughly 28 propositional language classes — including NNF, DNNF,
				d-DNNF, FBDD, OBDD, SDD, CNF, DNF, and others — organized in a directed graph
				where edges represent whether one language can be polynomially or
				quasi-polynomially compiled into another.</p></section> <section class="svelte-cwls5q"><h2 class="svelte-cwls5q">Operations</h2> <p class="svelte-cwls5q">For each language, the map tracks support for standard <strong>queries</strong> (CO, VA, CE, IM, EQ, SE, CT, ME) and <strong>transformations</strong> (CD, FO, SFO, ∧C, ∧BC, ∨C, ∨BC, ¬C), indicating whether each can be
				performed in polynomial time, quasi-polynomial time, or not at all.</p></section> <section class="svelte-cwls5q"><h2 class="svelte-cwls5q">Automated reasoning</h2> <p class="svelte-cwls5q">Starting from a hand-curated knowledge base of published results, the tool
				validates consistency and propagates derived facts through fixed-point algorithms:</p> <ul class="svelte-cwls5q"><li class="svelte-cwls5q"><strong>Upgrade propagation</strong> — transitive closure over succinctness
					edges infers new polynomial/quasi-polynomial compilations.</li> <li class="svelte-cwls5q"><strong>Downgrade propagation</strong> — contradiction-based reasoning rules out
					compilations that would violate known negative results.</li> <li class="svelte-cwls5q"><strong>Operation propagation</strong> — query and transformation support is
					inferred via succinctness relations and operation implication lemmas.</li></ul> <p class="svelte-cwls5q">All derived entries are tagged with human-readable proof descriptions and
				literature references.</p></section> <section class="svelte-cwls5q"><h2 class="svelte-cwls5q">Separating functions</h2> <p class="svelte-cwls5q">Exponential succinctness gaps between languages are witnessed by <strong>separating function families</strong> — Boolean functions like <!>, Clique, Parity, and others — that have compact
				representations in one language but provably require exponential size in another.</p></section> <section class="svelte-cwls5q"><h2 class="svelte-cwls5q">Contributing</h2> <p class="svelte-cwls5q">Know of a new result? Use the <a href="/contribute" class="svelte-cwls5q">contribution workflow</a> to propose new edges, operation
				results, or language additions. Submissions are reviewed before integration.</p></section> <section class="svelte-cwls5q"><h2 class="svelte-cwls5q">Links</h2> <ul class="svelte-cwls5q"><li class="svelte-cwls5q"><a href="https://github.com/dkahdian/kcm" target="_blank" rel="noopener" class="svelte-cwls5q">GitHub repository</a></li> <li class="svelte-cwls5q"><a href="https://doi.org/10.1613/jair.989" target="_blank" rel="noopener" class="svelte-cwls5q">Darwiche &amp; Marquis, "A Knowledge Compilation Map" (JAIR, 2002)</a></li></ul></section></main></div>`);function k(r){var t=w();g(v=>{h.title="About — Knowledge Compilation Map"});var l=s(e(t),2),o=s(e(l),8),n=s(e(o),2),c=s(e(n),3);u(c,{text:"OR_n"}),i(),a(n),a(o),i(4),a(l),a(t),d(r,t)}export{k as component};
