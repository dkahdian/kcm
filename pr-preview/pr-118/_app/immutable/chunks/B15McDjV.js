import{T as an,p as jn,bk as rn,Q as Ee,v as M,F as Dn,w as Pn,a1 as Ve,a3 as Fn,N as Mn,O as Qn,P as ze,R as Ae,D as oe,ai as Un,aI as Bn,A as Ne,W as Vn,bl as ve,bm as be,U as zn,ah as He,aT as Hn,af as Ye,aA as cn,i as Yn,X as un,Y as Gn,bn as Kn,bo as Te,q as Xn,C as ln,bp as Wn,at as Zn,bq as Jn,az as et,br as nt,a6 as tt}from"./DyTkIbAe.js";import{d as U,b as ot,a as it,g as st}from"./D7eFSXeg.js";const at=!0;function Zo(e,n){return n}function rt(e,n,t){for(var o=e.items,i=[],s=n.length,a=0;a<s;a++)Jn(n[a].e,i,!0);var c=s>0&&i.length===0&&t!==null;if(c){var r=t.parentNode;et(r),r.append(t),o.clear(),_(e,n[0].prev,n[s-1].next)}nt(i,()=>{for(var u=0;u<s;u++){var l=n[u];c||(o.delete(l.k),_(e,l.prev,l.next)),ln(l.e,!c)}})}function Jo(e,n,t,o,i,s=null){var a=e,c={flags:n,items:new Map,first:null},r=(n&rn)!==0;if(r){var u=e;a=M?Ee(Dn(u)):u.appendChild(an())}M&&Pn();var l=null,h=!1,d=new Map,g=Fn(()=>{var y=t();return Yn(y)?y:y==null?[]:cn(y)}),p,m;function f(){ct(m,p,c,d,a,i,n,o,t),s!==null&&(p.length===0?l?un(l):l=Ne(()=>s(a)):l!==null&&Gn(l,()=>{l=null}))}jn(()=>{m??=tt,p=Ve(g);var y=p.length;if(h&&y===0)return;h=y===0;let w=!1;if(M){var q=Mn(a)===Qn;q!==(y===0)&&(a=ze(),Ee(a),Ae(!1),w=!0)}if(M){for(var v=null,b,$=0;$<y;$++){if(oe.nodeType===Un&&oe.data===Bn){a=oe,w=!0,Ae(!1);break}var x=p[$],k=o(x,$);b=_e(oe,c,v,null,x,k,$,i,n,t),c.items.set(k,b),v=b}y>0&&Ee(ze())}if(M)y===0&&s&&(l=Ne(()=>s(a)));else if(Vn()){var E=new Set,T=zn;for($=0;$<y;$+=1){x=p[$],k=o(x,$);var O=c.items.get(k)??d.get(k);O?(n&(ve|be))!==0&&fn(O,x,$,n):(b=_e(null,c,null,null,x,k,$,i,n,t,!0),d.set(k,b)),E.add(k)}for(const[A,Y]of c.items)E.has(A)||T.skipped_effects.add(Y.e);T.add_callback(f)}else f();w&&Ae(!0),Ve(g)}),M&&(a=oe)}function ct(e,n,t,o,i,s,a,c,r){var u=(a&Wn)!==0,l=(a&(ve|be))!==0,h=n.length,d=t.items,g=t.first,p=g,m,f=null,y,w=[],q=[],v,b,$,x;if(u)for(x=0;x<h;x+=1)v=n[x],b=c(v,x),$=d.get(b),$!==void 0&&($.a?.measure(),(y??=new Set).add($));for(x=0;x<h;x+=1){if(v=n[x],b=c(v,x),$=d.get(b),$===void 0){var k=o.get(b);if(k!==void 0){o.delete(b),d.set(b,k);var E=f?f.next:p;_(t,f,k),_(t,k,E),Ce(k,E,i),f=k}else{var T=p?p.e.nodes_start:i;f=_e(T,t,f,f===null?t.first:f.next,v,b,x,s,a,r)}d.set(b,f),w=[],q=[],p=f.next;continue}if(l&&fn($,v,x,a),($.e.f&Te)!==0&&(un($.e),u&&($.a?.unfix(),(y??=new Set).delete($))),$!==p){if(m!==void 0&&m.has($)){if(w.length<q.length){var O=q[0],A;f=O.prev;var Y=w[0],ee=w[w.length-1];for(A=0;A<w.length;A+=1)Ce(w[A],O,i);for(A=0;A<q.length;A+=1)m.delete(q[A]);_(t,Y.prev,ee.next),_(t,f,Y),_(t,ee,O),p=O,f=ee,x-=1,w=[],q=[]}else m.delete($),Ce($,p,i),_(t,$.prev,$.next),_(t,$,f===null?t.first:f.next),_(t,f,$),f=$;continue}for(w=[],q=[];p!==null&&p.k!==b;)(p.e.f&Te)===0&&(m??=new Set).add(p),q.push(p),p=p.next;if(p===null)continue;$=p}w.push($),f=$,p=$.next}if(p!==null||m!==void 0){for(var F=m===void 0?[]:cn(m);p!==null;)(p.e.f&Te)===0&&F.push(p),p=p.next;var ne=F.length;if(ne>0){var G=(a&rn)!==0&&h===0?i:null;if(u){for(x=0;x<ne;x+=1)F[x].a?.measure();for(x=0;x<ne;x+=1)F[x].a?.fix()}rt(t,F,G)}}u&&Xn(()=>{if(y!==void 0)for($ of y)$.a?.apply()}),e.first=t.first&&t.first.e,e.last=f&&f.e;for(var te of o.values())ln(te.e);o.clear()}function fn(e,n,t,o){(o&ve)!==0&&He(e.v,n),(o&be)!==0?He(e.i,t):e.i=t}function _e(e,n,t,o,i,s,a,c,r,u,l){var h=(r&ve)!==0,d=(r&Kn)===0,g=h?d?Hn(i,!1,!1):Ye(i):i,p=(r&be)===0?a:Ye(a),m={i:p,v:g,k:s,a:null,e:null,prev:t,next:o};try{if(e===null){var f=document.createDocumentFragment();f.append(e=an())}return m.e=Ne(()=>c(e,g,p,u),M),m.e.prev=t&&t.e,m.e.next=o&&o.e,t===null?l||(n.first=m):(t.next=m,t.e.next=m.e),o!==null&&(o.prev=m,o.e.prev=m.e),m}finally{}}function Ce(e,n,t){for(var o=e.next?e.next.e.nodes_start:t,i=n?n.e.nodes_start:t,s=e.e.nodes_start;s!==null&&s!==o;){var a=Zn(s);i.before(s),s=a}}function _(e,n,t){n===null?e.first=t:(n.next=t,n.e.next=t&&t.e),t!==null&&(t.prev=n,t.e.prev=n&&n.e)}const ei=at,Z={poly:{code:"poly",label:"Polynomial",description:"Polynomial compilation exists",opDescription:"Polynomial transformation exists",notation:"$\\leq_p$",emoji:"ðŸŸ¢",color:"#22c55e",pastel:"#dcfce7",cssClass:"complexity-poly",arrow:"triangle",dashed:!1},"no-poly-unknown-quasi":{code:"no-poly-unknown-quasi",label:"No Poly, Quasi Unknown",description:"No polynomial compilation; quasi-polynomial unknown",opDescription:"No polynomial transformation; quasi-polynomial unknown",notation:"$\\not\\leq_p$ Â· $\\leq_q^?$",emoji:"âš ï¸",color:"#ef4444",pastel:"#fee2e2",cssClass:"complexity-no-poly-unknown-quasi",arrow:"tee",dashed:!0},"no-poly-quasi":{code:"no-poly-quasi",label:"No Poly, Quasi Exists",description:"No polynomial compilation; quasi-polynomial exists",opDescription:"No polynomial transformation; quasi-polynomial exists",notation:"$\\not\\leq_p$ Â· $\\leq_q$",emoji:"âš¡",color:"#f97316",pastel:"#ffedd5",cssClass:"complexity-no-poly-quasi",arrow:"tee",dashed:!1},"unknown-poly-quasi":{code:"unknown-poly-quasi",label:"Poly Unknown, Quasi Exists",description:"Polynomial unknown; quasi-polynomial exists",opDescription:"Polynomial unknown; quasi-polynomial exists",notation:"$\\leq_p^?$ Â· $\\leq_q$",emoji:"âš¡",color:"#eab308",pastel:"#fef9c3",cssClass:"complexity-unknown-poly-quasi",arrow:"triangle-cross",dashed:!0},"unknown-both":{code:"unknown-both",label:"Unknown",description:"Both polynomial and quasi-polynomial unknown",opDescription:"Both polynomial and quasi-polynomial unknown",notation:"$?$",emoji:"â”",color:"#6b7280",pastel:"#f3f4f6",cssClass:"complexity-unknown-both",arrow:"square",dashed:!0},unknown:{code:"unknown",internal:!0,label:"Unknown",description:"Unknown whether polynomial compilation exists",opDescription:"Unknown whether polynomial transformation exists",notation:"$?$",emoji:"â”",color:"#6b7280",pastel:"#f3f4f6",cssClass:"complexity-unknown",arrow:"square",dashed:!0},"no-quasi":{code:"no-quasi",label:"No Quasi",description:"No quasi-polynomial compilation (implies no polynomial)",opDescription:"No quasi-polynomial transformation (implies no polynomial)",notation:"$\\not\\leq_q$",emoji:"âŒ",color:"#dc2626",pastel:"#fecaca",cssClass:"complexity-no-quasi",arrow:"square",dashed:!1},"not-poly":{code:"not-poly",internal:!0,label:"Not Polynomial",description:"No polynomial compilation",opDescription:"No polynomial transformation",notation:"$\\not\\leq$",emoji:"âŒ",color:"#ef4444",pastel:"#fee2e2",cssClass:"complexity-not-poly",arrow:"square",dashed:!1},"unknown-to-us":{code:"unknown-to-us",label:"Unknown to Us",description:"Not yet researched or documented",opDescription:"Not yet researched or documented",notation:"?",emoji:"â“",color:"#9ca3af",pastel:"#ffffff",cssClass:"complexity-unknown-to-us",arrow:"circle",dashed:!0}};function ut(e,n){const t=e["unknown-both"]??Z["unknown-both"];return e[n]??t}function Ge(e){return e in Z}const Ke={arrow:"none",dashed:!1};function lt(){return Object.values(Z).filter(e=>!e.internal).map(e=>({id:e.code,name:e.label,label:e.notation,description:e.description,style:{lineStyle:"solid",width:2,targetStyle:{arrow:e.arrow,dashed:e.dashed},sourceStyle:{arrow:"none",dashed:!1}},defaultVisible:!0}))}const ft=lt();function ni(e){if(e===null)return Ke;const n=Z[e];return n?{arrow:n.arrow,dashed:n.dashed}:Ke}const dn=U.operations,B=dn.queries,J=dn.transformations;function ce(){return Object.keys(B)}function dt(){return Object.keys(J)}function ti(e){for(const[n,t]of Object.entries(J))if(t.code===e)return n;return e}function Xe(e,n){const t=[];for(const[o,i]of Object.entries(n)){const s=e?.[o]||e?.[i.code];s?t.push({code:i.code,label:i.label,complexity:s.complexity,caveat:s.caveat,refs:s.refs,description:s.description,derived:s.derived,dimmed:s.dimmed,explicit:s.explicit}):t.push({code:i.code,label:i.label,complexity:"unknown-to-us",refs:[]})}return t}function pt(e,n){return{queries:Xe(e,B),transformations:Xe(n,J)}}const mt=U.languages;function yt(e){const n=new Set;return e.definitionRefs&&e.definitionRefs.forEach(t=>n.add(t)),e.properties?.queries&&Object.values(e.properties.queries).forEach(t=>{t.refs&&t.refs.forEach(o=>n.add(o))}),e.properties?.transformations&&Object.values(e.properties.transformations).forEach(t=>{t.refs&&t.refs.forEach(o=>n.add(o))}),e.tags&&e.tags.forEach(t=>{t.refs&&t.refs.forEach(o=>n.add(o))}),{...e,references:ot(...Array.from(n))}}const gt=mt.map(yt),pn=U.adjacencyMatrix,mn=pn.languageIds,ht=pn.matrix,wt=Object.fromEntries(mn.map((e,n)=>[e,n])),vt={languageIds:mn,indexByLanguage:wt,matrix:ht},bt=U.separatingFunctions??[],$t="metadata"in U?U.metadata:void 0,xt={languages:gt,adjacencyMatrix:vt,relationTypes:ft,complexities:Z,references:it,separatingFunctions:bt,metadata:$t},qt=new Set(["poly","no-poly-unknown-quasi","no-poly-quasi","unknown-poly-quasi","unknown-both","no-quasi"]),St=new Set(Object.keys(Z)),It=new Set(ce()),kt=new Set(dt()),Et=new Set(Object.values(J).map(e=>e.code)),At=/\$/g;function De(e){return(e??"").replace(At,"").trim()}function ae(e,n,t,o){if(e!==void 0){if(!Array.isArray(e)){o.push(`${n}: references must be an array of IDs`);return}for(const i of e){if(typeof i!="string"||!i.trim()){o.push(`${n}: reference identifiers must be non-empty strings`);continue}t.has(i)||o.push(`${n}: unknown reference "${i}"`)}}}function Tt(e,n){const t=new Map;for(const o of e){if(!o.id||typeof o.id!="string"){n.push(`Encountered language without a valid id (name: ${o.name})`);continue}if(!o.name||typeof o.name!="string"){n.push("Encountered language without a valid name");continue}const i=De(o.id);if(!i){n.push(`Language "${o.name}" (id: "${o.id}") resolves to an empty identifier after normalization`);continue}if(t.has(i)){const s=t.get(i);n.push(`Language ID collision: "${o.id}" (${o.name}) conflicts with "${s}" after normalization`)}else t.set(i,o.name)}return t}function Ct(e){const n=new Set;if(!e)return n;for(const t of e)t?.id&&n.add(t.id);return n}function Ot(e,n,t){const{languageIds:o,indexByLanguage:i,matrix:s}=e,a=new Map;o.forEach((r,u)=>{const l=De(r);if(!l){t.push(`Adjacency matrix entry at index ${u} has an empty identifier`);return}if(a.has(l)){const h=a.get(l);t.push(`Adjacency matrix contains duplicate identifier "${r}" (conflicts with index ${h})`)}else a.set(l,u);n.has(l)||t.push(`Adjacency matrix references unknown language "${r}"`)});for(const[r,u]of n.entries())a.has(r)||t.push(`Language "${u}" is missing from the adjacency matrix`);s.length!==o.length&&t.push("Adjacency matrix must be square (rows must match number of languages)"),o.forEach((r,u)=>{const l=s[u];if(!Array.isArray(l)){t.push(`Adjacency matrix row ${u} is not an array`);return}l.length!==o.length&&t.push(`Adjacency matrix row ${u} length (${l.length}) does not match language count (${o.length})`)});const c=Object.entries(i);c.length!==o.length&&t.push("Adjacency matrix indexByLanguage must map every language exactly once");for(const[r,u]of c){if(typeof u!="number"||Number.isNaN(u)){t.push(`indexByLanguage entry for "${r}" is not a valid number`);continue}if(u<0||u>=o.length){t.push(`indexByLanguage entry for "${r}" is out of bounds (${u})`);continue}o[u]!==r&&t.push(`indexByLanguage mismatch: position ${u} stores "${o[u]}" instead of "${r}"`)}}function We(e,n,t,o,i){if(t)for(const[s,a]of Object.entries(t)){const c=n==="query"?It:kt,r=n==="query"?void 0:Et;!c.has(s)&&!r?.has(s)&&i.push(`Language "${e}" references unknown ${n} code "${s}"`),(!a||typeof a.complexity!="string"||!St.has(a.complexity))&&i.push(`Language "${e}" ${n} "${s}" must have a valid complexity code`),ae(a?.refs,`Language "${e}" ${n} "${s}" refs`,o,i)}}function Rt(e,n,t,o){if(Array.isArray(e.references))for(const i of e.references){if(!i?.id){o.push(`Language "${e.name}" contains a reference without an id`);continue}t.has(i.id)||o.push(`Language "${e.name}" references unknown id "${i.id}"`)}if(ae(e.definitionRefs,`Language "${e.name}" definitionRefs`,t,o),We(e.name,"query",e.properties?.queries,t,o),We(e.name,"transformation",e.properties?.transformations,t,o),Array.isArray(e.tags)){const i=new Set;for(const s of e.tags){if(!s?.label){o.push(`Language "${e.name}" has a tag without a label`);continue}i.has(s.label)?o.push(`Language "${e.name}" has duplicate tag label "${s.label}"`):i.add(s.label),ae(s.refs,`Language "${e.name}" tag "${s.label}" refs`,t,o)}}if(Array.isArray(e.subsets))for(const i of e.subsets){const s=De(i);(!s||!n.has(s))&&o.push(`Language "${e.name}" subset "${i}" does not reference a known language`)}}function Nt(e,n,t){const o=new Set;for(const i of e){if(!i.shortName){t.push("Separating function is missing a shortName");continue}o.has(i.shortName)?t.push(`Duplicate separating function shortName "${i.shortName}"`):o.add(i.shortName),ae(i.refs,`Separating function "${i.shortName}" refs`,n,t)}return o}function _t(e,n,t,o,i,s){if(qt.has(e.status)||s.push(`Edge ${n} -> ${t} has unknown status "${e.status}"`),ae(e.refs,`Edge ${n} -> ${t} refs`,o,s),e.separatingFunctionIds!==void 0)if(!Array.isArray(e.separatingFunctionIds))s.push(`Edge ${n} -> ${t}: separatingFunctionIds must be an array`);else for(const a of e.separatingFunctionIds){if(typeof a!="string"||!a.trim()){s.push(`Edge ${n} -> ${t}: separatingFunctionIds must contain string IDs`);continue}i.has(a)||s.push(`Edge ${n} -> ${t} references unknown separating function "${a}"`)}}function Lt(e,n,t,o){const{languageIds:i,matrix:s}=e;for(let a=0;a<i.length;a+=1)for(let c=0;c<i.length;c+=1){const r=s[a]?.[c];r&&_t(r,i[a],i[c],n,t,o)}}function yn(e){const n=[],t=Tt(e.languages,n);Ot(e.adjacencyMatrix,t,n);const o=Ct(e.references);for(const s of e.languages)Rt(s,t,o,n);const i=Nt(e.separatingFunctions??[],o,n);return Lt(e.adjacencyMatrix,o,i,n),n.length>0?{ok:!1,errors:n}:{ok:!0}}const gn=new Set(["poly"]),hn=new Set(["poly","unknown-poly-quasi","no-poly-quasi"]),jt=new Set(["no-poly-unknown-quasi","no-poly-quasi","no-quasi"]);function Pe(e,n,t){const o=e.matrix[n]?.[t];return o?o.status:null}function Dt(e){switch(e){case"poly":return"in polynomial time";case"unknown-poly-quasi":return"in at worst quasi-polynomial time";case"no-poly-quasi":return"in quasi-polynomial time";default:return"in unknown time"}}function Pt(e,n){return Array.from({length:e},()=>Array(e).fill(n))}function Ft(e){return Array.from({length:e},()=>Array(e).fill(-1))}function Ze(e,n){const t=e.languageIds.length,o=Pt(t,!1),i=Ft(t);for(let s=0;s<t;s+=1){const a=new Set,c=[s];for(;c.length>0;){const r=c.pop();if(a.has(r))continue;a.add(r);const u=e.matrix[r];if(u)for(let l=0;l<t;l+=1){if(l===s)continue;const h=u[l];h&&n.has(h.status)&&(o[s][l]||(o[s][l]=!0,i[s][l]=r),a.has(l)||c.push(l))}}}return{reach:o,parent:i}}function Je(e,n,t){const o=[];let i=n;for(;i!==-1&&i!==e;)o.push(i),i=t[i];return i===e?(o.push(e),o.reverse(),o):[]}function en(e,n){return e.map(t=>n[t])}function Mt(e,n){const{languageIds:t}=n,o=[];for(let i=0;i<e.length-1;i+=1){const s=e[i],a=e[i+1],c=Pe(n,s,a)??"unknown",r=Dt(c);o.push(`${t[s]} compiles to ${t[a]} ${r}.`)}return o.join(" ")}function Qt(e){return e??"missing"}function nn(e,n,t,o,i){const s=Mt(o,i),a=i.languageIds[e],c=i.languageIds[n],r=Qt(Pe(i,e,n));return`Contradiction: ${s} Therefore ${a}â†’${c} must have ${t==="poly"?"poly":"quasi"}, but ${a}â†’${c} is marked ${r}.`}function wn(e){const{adjacencyMatrix:n}=e,t=n.languageIds.length,o=Ze(n,gn),i=Ze(n,hn);for(let s=0;s<t;s+=1)for(let a=0;a<t;a+=1){if(s===a)continue;const c=Pe(n,s,a);if(o.reach[s][a]&&c&&jt.has(c)){const r=Je(s,a,o.parent[s]);return{ok:!1,error:nn(s,a,"poly",r,n),witnessPath:en(r,n.languageIds)}}if(i.reach[s][a]&&c==="no-quasi"){const r=Je(s,a,i.parent[s]);return{ok:!1,error:nn(s,a,"quasi",r,n),witnessPath:en(r,n.languageIds)}}}return{ok:!0}}function Ut(e){return e!=null&&gn.has(e)}function Bt(e){return e!=null&&hn.has(e)}function me(e,n){const t=new Set;for(let o=0;o<e.length-1;o+=1){const i=e[o],s=e[o+1],a=n.matrix[i]?.[s];if(a?.refs)for(const c of a.refs)t.add(c)}return Array.from(t)}function vn(e){let n=2166136261;for(let o=0;o<e.length;o++)n^=e.charCodeAt(o),n=Math.imul(n,16777619);return`lang_${(n>>>0).toString(16).padStart(8,"0")}`}let Le=new Map;function Vt(e){Le=new Map;for(const n of e)n.id&&Le.set(n.id,n.name)}function I(e){return Le.get(e)??e}const Oe=U.operationLemmas,K=new Set(["poly"]),Q=new Set(["poly","unknown-poly-quasi","no-poly-quasi"]);function zt(e){const n={};return e.forEach((t,o)=>{n[t]=o}),n}function Ht(e,n){return Array.from({length:e},()=>Array(e).fill(n))}function Yt(e){return Array.from({length:e},()=>Array(e).fill(-1))}function N(e,n){const t=e.languageIds.length,o=Ht(t,!1),i=Yt(t);for(let s=0;s<t;s+=1){const a=new Set,c=[s];for(;c.length>0;){const r=c.pop();if(a.has(r))continue;a.add(r);const u=e.matrix[r];if(u)for(let l=0;l<t;l+=1){if(l===s)continue;const h=u[l];h&&n.has(h.status)&&(o[s][l]||(o[s][l]=!0,i[s][l]=r),a.has(l)||c.push(l))}}}return{reach:o,parent:i}}function ie(e,n,t){const o=[];let i=n;for(;i!==-1&&i!==e;)o.push(i),i=t[i];return i===e?(o.push(e),o.reverse(),o):[]}function se(e,n,t){return e.length>=2?e:[n,t]}function de(e){switch(e){case"poly":return"in polynomial time";case"unknown-poly-quasi":return"in at worst quasi-polynomial time";case"no-poly-quasi":return"in quasi-polynomial time";default:return"in unknown time"}}function Gt(e,n,t){switch(t){case"no-poly-quasi":return`This contradicts the fact that ${e} cannot compile to ${n} in polynomial time`;case"no-poly-unknown-quasi":return`This contradicts the fact that ${e} cannot compile to ${n} in polynomial time`;case"no-quasi":return`This contradicts the fact that ${e} cannot compile to ${n} in quasi-polynomial time`;default:return`This contradicts the existing relationship from ${e} to ${n}`}}function C(e){return!e||e.length===0?"":` \\citet{${e.join(",")}}`}function je(e){return e?` unless ${e}`:""}function $e(e,n){const t=new Set;for(let o=0;o<e.length-1;o+=1){const i=e[o],s=e[o+1],a=n.matrix[i]?.[s];a?.caveat&&t.add(a.caveat)}if(t.size!==0)return Array.from(t).join(" OR ")}function ye(e,n){const{languageIds:t}=n,o=[];for(let i=0;i<e.length-1;i+=1){const s=e[i],a=e[i+1],c=t.indexOf(s),r=t.indexOf(a),u=n.matrix[c]?.[r],l=u?.status??"unknown",h=u?.refs??[],d=u?.caveat;o.push(`${I(s)} compiles to ${I(a)} ${de(l)}${je(d)}${C(h)}.`)}return o.join(" ")}function Fe(e,n){const t=[];return t.push("First, we show no polynomial compilation exists."),t.push(e.description),t.push(""),t.push("Now, we show a quasi-polynomial compilation exists."),t.push(n.description),t.join(`
`)}function ge(e){throw new Error(e)}function Kt(e){return e?e.noPolyDescription?e.noPolyDescription:e.status==="no-poly-unknown-quasi"||e.status==="no-poly-quasi"?{description:e.description??"",refs:e.refs??[],derived:e.derived??!1}:null:null}function Xt(e){return e?e.quasiDescription?e.quasiDescription:e.status==="unknown-poly-quasi"||e.status==="no-poly-quasi"?{description:e.description??"",refs:e.refs??[],derived:e.derived??!1}:null:null}function tn(e,n,t,o){if(n.length===0)return;const{languageIds:i}=e,s=n[0],a=n[n.length-1],c=me(n,e),r=$e(n,e),u=n.map(d=>i[d]),h=`${ye(u,e)} ${o}`.trim();e.matrix[s][a]={status:t,refs:c,caveat:r,separatingFunctionIds:void 0,hidden:!1,derived:!0,description:h}}function Wt(e,n,t,o,i){const{languageIds:s}=e,a=I(s[n]),c=I(s[t]),r=Kt(i)??{description:i.description??"",refs:i.refs??[],derived:i.derived??!1},u=o.map(v=>s[v]),h=`${ye(u,e)} Therefore a quasi-polynomial compilation exists from ${a} to ${c}.`,d=me(o,e),g={description:h,refs:d,derived:!0},p=[...new Set([...r.refs,...g.refs])],m=$e(o,e),f=i.caveat,y=new Set;if(f&&y.add(f),m)for(const v of m.split(" OR "))y.add(v.trim());const w=y.size>0?Array.from(y).join(" OR "):void 0,q=r.derived&&g.derived;e.matrix[n][t]={status:"no-poly-quasi",refs:p,caveat:w,separatingFunctionIds:i.separatingFunctionIds,hidden:!1,derived:q,noPolyDescription:r,quasiDescription:g,description:Fe(r,g)}}function Zt(e,n,t){const{languageIds:o}=e,i=o.length;let s=0;for(let a=0;a<i;a+=1)for(let c=0;c<i;c+=1){if(a===c)continue;const r=e.matrix[a][c],u=r?.status??null,l=I(o[a]),h=I(o[c]);if(t.reach[a][c]&&!Bt(u)){if(u==="no-quasi"){const m=se(ie(a,c,t.parent[a]),a,c).map(y=>o[y]),f=ye(m,e);ge(`Contradiction: ${f} Therefore ${l} compiles to ${h} in quasi-polynomial time, but ${l} is marked as not compiling to ${h} in quasi-polynomial time.`)}const d=se(ie(a,c,t.parent[a]),a,c),g=u==="no-poly-unknown-quasi"?"no-poly-quasi":"unknown-poly-quasi";if(u==="no-poly-unknown-quasi"&&r)Wt(e,a,c,d,r);else{const p=`Therefore a quasi-polynomial compilation exists from ${l} to ${h}.`;tn(e,d,g,p)}s+=1;continue}if(n.reach[a][c]&&!Ut(u)){if(u==="no-poly-quasi"||u==="no-poly-unknown-quasi"||u==="no-quasi"){const m=se(ie(a,c,n.parent[a]),a,c).map(y=>o[y]),f=ye(m,e);ge(`Contradiction: ${f} Therefore ${l} compiles to ${h} in polynomial time, but ${l} is marked as not compiling to ${h} in polynomial time.`)}const d=se(ie(a,c,n.parent[a]),a,c),g=`Therefore a polynomial compilation exists from ${l} to ${h}.`;tn(e,d,"poly",g),s+=1}}return s}function Jt(e,n,t,o,i){const{adjacencyMatrix:s}=e,a=s.matrix[n][t],c=a?.status??null,r=s.languageIds,u=I(r[n]),l=I(r[t]),h=f=>{const y=s.matrix[n][t];s.matrix[n][t]={status:f,refs:y?.refs??[],hidden:y?.hidden??!1,derived:!0,description:y?.description,separatingFunctionIds:void 0};const w=wn(e);return s.matrix[n][t]=y??null,w},d=(f,y,w)=>{if(y.length<2)return`If ${u} compiles to ${l} ${de(f)}, a contradiction arises.`;const q=y[0],v=y[y.length-1],b=I(q),$=I(v),x=r.indexOf(q),k=r.indexOf(v),E=s.matrix[x]?.[k],T=E?.status??"unknown",O=E?.refs??[],A=[];for(let G=0;G<y.length-1;G++){const te=y[G],Ie=y[G+1];if(te===r[n]&&Ie===r[t])continue;const On=r.indexOf(te),Rn=r.indexOf(Ie),ke=s.matrix[On]?.[Rn],Nn=ke?.status??"unknown",_n=ke?.refs??[],Ln=ke?.caveat;A.push(`${I(te)} compiles to ${I(Ie)} ${de(Nn)}${je(Ln)}${C(_n)}`)}const Y=A.length>0?A.join(". ")+". ":"",ee=de(f),F=f==="poly"?"in polynomial time":"in at most quasi-polynomial time",ne=Gt(b,$,T);return`${Y}If ${u} compiles to ${l} ${ee}, then ${b} compiles to ${$} ${F}. ${ne}${je(w)}${C(O)}.`},g=f=>{const y=f.map(T=>r.indexOf(T)).filter(T=>T>=0),w=$e(y,s),q=f[0],v=f[f.length-1],b=r.indexOf(q),$=r.indexOf(v),k=s.matrix[b]?.[$]?.caveat,E=new Set;if(w)for(const T of w.split(" OR "))E.add(T.trim());return k&&E.add(k),E.size>0?Array.from(E).join(" OR "):void 0},p=(f,y,w)=>{const q=w.map(x=>r.indexOf(x)).filter(x=>x>=0),v=me(q,s),b=g(w),$=d(y,w,b);s.matrix[n][t]={status:f,refs:v,caveat:b,hidden:!1,derived:!0,separatingFunctionIds:void 0,description:$.trim()}},m=f=>{const y=Xt(a)??{description:a?.description??"",refs:a?.refs??[],derived:a?.derived??!1},w=f.map(A=>r.indexOf(A)).filter(A=>A>=0),q=g(f),v=a?.caveat,b=new Set;if(v&&b.add(v),q)for(const A of q.split(" OR "))b.add(A.trim());const $=b.size>0?Array.from(b).join(" OR "):void 0,x=d("poly",f,$),k=me(w,s),E={description:x,refs:k,derived:!0},T=[...new Set([...E.refs,...y.refs])],O=E.derived&&y.derived;s.matrix[n][t]={status:"no-poly-quasi",refs:T,caveat:$,hidden:!1,derived:O,separatingFunctionIds:a?.separatingFunctionIds,noPolyDescription:E,quasiDescription:y,description:Fe(E,y)}};if(c===null||c==="unknown-both"){const f=h("poly");if(!f.ok){const w=f.witnessPath??[r[n],r[t]];return p("no-poly-unknown-quasi","poly",w),!0}const y=h("unknown-poly-quasi");if(!y.ok){const w=y.witnessPath??[r[n],r[t]];return p("no-quasi","unknown-poly-quasi",w),!0}return s.matrix[n][t]=a??null,!1}if(c==="unknown-poly-quasi"){const f=h("poly");if(!f.ok){const y=f.witnessPath??[r[n],r[t]];return m(y),!0}return s.matrix[n][t]=a,!1}if(c==="no-poly-unknown-quasi"){const f=h("no-poly-quasi");if(!f.ok){const y=f.witnessPath??[r[n],r[t]];return p("no-quasi","no-poly-quasi",y),!0}return s.matrix[n][t]=a,!1}return!1}function j(...e){const n=new Set;for(const t of e)t&&n.add(t);if(n.size!==0)return Array.from(n).join(" OR ")}function he(e,n,t,o){const i=ie(e,n,t[e]),s=se(i,e,n);return $e(s,o)}function S(e){const n=B[e];if(n)return n.label;const t=J[e];return t?t.label:e}const eo=new Set(["no-poly-unknown-quasi","no-poly-quasi","no-quasi"]),no=new Set(["no-quasi"]);function R(e,n){return e.properties?.queries?.[n]??e.properties?.transformations?.[n]}function V(e,n,t){e.properties||(e.properties={}),e.properties.queries||(e.properties.queries={}),e.properties.queries[n]=t}function L(e,n){return e.properties?.queries?.[n]?.complexity??"unknown-to-us"}function z(e){return e==="poly"}function H(e){return Q.has(e)}function X(e){return eo.has(e)}function W(e){return no.has(e)}function on(e,n,t,o){let i=!1;const{adjacencyMatrix:s,languages:a}=e,c=ce();for(const r of c)for(let u=0;u<a.length;u++){const l=a[u],h=l.id,d=s.indexByLanguage[h];if(d===void 0)continue;const g=L(l,r);if(o&&z(g)){const p=R(l,r);for(let m=0;m<a.length;m++){const f=a[m],y=f.id,w=s.indexByLanguage[y];if(w!==void 0&&w!==d&&n.reach[w][d]){const q=L(f,r);if(!z(q)){const v=I(y),b=I(h),$=l.properties?.queries?.[r]?.refs??[],x=`${v} compiles to ${b} in polynomial time, and ${b} supports ${S(r)} in polynomial time${C($)}. Therefore ${v} supports ${S(r)} in polynomial time.`,k=he(w,d,n.parent,s),E=p?.caveat,T=j(k,E);V(f,r,{complexity:"poly",refs:l.properties?.queries?.[r]?.refs??[],derived:!0,description:x,...T&&{caveat:T}}),i=!0}}}}if(!o&&H(g)){const p=R(l,r);for(let m=0;m<a.length;m++){const f=a[m],y=f.id,w=s.indexByLanguage[y];if(w!==void 0&&w!==d&&t.reach[w][d]){const q=L(f,r);if(H(q)||W(q))continue;const v=I(y),b=I(h),$=q==="no-poly-unknown-quasi"?"no-poly-quasi":"unknown-poly-quasi",x=l.properties?.queries?.[r]?.refs??[],k=`${v} compiles to ${b} in quasi-polynomial time, and ${b} supports ${S(r)} in quasi-polynomial time${C(x)}. Therefore ${v} supports ${S(r)} in at most quasi-polynomial time.`,E=he(w,d,t.parent,s),T=p?.caveat,O=j(E,T);V(f,r,{complexity:$,refs:l.properties?.queries?.[r]?.refs??[],derived:!0,description:k,...O&&{caveat:O}}),i=!0}}}}return i}function sn(e,n,t){let o=!1;for(const i of e.languages)for(const s of n){let a=!0,c="poly";const r=[];for(const g of s.antecedent){const p=R(i,g);if(!p){a=!1;break}r.push(p.caveat);const m=p.complexity;if(t){if(!z(m)){a=!1;break}}else{if(!H(m)){a=!1;break}(m==="unknown-poly-quasi"||m==="no-poly-quasi")&&(c=m)}}if(!a)continue;const l=R(i,s.consequent)?.complexity??"unknown-to-us",h=t?"poly":c;if(t?!z(l):!H(l)){const g=I(i.id),p=s.antecedent.map(S).join(", "),m=`Since ${g} supports ${p}, it also supports ${S(s.consequent)}${C(s.refs)}.`,f=j(...r);s.consequent in(B??{})?V(i,s.consequent,{complexity:h,refs:s.refs,derived:!0,description:m,...f&&{caveat:f}}):(i.properties||(i.properties={}),i.properties.transformations||(i.properties.transformations={}),i.properties.transformations[s.consequent]={complexity:h,refs:s.refs,derived:!0,description:m,...f&&{caveat:f}}),o=!0}}return o}function to(e,n,t){let o=!1;const{adjacencyMatrix:i,languages:s}=e,a=ce();for(const c of a)for(const r of s){const u=i.indexByLanguage[r.id];if(u===void 0)continue;const l=L(r,c),h=I(r.id);if(X(l)){const d=R(r,c);for(const g of s){if(g.id===r.id)continue;const p=i.indexByLanguage[g.id];if(p===void 0||!n.reach[u][p])continue;const m=L(g,c);if(X(m))continue;const f=I(g.id),y=r.properties?.queries?.[c]?.refs??[],w=`${S(c)} is unsupported by ${h}${C(y)}, and ${h} compiles to ${f} in polynomial time. If ${f} supported ${S(c)} in polynomial time, then ${h} could too by compiling first. Therefore ${S(c)} is unsupported by ${f}.`,q=he(u,p,n.parent,i),v=d?.caveat,b=j(q,v);V(g,c,{complexity:"no-poly-unknown-quasi",refs:r.properties?.queries?.[c]?.refs??[],derived:!0,description:w,...b&&{caveat:b}}),o=!0}}if(W(l)){const d=R(r,c);for(const g of s){if(g.id===r.id)continue;const p=i.indexByLanguage[g.id];if(p===void 0||!t.reach[u][p])continue;const m=L(g,c);if(W(m))continue;const f=I(g.id),y=r.properties?.queries?.[c]?.refs??[],w=`${S(c)} is unsupported by ${h} in quasi-polynomial time${C(y)}, and ${h} compiles to ${f} in quasi-polynomial time. If ${f} supported ${S(c)} in quasi-polynomial time, then ${h} could too by compiling first. Therefore ${S(c)} is unsupported by ${f} in quasi-polynomial time.`,q=he(u,p,t.parent,i),v=d?.caveat,b=j(q,v);V(g,c,{complexity:"no-quasi",refs:r.properties?.queries?.[c]?.refs??[],derived:!0,description:w,...b&&{caveat:b}}),o=!0}}}return o}function oo(e,n){let t=!1;for(const o of e.languages){const i=I(o.id);for(const s of n){const a=R(o,s.consequent),c=a?.complexity??"unknown-to-us";if(X(c))for(let r=0;r<s.antecedent.length;r++){const u=s.antecedent[r],h=R(o,u)?.complexity??"unknown-to-us";if(X(h))continue;let d=!0;const g=[],p=[];for(let v=0;v<s.antecedent.length;v++){if(v===r)continue;const b=s.antecedent[v];g.push(b);const $=R(o,b),x=$?.complexity??"unknown-to-us";if(!z(x)){d=!1;break}p.push($?.caveat)}if(!d)continue;const m=a?.refs??[],f=g.length>0?` and since ${g.map(S).join(" and ")} ${g.length===1?"is":"are"} supported in polynomial time,`:"",y=`Since ${s.antecedent.map(S).join(" âˆ§ ")} implies ${S(s.consequent)}${C(s.refs)}, and since ${S(s.consequent)} is unsupported by ${i}${C(m)},${f} then ${S(u)} is unsupported by ${i} as well.`,w=j(a?.caveat,...p);u in(B??{})?V(o,u,{complexity:"no-poly-unknown-quasi",refs:a?.refs??s.refs,derived:!0,description:y,...w&&{caveat:w}}):(o.properties||(o.properties={}),o.properties.transformations||(o.properties.transformations={}),o.properties.transformations[u]={complexity:"no-poly-unknown-quasi",refs:a?.refs??s.refs,derived:!0,description:y,...w&&{caveat:w}}),t=!0}if(W(c))for(let r=0;r<s.antecedent.length;r++){const u=s.antecedent[r],h=R(o,u)?.complexity??"unknown-to-us";if(W(h))continue;let d=!0;const g=[],p=[];for(let v=0;v<s.antecedent.length;v++){if(v===r)continue;const b=s.antecedent[v];g.push(b);const $=R(o,b),x=$?.complexity??"unknown-to-us";if(!H(x)){d=!1;break}p.push($?.caveat)}if(!d)continue;const m=a?.refs??[],f=g.length>0?` and since ${g.map(S).join(" and ")} ${g.length===1?"is":"are"} supported in quasi-polynomial time,`:"",y=`Since ${s.antecedent.map(S).join(" âˆ§ ")} implies ${S(s.consequent)}${C(s.refs)}, and since ${S(s.consequent)} is unsupported by ${i} in quasi-polynomial time${C(m)},${f} then ${S(u)} is unsupported by ${i} in quasi-polynomial time as well.`,w=j(a?.caveat,...p);u in(B??{})?V(o,u,{complexity:"no-quasi",refs:a?.refs??s.refs,derived:!0,description:y,...w&&{caveat:w}}):(o.properties||(o.properties={}),o.properties.transformations||(o.properties.transformations={}),o.properties.transformations[u]={complexity:"no-quasi",refs:a?.refs??s.refs,derived:!0,description:y,...w&&{caveat:w}}),t=!0}}}return t}const io=new Set(["no-poly-unknown-quasi","no-poly-quasi","no-quasi"]);function so(e){let n=!1;const{adjacencyMatrix:t,languages:o}=e,i=ce();for(const s of i)for(const a of o){const c=t.indexByLanguage[a.id];if(c===void 0)continue;const r=L(a,s),u=R(a,s);for(const l of o){if(l.id===a.id)continue;const h=t.indexByLanguage[l.id];if(h===void 0)continue;const d=L(l,s),g=R(l,s);z(r)&&X(d)&&ao(t,h,c,l,a,s,u,g)&&(n=!0),H(r)&&d==="no-quasi"&&ro(t,h,c,l,a,s,u,g)&&(n=!0)}}return n}function ao(e,n,t,o,i,s,a,c){const r=e.matrix[n][t],u=r?.status??null;if(u!==null&&io.has(u))return!1;const l=I(i.id),h=I(o.id);u==="poly"&&ge(`Contradiction (succinctness by query): ${h} â†’ ${l} is marked as poly, but ${l} supports ${S(s)} in polynomial time while ${S(s)} is unsupported by ${h}. If the polynomial compilation existed, ${h} could support ${S(s)} by compiling to ${l}.`);const d=a?.refs??[],g=c?.refs??[],p=`${l} supports ${S(s)} in polynomial time${C(d)}, but ${S(s)} is unsupported by ${h}${C(g)}. If ${h} could compile to ${l} in polynomial time, ${h} could support ${S(s)} by first compiling to ${l}. Therefore ${h} cannot compile to ${l} in polynomial time.`,m=j(a?.caveat,c?.caveat),f=[...new Set([...a?.refs??[],...c?.refs??[]])];if(u==="unknown-poly-quasi"&&r){const y=r.quasiDescription??{description:r.description??"",refs:r.refs??[],derived:r.derived??!1},w={description:p,refs:f,derived:!0},q=[...new Set([...w.refs,...y.refs])],v=new Set;if(m)for(const x of m.split(" OR "))v.add(x.trim());if(r.caveat)for(const x of r.caveat.split(" OR "))v.add(x.trim());const b=v.size>0?Array.from(v).join(" OR "):void 0,$=w.derived&&y.derived;e.matrix[n][t]={status:"no-poly-quasi",refs:q,caveat:b,separatingFunctionIds:r.separatingFunctionIds,hidden:!1,derived:$,noPolyDescription:w,quasiDescription:y,description:Fe(w,y)}}else e.matrix[n][t]={status:"no-poly-unknown-quasi",refs:f,caveat:m,separatingFunctionIds:void 0,hidden:!1,derived:!0,description:p};return!0}function ro(e,n,t,o,i,s,a,c){const r=e.matrix[n][t],u=r?.status??null;if(u==="no-quasi")return!1;const l=I(i.id),h=I(o.id);(u==="poly"||u==="unknown-poly-quasi"||u==="no-poly-quasi")&&ge(`Contradiction (succinctness by query): ${h} â†’ ${l} is marked as ${u} (guaranteeing quasi-poly), but ${l} supports ${S(s)} in quasi-polynomial time while ${S(s)} is unsupported by ${h} in quasi-polynomial time. If the quasi-polynomial compilation existed, ${h} could support ${S(s)} by compiling to ${l}.`);const d=a?.refs??[],g=c?.refs??[],p=`${l} supports ${S(s)} in quasi-polynomial time${C(d)}, but ${S(s)} is unsupported by ${h} in quasi-polynomial time${C(g)}. If ${h} could compile to ${l} in quasi-polynomial time, ${h} could support ${S(s)} by first compiling to ${l}. Therefore ${h} cannot compile to ${l} in quasi-polynomial time.`,m=j(a?.caveat,c?.caveat),f=j(m,r?.caveat),y=[...new Set([...a?.refs??[],...c?.refs??[],...r?.refs??[]])];return e.matrix[n][t]={status:"no-quasi",refs:y,caveat:f,separatingFunctionIds:r?.separatingFunctionIds,hidden:!1,derived:!0,description:p},!0}function co(e){const{adjacencyMatrix:n,languages:t}=e,o=N(n,K),i=N(n,Q),s=ce();for(const a of s)for(let c=0;c<t.length;c++){const r=t[c],u=r.id,l=n.indexByLanguage[u];if(l===void 0)continue;const h=L(r,a);for(let d=0;d<t.length;d++){const g=t[d],p=g.id,m=n.indexByLanguage[p];if(m===void 0||l===m)continue;const f=L(g,a),y=I(u),w=I(p);if(o.reach[l][m]&&z(f)&&X(h))return{ok:!1,error:`Contradiction: ${y} compiles to ${w} in polynomial time, and ${w} supports ${S(a)} in polynomial time, but ${S(a)} is marked as unsupported by ${y}.`};if(i.reach[l][m]&&H(f)&&W(h))return{ok:!1,error:`Contradiction: ${y} compiles to ${w} in quasi-polynomial time, and ${w} supports ${S(a)} in quasi-polynomial time, but ${S(a)} is marked as unsupported by ${y} in quasi-polynomial time.`}}}return{ok:!0}}function bn(e){const{adjacencyMatrix:n}=e;n.indexByLanguage=zt(n.languageIds),Vt(e.languages);const t=wn(e);if(!t.ok)throw new Error(t.error??"Adjacency consistency validation failed");let o=!0;for(;o;){o=!1;let i=!0;for(;i;){const a=N(n,Q),c=N(n,K);i=Zt(n,c,a)>0}let s=!0;for(;s;){s=!1,N(n,Q),N(n,K);for(let a=0;a<n.languageIds.length;a+=1)for(let c=0;c<n.languageIds.length;c+=1)a!==c&&Jt(e,a,c)&&(s=!0)}uo(e),so(e)&&(o=!0)}return e}function uo(e){const{adjacencyMatrix:n}=e;let t=!0;for(;t;){const a=N(n,K),c=N(n,Q);t=!1,on(e,a,c,!0)&&(t=!0),sn(e,Oe,!0)&&(t=!0)}let o=!0;for(;o;){const a=N(n,K),c=N(n,Q);o=!1,on(e,a,c,!1)&&(o=!0),sn(e,Oe,!1)&&(o=!0)}let i=!0;for(;i;){const a=N(n,K),c=N(n,Q);i=!1,to(e,a,c)&&(i=!0),oo(e,Oe)&&(i=!0)}const s=co(e);if(!s.ok)throw new Error(s.error??"Query consistency validation failed after propagation")}const lo=yn,fo=bn;function po(e){e.errors?.length&&console.warn("transformData validity check failed:",e.errors)}function ue(e){return JSON.parse(JSON.stringify(e))}function mo(e,n){const t={},o=n.map((i,s)=>{t[i]=s;const a=e.indexByLanguage[i],c=a!==void 0?e.matrix[a]:void 0;return n.map(r=>{if(!c)return null;const u=e.indexByLanguage[r];return u===void 0?null:c[u]??null})});return{languageIds:n,indexByLanguage:t,matrix:o}}function le(e,n){const t=ue(e),o=[];let i=!1;for(const s of t.languages){const a=n(s);a?o.push(a):i=!0}if(t.languages=o,i){const s=new Set(o.map(c=>c.id)),a=t.adjacencyMatrix.languageIds.filter(c=>s.has(c));t.adjacencyMatrix=mo(t.adjacencyMatrix,a)}return t}function P(e,n){const t=ue(e),{languageIds:o,matrix:i}=t.adjacencyMatrix;for(let s=0;s<o.length;s+=1){const a=o[s];for(let c=0;c<o.length;c+=1){const r=o[c];i[s][c]=n(i[s][c],a,r)}}return t}function oi(e,n,t={},o={}){const i=ue(e),s=n(i);if(t.checkValidity){const c=(o.validate??lo)(s);if(!c.ok)return(o.onInvalid??po)(c),null}return t.propagateImplicit?(o.propagate??fo)(s):s}function yo(e,n){return(t,o)=>o?le(t,i=>{const s=pt(i.properties.queries,i.properties.transformations),c=(n==="query"?s.queries:s.transformations)?.find(l=>l.code===e);if(!c)return i;const u=`
${ut(t.complexities,c.complexity).emoji} ${e}`;return{...i,visual:{...i.visual,labelSuffix:(i.visual?.labelSuffix||"")+u}}}):t}function go(e){return e.languages.map(n=>({id:`select-${n.name}`,name:n.name,description:`Show ${n.fullName}`,category:"Show Languages",defaultParam:!0,controlType:"checkbox",lambda:(t,o)=>o?t:le(t,i=>i.name===n.name?null:i)}))}function ho(){return{id:"fill-unknown-operations",name:"Fill Unknown Operations",description:"Normalizes operation keys without adding unknown entries",hidden:!0,defaultParam:!0,lambda:(e,n)=>n?le(e,t=>{const o=(i,s)=>{const a={};if(!i)return a;for(const[c,r]of Object.entries(s)){const u=i[c]||i[r.code];u&&(a[r.code]={complexity:u.complexity,...u.caveat&&{caveat:u.caveat},refs:u.refs??[],...u.description&&{description:u.description},...u.derived!=null&&{derived:u.derived},...u.dimmed!=null&&{dimmed:u.dimmed},...u.explicit!=null&&{explicit:u.explicit}})}return a};return{...t,properties:{queries:o(t.properties.queries,B),transformations:o(t.properties.transformations,J)}}}):e}}function ii(e){const n=e.filter(i=>i.category),t=new Map;return n.forEach(i=>{const s=i.category;t.has(s)||t.set(s,[]),t.get(s).push(i)}),Array.from(t.entries()).map(([i,s])=>({name:i,filters:s}))}function $n(e,n,t){const o=`visualize-${e.code.toLowerCase().replace(/[^a-z0-9]/g,"-")}`,i=e.description||`Display ${e.name} (${e.code}) status on nodes`;return{id:o,name:`${e.name} (${e.code})`,description:i,category:t,defaultParam:!1,controlType:"checkbox",lambda:yo(e.code,n)}}function wo(e){return e.map(n=>$n(n,"query","Visualize Queries"))}function vo(e){return e.map(n=>$n(n,"transformation","Visualize Transformations"))}const bo=wo([{code:"CO",name:"Consistency"},{code:"VA",name:"Validity"},{code:"CE",name:"Clausal Entailment"},{code:"CT",name:"Model Counting"}]),$o=vo([{code:"CD",name:"Conditioning"},{code:"FO",name:"Forgetting"},{code:"âˆ§C",name:"Conjunction"},{code:"Â¬C",name:"Negation"}]);function xn(e,n){const{indexByLanguage:t,matrix:o}=n.adjacencyMatrix;return(i,s,a)=>{if(!i)return null;const c=e(i),r=t[s],u=t[a];if(r===void 0||u===void 0)return i;const l=o[u]?.[r]??null,h=e(l);return c&&h?null:i}}const xo={id:"poly-display",name:"Polynomial Display",description:"Control how polynomial and quasipolynomial complexity edges are shown",category:"Visibility",defaultParam:"polytime-vs-not",controlType:"dropdown",options:[{value:"include-quasipolynomial",label:"Also include quasipolynomial time",description:"Show all edge types as-is"},{value:"polytime-vs-not",label:"Polytime vs not polytime",description:"Collapse to polynomial, not polynomial, or unknown"}],lambda:(e,n)=>{if(n==="include-quasipolynomial")return e;const t=P(e,i=>{if(!i)return null;let s=i.status;switch(i.status){case"poly":break;case"no-poly-unknown-quasi":case"no-poly-quasi":case"no-quasi":s="not-poly";break;case"unknown-poly-quasi":case"unknown-both":s="unknown";break}return s===i.status?i:{...i,status:s}}),o=t.complexities.poly;return o&&(t.complexities={...t.complexities,poly:{...o,notation:"$\\leq$"}}),t}},qo={id:"manage-unknowns",name:"Manage Unknowns",description:"Control how edges with unknown status are treated",category:"Visibility",defaultParam:"omit-all",defaultParamMatrix:"expressively",controlType:"dropdown",options:[{value:"omit-all",label:"Omit all",description:"Hide edges with unknown or partially unknown status"},{value:"expressively",label:"Expressively",description:"Show unknown edges without modification"},{value:"optimistically",label:"Optimistically",description:"Assume unknown edges behave as positively as possible"},{value:"pessimistically",label:"Pessimistically",description:"Assume unknown edges behave as restrictively as possible"}],lambda:(e,n)=>n==="expressively"?e:P(e,t=>{if(!t)return null;switch(n){case"omit-all":return t.status!=="unknown-poly-quasi"&&t.status!=="unknown-both"&&t.status!=="no-poly-unknown-quasi"?t:null;case"optimistically":{let o=t.status;return t.status==="no-poly-unknown-quasi"?o="no-poly-quasi":(t.status==="unknown-poly-quasi"||t.status==="unknown-both")&&(o="poly"),o===t.status?t:{...t,status:o}}case"pessimistically":{let o=t.status;return t.status==="unknown-both"||t.status==="no-poly-unknown-quasi"?o="no-quasi":t.status==="unknown-poly-quasi"&&(o="no-poly-quasi"),o===t.status?t:{...t,status:o}}default:return t}})},So={id:"positive-results-only",name:"Positive Results Only",description:"Hide negative/unknown results (keep only edges that assert existence of a compilation)",category:"Visibility",defaultParam:!1,controlType:"checkbox",lambda:(e,n)=>n?P(e,t=>{if(!t)return null;switch(t.status){case"no-poly-unknown-quasi":case"no-quasi":case"not-poly":case"unknown-both":return null;default:return t}}):e},Io={id:"omit-incomparable",name:"Omit Incomparable",description:"Omit edges where both directions are no-quasi",category:"Edge Visibility",defaultParam:!0,defaultParamMatrix:!1,controlType:"checkbox",lambda:(e,n)=>n?P(e,xn(o=>!o||o.status==="no-quasi",e)):e},ko={id:"omit-separator-functions",name:"Omit Separator Functions",description:"Hide all separator functions from edges",category:"Visibility",defaultParam:!0,controlType:"checkbox",lambda:(e,n)=>n?P(e,t=>t?t.separatingFunctionIds&&t.separatingFunctionIds.length>0?{...t,separatingFunctionIds:[]}:t:null):e},Eo={id:"omit-marked-edges",name:"Omit Marked Edges",description:"Omit edges that have been marked as hidden",category:"Edge Visibility",defaultParam:!0,controlType:"checkbox",hidden:!0,lambda:(e,n)=>n?P(e,t=>!t||t.hidden?null:t):e},Ao={id:"omit-implicit-edges",name:"Omit Implicit Edges",description:"Omit edges where both directions were inferred by propagation",category:"Edge Visibility",defaultParam:!0,defaultParamMatrix:!1,controlType:"checkbox",lambda:(e,n)=>n?P(e,xn(o=>!o||o.derived===!0,e)):e},To={id:"implicit-edge-treatment",name:"Implicit Edge Treatment",description:"Control how implicit (derived) vs explicit edges are visually distinguished",category:"Visibility",defaultParam:"none",defaultParamMatrix:"gray",controlType:"dropdown",options:[{value:"none",label:"None",description:"No visual distinction between implicit and explicit edges"},{value:"gray",label:"Gray implicit",description:"Show implicit edges with gray stripes"},{value:"highlight-explicit",label:"Highlight explicit",description:"Add golden border to explicit (non-derived) edges"}],lambda:(e,n)=>{if(n==="none")return e;let t=P(e,o=>{if(!o)return null;if(n==="gray"){if(o.derived)return{...o,dimmed:!0}}else if(n==="highlight-explicit"&&!o.derived)return{...o,explicit:!0};return o});return t=le(t,o=>{const i=s=>{const a={};for(const[c,r]of Object.entries(s))n==="gray"&&r.derived?a[c]={...r,dimmed:!0}:n==="highlight-explicit"&&!r.derived?a[c]={...r,explicit:!0}:a[c]=r;return a};return{...o,properties:{...o.properties,queries:i(o.properties.queries??{}),transformations:i(o.properties.transformations??{})}}}),t}};function Co(e,n){const{adjacencyMatrix:t}=e,o=t.indexByLanguage[n];if(o===void 0)return!1;const i=t.matrix[o];if(i){for(let s=0;s<t.languageIds.length;s++)if(i[s])return!0}for(let s=0;s<t.languageIds.length;s++)if(t.matrix[s]?.[o])return!0;return!1}const Oo={id:"hide-in-progress",name:"Hide In Progress Languages",description:"Hide languages that have no edges (not yet connected to the graph)",category:"Visibility",defaultParam:!0,controlType:"checkbox",lambda:(e,n)=>n?le(e,t=>Co(e,t.id)?t:null):e},Ro=[Oo,qo,Io,Ao,To,So,xo,ko,Eo];function Me(e){return e==="poly"?"poly":e==="no-poly-quasi"||e==="unknown-poly-quasi"?"quasi":null}function qn(e){return e==="no-quasi"}function Sn(e,n,t){const o=e.matrix[n]?.[t],i=e.matrix[t]?.[n];if(!o||!i||o.hidden||i.hidden)return null;const s=Me(o.status);return!s||!qn(i.status)?null:s}const No={id:"omit-transitive-edges",name:"Omit Transitive Edges",description:"Hide edges that are redundant due to transitivity",category:"Edge Visibility",defaultParam:!0,defaultParamMatrix:!1,controlType:"checkbox",lambda:(e,n)=>{const t=ue(e),{adjacencyMatrix:o}=t;if(!n){for(let i=0;i<o.languageIds.length;i+=1){const s=o.matrix[i];s&&s.forEach(a=>{a&&(a.hidden=!1)})}return t}_o(o);for(let i=0;i<o.languageIds.length;i+=1){const s=o.matrix[i];if(!s)continue;const a=[];s.forEach((c,r)=>{if(!c||r===i||c.hidden)return;const u=Me(c.status);u&&a.push({targetIndex:r,edgeType:u})});for(const{targetIndex:c,edgeType:r}of a){const u=o.matrix[i][c];if(!u||u.hidden)continue;const l=u.hidden??!1;u.hidden=!0,Lo(o,i,c,r)||(u.hidden=l)}}return t}};function _o(e){for(let n=0;n<e.languageIds.length;n+=1){const t=e.matrix[n];if(!t)continue;const o=[];for(let i=0;i<t.length;i+=1){if(i===n)continue;const s=Sn(e,n,i);s&&o.push({targetIndex:i,edgeType:s})}for(const{targetIndex:i,edgeType:s}of o){const a=e.matrix[n][i];if(!a||a.hidden)continue;const c=a.hidden??!1;if(a.hidden=!0,!jo(e,n,i,s)){a.hidden=c;continue}const u=e.matrix[i]?.[n];u&&qn(u.status)&&(u.hidden=!0)}}}function Lo(e,n,t,o){const i=new Set,s=[n];for(i.add(n);s.length>0;){const a=s.shift(),c=e.matrix[a];if(c)for(let r=0;r<c.length;r++){const u=c[r];if(!u||r===n||i.has(r)||u.hidden)continue;const l=Me(u.status);if(!l)continue;if(o==="poly"?l==="poly":l==="poly"||l==="quasi"){if(r===t)return!0;i.add(r),s.push(r)}}}return!1}function jo(e,n,t,o){const i=new Set,s=[n];for(i.add(n);s.length>0;){const a=s.shift(),c=e.matrix[a];if(c)for(let r=0;r<c.length;r+=1){if(r===n||i.has(r))continue;const u=Sn(e,a,r);if(!(!u||!(o==="poly"?u==="poly":u==="poly"||u==="quasi"))){if(r===t)return!0;i.add(r),s.push(r)}}}return!1}const Do=[No],Po=[ho(),...bo,...$o,...Do],Fo=xt;function si(){const e=go(Fo);return[...Po,...e]}function ai(){return Ro}const Qe="kcm_contribute_queue_v1",In="kcm_contributor_info_v1",we="kcm_contribute_preview_dataset_v1";function xe(e){return typeof localStorage>"u"?null:localStorage.getItem(e)}function Mo(e,n){typeof localStorage>"u"||localStorage.setItem(e,n)}function pe(e){typeof localStorage>"u"||localStorage.removeItem(e)}function ri(){return xe(Qe)!==null}function Qo(e){if(!Array.isArray(e?.entries)||e.entries.length===0)throw new Error("Stored queue is missing ordered entries.");return e.entries}function ci(){const e=xe(Qe);if(!e)return null;try{const n=JSON.parse(e);return{entries:Qo(n),customTags:n.customTags||[],modifiedRelations:n.modifiedRelations||[],submissionId:typeof n.submissionId=="string"?n.submissionId:void 0,supersedesSubmissionId:typeof n.supersedesSubmissionId=="string"?n.supersedesSubmissionId:null}}catch(n){return console.error("Failed to load queued changes:",n),null}}function ui(){pe(Qe),pe(we),pe(In)}function li(){const e=xe(In);if(!e)return null;try{return JSON.parse(e)}catch(n){return console.error("Failed to load contributor info:",n),null}}function fi(e){if(e===null){pe(we);return}try{Mo(we,JSON.stringify(e))}catch(n){console.error("Failed to persist preview dataset:",n)}}function di(){const e=xe(we);if(!e)return null;try{return JSON.parse(e)}catch(n){return console.error("Failed to load preview dataset:",n),null}}const kn="kcm_submission_history_v1",Ue=10,D=Array.isArray,fe=e=>!!e&&typeof e=="object";function Uo(e){return fe(e)&&typeof e.name=="string"}function Bo(e){return fe(e)&&typeof e.sourceId=="string"&&typeof e.targetId=="string"&&typeof e.status=="string"&&Array.isArray(e.refs)}function En(e){return fe(e)&&typeof e.shortName=="string"&&typeof e.name=="string"&&typeof e.description=="string"&&Array.isArray(e.refs)}function An(e){return fe(e)&&typeof e.bibtex=="string"&&typeof e.title=="string"&&typeof e.href=="string"}function re(e){return e.map(n=>({...n,definitionRefs:[...n.definitionRefs],queries:Object.fromEntries(Object.entries(n.queries).map(([t,o])=>[t,{...o,refs:[...o.refs]}])),transformations:Object.fromEntries(Object.entries(n.transformations).map(([t,o])=>[t,{...o,refs:[...o.refs]}])),tags:n.tags.map(t=>({...t,refs:[...t.refs]})),existingReferences:[...n.existingReferences]}))}function qe(e){return e.map(n=>({...n,refs:[...n.refs],separatingFunctionIds:n.separatingFunctionIds?[...n.separatingFunctionIds]:void 0}))}function Tn(e){return e.map(n=>({...n,refs:[...n.refs]}))}function Se(e){return e.map(n=>({...n,refs:[...n.refs]}))}function Be(e){return e.map(n=>({...n}))}function Cn(e){return e.map(n=>{switch(n.kind){case"language:new":case"language:edit":return{...n,payload:re([n.payload])[0]};case"relationship":return{...n,payload:qe([n.payload])[0]};case"separator":return{...n,payload:Se([n.payload])[0]};case"reference":return{...n,payload:Be([n.payload])[0]}}})}function Vo(e){if(!D(e))return[];const n=[];let t=0;for(const o of e){if(!fe(o))continue;const i=o,s=typeof i.id=="string"?i.id:`history-entry-${t++}`,a=i.kind;switch(a){case"language:new":case"language:edit":Uo(i.payload)&&n.push({id:s,kind:a,payload:re([i.payload])[0]});break;case"relationship":Bo(i.payload)&&n.push({id:s,kind:a,payload:qe([i.payload])[0]});break;case"separator":En(i.payload)&&n.push({id:s,kind:a,payload:Se([i.payload])[0]});break;case"reference":An(i.payload)&&n.push({id:s,kind:a,payload:Be([i.payload])[0]});break}}return n}function zo(e){if(!e||typeof e!="object")return null;const n=e,t=typeof n.id=="string"?n.id:null,o=typeof n.createdAt=="string"?n.createdAt:null;if(!t||!o)return null;const i=n.payload;if(!i||typeof i!="object")return null;const s=typeof i.submissionId=="string"?i.submissionId:t,a=typeof i.supersedesSubmissionId=="string"?i.supersedesSubmissionId:null,c=i.contributor,r=c&&typeof c=="object"?{email:typeof c.email=="string"?c.email:"",github:typeof c.github=="string"?c.github:"",note:typeof c.note=="string"?c.note:""}:{email:"",github:"",note:""},u=v=>D(v)?re(v.filter(b=>!!b&&typeof b=="object")):[],l=v=>D(v)?qe(v.filter(b=>!!b&&typeof b=="object")):[],h=v=>D(v)?v.filter(b=>typeof b=="string"):[],d=v=>D(v)?Be(v.filter(b=>An(b))):[],g=v=>D(v)?Tn(v.filter(b=>!!b&&typeof b=="object")):[],p=v=>D(v)?Se(v.filter(b=>En(b))):[],m={submissionId:s,supersedesSubmissionId:a,languagesToAdd:u(i.languagesToAdd),languagesToEdit:u(i.languagesToEdit),relationships:l(i.relationships),newReferences:d(i.newReferences),newSeparatingFunctions:p(i.newSeparatingFunctions),customTags:g(i.customTags),modifiedRelations:h(i.modifiedRelations),contributor:r,queueEntries:void 0},f=Vo(i.queueEntries);if(f.length===0)return console.warn("Skipping submission history entry without queue entries",t),null;m.queueEntries=f;const y=n.summary,w=y&&typeof y=="object"?{languagesToAdd:Number(y.languagesToAdd)||m.languagesToAdd.length,languagesToEdit:Number(y.languagesToEdit)||m.languagesToEdit.length,relationships:Number(y.relationships)||m.relationships.length,newReferences:Number(y.newReferences)||m.newReferences.length}:{languagesToAdd:m.languagesToAdd.length,languagesToEdit:m.languagesToEdit.length,relationships:m.relationships.length,newReferences:m.newReferences.length},q=typeof n.supersededBySubmissionId=="string"?n.supersededBySubmissionId:void 0;return{id:t,createdAt:o,summary:w,payload:m,supersedesSubmissionId:a,supersededBySubmissionId:q}}function Ho(e){return D(e)?e.map(t=>zo(t)).filter(t=>t!==null).sort((t,o)=>t.createdAt<o.createdAt?1:-1).slice(0,Ue):[]}function Yo(){if(typeof localStorage>"u")return[];try{const e=localStorage.getItem(kn);return e?Ho(JSON.parse(e)):[]}catch(e){return console.warn("Failed to load submission history",e),[]}}function Go(e){if(!(typeof localStorage>"u"))try{localStorage.setItem(kn,JSON.stringify(e.slice(0,Ue)))}catch(n){console.warn("Failed to save submission history",n)}}function Ko(e){const n=new Date().toISOString();return{id:e.submissionId,createdAt:n,summary:{languagesToAdd:e.languagesToAdd.length,languagesToEdit:e.languagesToEdit.length,relationships:e.relationships.length,newReferences:e.newReferences.length},payload:{...e,languagesToAdd:re(e.languagesToAdd),languagesToEdit:re(e.languagesToEdit),relationships:qe(e.relationships),newReferences:[...e.newReferences],newSeparatingFunctions:Se(e.newSeparatingFunctions),customTags:Tn(e.customTags),modifiedRelations:[...e.modifiedRelations],contributor:{...e.contributor},queueEntries:e.queueEntries?Cn(e.queueEntries):void 0},supersedesSubmissionId:e.supersedesSubmissionId??null,supersededBySubmissionId:void 0}}function pi(e){const n=Yo(),t=Ko(e),o=n.filter(a=>a.id!==t.id);if(t.supersedesSubmissionId){const a=o.find(c=>c.id===t.supersedesSubmissionId);a&&(a.supersededBySubmissionId=t.id)}const s=[t,...o].slice(0,Ue);return Go(s),s}function mi(e){if(!Array.isArray(e.queueEntries)||e.queueEntries.length===0)throw new Error("Submission history entry is missing queueEntries.");return Cn(e.queueEntries)}function Re(e,n){const t=[];for(const o of e.definitionRefs){const i=n.get(o);i&&t.push(i)}return{id:vn(e.name),name:e.name,fullName:e.fullName,definition:e.definition,definitionRefs:[...e.definitionRefs],properties:{queries:e.queries,transformations:e.transformations},tags:e.tags,references:t}}function yi(e,n){const t=ue(e),o=()=>{for(const d of t.languages){const g=d.properties?.queries;if(g&&typeof g=="object")for(const m of Object.values(g)){const f=m?.complexity;(typeof f!="string"||!Ge(f))&&(m.complexity="unknown-to-us")}const p=d.properties?.transformations;if(p&&typeof p=="object")for(const m of Object.values(p)){const f=m?.complexity;(typeof f!="string"||!Ge(f))&&(m.complexity="unknown-to-us")}}},i=d=>{const{adjacencyMatrix:g}=t;if(d in g.indexByLanguage)return;const p=g.languageIds.length;g.languageIds.push(d),g.indexByLanguage[d]=p;for(const m of g.matrix)m.push(null);g.matrix.push(new Array(p+1).fill(null))},s=new Map;if(t.references)for(const d of t.references)s.set(d.id,d);const a=new Set(s.keys()),c=new Map;if(t.separatingFunctions)for(const d of t.separatingFunctions)c.set(d.shortName,d);const r=new Set(n.modifiedRelations??[]),u=d=>{const g={shortName:d.shortName,name:d.name,description:d.description,refs:[...d.refs]};c.set(g.shortName,g),t.separatingFunctions=[...t.separatingFunctions??[],g]},l=d=>{i(d.sourceId),i(d.targetId);const g=t.adjacencyMatrix.indexByLanguage[d.sourceId],p=t.adjacencyMatrix.indexByLanguage[d.targetId];if(g===void 0||p===void 0)return;const m=`${d.sourceId}->${d.targetId}`;if(r.size>0&&!r.has(m)&&t.adjacencyMatrix.matrix[g]?.[p])return;if(!d.status||d.status==="unknown-to-us"){t.adjacencyMatrix.matrix[g][p]=null;return}const f=[];if(d.separatingFunctionIds&&d.separatingFunctionIds.length>0)for(const w of d.separatingFunctionIds)c.has(w)&&f.push(w);const y={status:d.status,description:d.description,caveat:d.caveat,refs:[...d.refs],separatingFunctionIds:f.length>0?f:void 0,derived:!1};t.adjacencyMatrix.matrix[g][p]=y};for(const d of n.entries)switch(d.kind){case"reference":{const g=d.payload,p=st(g.bibtex,a);a.add(p);const m={id:p,title:g.title,href:g.href,bibtex:g.bibtex};s.set(p,m),t.references=[...t.references??[],m];break}case"separator":{u(d.payload);break}case"language:new":{const g=Re(d.payload,s);t.languages.push(g),i(g.id);break}case"language:edit":{const g=vn(d.payload.name),p=t.languages.findIndex(m=>m.id===g);if(p===-1){const m=Re(d.payload,s);t.languages.push(m),i(m.id)}else t.languages[p]=Re(d.payload,s);break}case"relationship":{l(d.payload);break}}o();const h=yn(t);if(!h.ok){const d=h.errors?.join("; ")??"unknown structural error";throw new Error(`Contribution queue produced an invalid dataset: ${d}`)}return bn(t)}export{go as A,ui as B,Z as C,li as D,pi as E,B as Q,J as T,gt as a,vt as b,ei as c,ti as d,Jo as e,Qe as f,vn as g,In as h,Zo as i,yi as j,Fo as k,Yo as l,ci as m,mi as n,ni as o,ut as p,pt as q,ft as r,fi as s,oi as t,ii as u,si as v,ai as w,ri as x,di as y,Po as z};
