{
  "languages": [
    {
      "fullName": "Algebraic Normal Form",
      "name": "ANF",
      "properties": {
        "queries": {},
        "transformations": {}
      },
      "tags": [],
      "id": "lang_8f666aa0",
      "definition": "A Boolean formula represented exclusively using the exclusive-OR (XOR) and AND logical operators, taking the shape of a XOR sum of conjunctions. Originally introduced as Zhegalkin polynomials, it is highly structured but generally less space-efficient for standard compilation tasks compared to decision graphs \\citet{Zhegalkin_1927}.",
      "definitionRefs": []
    },
    {
      "name": "BDD",
      "fullName": "Binary Decision Diagram",
      "properties": {
        "queries": {},
        "transformations": {}
      },
      "tags": [],
      "id": "lang_bb65ddb5",
      "definition": "A directed acyclic graph where each internal node represents a true/false decision on a specific boolean variable. Paths from the root to the leaf nodes explicitly map sequential variable assignments to a final 0 or 1 output \\citet{Lee_1959}.",
      "definitionRefs": []
    },
    {
      "id": "lang_89649e36",
      "name": "CNF",
      "fullName": "Conjunctive Normal Form",
      "definition": "A standard logical representation where a formula is an AND of clauses, with each clause being an OR of literals. While it is the foundational input format for modern SAT solvers, it supports very few polynomial-time operations natively \\citet{Boole_1847}.",
      "definitionRefs": [],
      "properties": {
        "queries": {
          "CO": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "caveat": "P = NP",
            "description": "Consistency checking for $CNF$ is NP-complete (the classic SAT problem). This is one of the foundational intractability results (\\citet{Darwiche_2002}, Proposition 4.1, Table 16)."
          },
          "IM": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "To check whether a consistent term $\\alpha$ implies a $CNF$ sentence $\\Sigma$, it suffices to verify that each clause of $\\Sigma$ shares a literal with $\\alpha$. This can be done in polynomial time (\\citet{Darwiche_2002}, Proposition 4.1, Table 21)."
          },
          "VA": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "A $CNF$ sentence is valid iff every clause in it is valid (i.e., contains a complementary pair of literals). This can be checked in linear time (\\citet{Darwiche_2002}, Proposition 4.1, Table 21)."
          },
          "CT": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002",
              "Roth_1996"
            ],
            "derived": true,
            "description": "Model Counting is unsupported by PI \\citet{Darwiche_2002,Roth_1996}, and PI compiles to CNF in polynomial time. If CNF supported Model Counting in polynomial time, then PI could too by compiling first. Therefore Model Counting is unsupported by CNF.",
            "caveat": "the polynomial hierarchy collapses"
          },
          "EQ": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Equivalence implies Consistency \\citet{Darwiche_2002}, and since Consistency is unsupported by CNF \\citet{Darwiche_2002}, then Equivalence is unsupported by CNF as well.",
            "caveat": "P = NP"
          },
          "SE": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Sentential Entailment implies Equivalence \\citet{Darwiche_2002}, and since Equivalence is unsupported by CNF \\citet{Darwiche_2002}, then Sentential Entailment is unsupported by CNF as well.",
            "caveat": "P = NP"
          },
          "CE": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Clausal Entailment implies Consistency \\citet{Darwiche_2002}, and since Consistency is unsupported by CNF \\citet{Darwiche_2002}, then Clausal Entailment is unsupported by CNF as well.",
            "caveat": "P = NP"
          },
          "ME": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Model Enumeration implies Consistency \\citet{Darwiche_2002}, and since Consistency is unsupported by CNF \\citet{Darwiche_2002}, then Model Enumeration is unsupported by CNF as well.",
            "caveat": "P = NP"
          }
        },
        "transformations": {
          "NOT_C": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "The negation of a CNF formula is a DNF formula. If CNF satisfied $\\neg$C, any DNF formula could be turned into an equivalent CNF in polytime (by double negation). Since DNF $\\not\\leq$ CNF, this is impossible (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "AND_C": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "Conjunction of CNF sentences is trivially another CNF sentence: simply take the union of all clauses (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "OR_BC": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "The disjunction of two CNF sentences $\\alpha_1 \\lor \\alpha_2$ can be computed by taking all cross products of one clause from $\\alpha_1$ and one from $\\alpha_2$, removing redundant literals and valid clauses. The result is a CNF of polynomial size (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "OR_C": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "It is straightforward to convert any term into an equivalent CNF formula in polynomial time. Since specific DNF formulas cannot be turned into equivalent CNF formulas in polynomial space (DNF $\\not\\leq$ CNF), CNF does not satisfy $\\lor$C (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "CD": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "CD is trivially satisfied: replacing literals of the conditioning term by Boolean constants in a CNF and removing valid clauses preserves the CNF property (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "FO": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "caveat": "P = NP",
            "description": "If CNF satisfies FO, then the consistency of any CNF sentence $\\Sigma$ could be tested in polytime: compute $\\exists\\text{Vars}(\\Sigma).\\Sigma$ and check validity. Since CNF does not satisfy CO, this implies P = NP (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "AND_BC": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since CNF supports Conjunction, it also supports Bounded Conjunction \\citet{Darwiche_2002}."
          },
          "SFO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since CNF supports Conditioning, Bounded Disjunction, it also supports Singleton Forgetting \\citet{Darwiche_2002}."
          }
        }
      },
      "tags": []
    },
    {
      "fullName": "Canonical/Compressed Sentential Decision Diagram",
      "name": "cSDD",
      "properties": {
        "queries": {
          "CE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001a"
            ],
            "derived": true,
            "description": "cSDD compiles to DNNF in polynomial time, and DNNF supports Clausal Entailment in polynomial time \\citet{Darwiche_2001a}. Therefore cSDD supports Clausal Entailment in polynomial time."
          },
          "CT": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001b"
            ],
            "derived": true,
            "description": "cSDD compiles to d-DNNF in polynomial time, and d-DNNF supports Model Counting in polynomial time \\citet{Darwiche_2001b}. Therefore cSDD supports Model Counting in polynomial time."
          },
          "CO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since cSDD supports Model Counting, it also supports Consistency \\citet{Darwiche_2002}."
          },
          "VA": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since cSDD supports Model Counting, it also supports Validity \\citet{Darwiche_2002}."
          },
          "IM": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "cSDD compiles to SDD in polynomial time, and SDD supports Implicant in polynomial time \\citet{Darwiche_2002}. Therefore cSDD supports Implicant in polynomial time."
          },
          "ME": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "cSDD compiles to d-DNNF in polynomial time, and d-DNNF supports Model Enumeration in polynomial time \\citet{Darwiche_2002}. Therefore cSDD supports Model Enumeration in polynomial time."
          },
          "SE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "cSDD compiles to SDD in polynomial time, and SDD supports Sentential Entailment in polynomial time \\citet{Darwiche_2002}. Therefore cSDD supports Sentential Entailment in polynomial time."
          },
          "EQ": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since cSDD supports Sentential Entailment, it also supports Equivalence \\citet{Darwiche_2002}."
          }
        },
        "transformations": {}
      },
      "tags": [],
      "id": "lang_83e3b023",
      "definition": "A Sentential Decision Diagram is called \\emph{compressed}(\\emph{canonical}) if, at each decision node, no two primes have the same sub \\citet{Darwiche_2011}.",
      "definitionRefs": []
    },
    {
      "name": "d-DNNF",
      "fullName": "Deterministic Decomposable Negation Normal Form",
      "properties": {
        "queries": {
          "CT": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001b"
            ],
            "description": "$d$-$DNNF$ satisfies CT: model counting can be performed in polynomial time by exploiting decomposability (multiplying counts at $\\land$-nodes) and determinism (adding counts at $\\lor$-nodes). This is the key tractability result motivating $d$-$DNNF$ as a compilation target \\citet{Darwiche_2001b} (\\citet{Darwiche_2002}, Proposition 4.1, Table 26)."
          },
          "CE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001a"
            ],
            "derived": true,
            "description": "d-DNNF compiles to DNNF in polynomial time, and DNNF supports Clausal Entailment in polynomial time \\citet{Darwiche_2001a}. Therefore d-DNNF supports Clausal Entailment in polynomial time."
          },
          "CO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since d-DNNF supports Model Counting, it also supports Consistency \\citet{Darwiche_2002}."
          },
          "VA": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since d-DNNF supports Model Counting, it also supports Validity \\citet{Darwiche_2002}."
          },
          "ME": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since d-DNNF supports Consistency, Conditioning, it also supports Model Enumeration \\citet{Darwiche_2002}."
          },
          "IM": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since d-DNNF supports Validity, Conditioning, it also supports Implicant \\citet{Darwiche_2002}."
          },
          "SE": {
            "complexity": "unknown-to-us",
            "refs": []
          }
        },
        "transformations": {
          "AND_BC": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "caveat": "P = NP",
            "description": "Since OBDD $\\subseteq$ d-DNNF and d-DNNF satisfies CO, the NP-completeness of consistency checking for two OBDDs (which may possess different underlying orderings) (Lemma 8.14, \\citet{Meinel_Theobald_1998}) implies d-DNNF does not satisfy $\\land$BC unless P = NP (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "CD": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "Conditioning preserves both decomposability and determinism. If $\\alpha \\land \\beta \\models \\bot$ then $(\\alpha|\\gamma) \\land (\\beta|\\gamma) \\models \\bot$ for any consistent term $\\gamma$, since $((\\alpha \\land \\beta)|\\gamma) \\land \\gamma \\models \\bot$ and $\\gamma$ is consistent (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "FO": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "caveat": "the polynomial hierarchy collapses",
            "description": "If d-DNNF satisfies FO, then every DNF can be compiled to an equivalent d-DNNF of polynomial size (using fresh selector variables and then applying FO). Since DNF $\\not\\leq$ d-DNNF, this is impossible (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "SFO": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "caveat": "P = NP",
            "description": "If d-DNNF satisfies SFO, then it satisfies $\\lor$BC (since $\\alpha_1 \\lor \\alpha_2 \\equiv \\exists x . ((x \\land \\alpha_1) \\lor (\\neg x \\land \\alpha_2))$ for fresh $x$). But d-DNNF does not satisfy $\\lor$BC unless P = NP (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "AND_C": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Conjunction implies Bounded Conjunction \\citet{Darwiche_2002}, and since Bounded Conjunction is unsupported by d-DNNF \\citet{Darwiche_2002}, then Conjunction is unsupported by d-DNNF as well.",
            "caveat": "P = NP"
          },
          "OR_BC": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Conditioning ∧ Bounded Disjunction implies Singleton Forgetting \\citet{Darwiche_2002}, and since Singleton Forgetting is unsupported by d-DNNF \\citet{Darwiche_2002}, and since Conditioning is supported in polynomial time, then Bounded Disjunction is unsupported by d-DNNF as well.",
            "caveat": "P = NP"
          },
          "OR_C": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Disjunction implies Bounded Disjunction \\citet{Darwiche_2002}, and since Bounded Disjunction is unsupported by d-DNNF \\citet{Darwiche_2002}, then Disjunction is unsupported by d-DNNF as well.",
            "caveat": "P = NP"
          }
        }
      },
      "tags": [],
      "id": "lang_6c130090",
      "definition": "A variant of DNNF where the children of every OR node represent mutually exclusive (deterministic) formulas. This added determinism is the critical property that enables efficient, linear-time model counting and probabilistic inference \\citet{Darwiche_2001a}.",
      "definitionRefs": []
    },
    {
      "fullName": "-",
      "name": "d-SDNNF",
      "properties": {
        "queries": {
          "CE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001a"
            ],
            "derived": true,
            "description": "d-SDNNF compiles to DNNF in polynomial time, and DNNF supports Clausal Entailment in polynomial time \\citet{Darwiche_2001a}. Therefore d-SDNNF supports Clausal Entailment in polynomial time."
          },
          "CT": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001b"
            ],
            "derived": true,
            "description": "d-SDNNF compiles to d-DNNF in polynomial time, and d-DNNF supports Model Counting in polynomial time \\citet{Darwiche_2001b}. Therefore d-SDNNF supports Model Counting in polynomial time."
          },
          "CO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since d-SDNNF supports Model Counting, it also supports Consistency \\citet{Darwiche_2002}."
          },
          "VA": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since d-SDNNF supports Model Counting, it also supports Validity \\citet{Darwiche_2002}."
          },
          "IM": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "d-SDNNF compiles to d-DNNF in polynomial time, and d-DNNF supports Implicant in polynomial time \\citet{Darwiche_2002}. Therefore d-SDNNF supports Implicant in polynomial time."
          },
          "ME": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "d-SDNNF compiles to d-DNNF in polynomial time, and d-DNNF supports Model Enumeration in polynomial time \\citet{Darwiche_2002}. Therefore d-SDNNF supports Model Enumeration in polynomial time."
          },
          "SE": {
            "complexity": "unknown-to-us",
            "refs": []
          }
        },
        "transformations": {
          "NOT_C": {
            "complexity": "no-quasi",
            "refs": [
              "Vinall-Smeeth_2024"
            ],
            "description": "Structured deterministic DNNF ($d$-$SDNNF$) is not closed under negation. \\citet{Vinall-Smeeth_2024} formally proves that there exist Boolean functions with polynomial-size $d$-$SDNNF$ representations whose exact negations require exponential-size $d$-$SDNNF$s.\nTODO: Check that this result truly holds to $d-SDNNF$, not just $d-SDNNF_T$"
          }
        }
      },
      "tags": [],
      "id": "lang_ea9b5299",
      "definition": "A deterministic DNNF where the variable decomposition across the graph is governed by a hierarchical variable tree (vtree). \\citet{Pipatsrisawat_2008}.",
      "definitionRefs": []
    },
    {
      "fullName": "-",
      "name": "d-SDNNF$_T$",
      "properties": {
        "queries": {},
        "transformations": {}
      },
      "tags": [],
      "id": "lang_91f812d0",
      "definition": "The set of all d-SDNNF formulas that follow a fixed vtree $T$ \\citet{Pipatsrisawat_2008}.",
      "definitionRefs": []
    },
    {
      "id": "lang_4c204bf3",
      "name": "DNF",
      "fullName": "Disjunctive Normal Form",
      "definition": "A logical formula expressed as an OR of terms, where each term is an AND of literals.",
      "definitionRefs": [],
      "properties": {
        "queries": {
          "VA": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "caveat": "P = NP",
            "description": "Validity checking for $DNF$ is coNP-complete. A $DNF$ is valid iff every assignment satisfies at least one term, which requires checking that term coverage is complete (\\citet{Darwiche_2002}, Proposition 4.1, Table 16)."
          },
          "CE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001a"
            ],
            "derived": true,
            "description": "DNF compiles to DNNF in polynomial time, and DNNF supports Clausal Entailment in polynomial time \\citet{Darwiche_2001a}. Therefore DNF supports Clausal Entailment in polynomial time."
          },
          "CO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since DNF supports Clausal Entailment, it also supports Consistency \\citet{Darwiche_2002}."
          },
          "ME": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since DNF supports Consistency, Conditioning, it also supports Model Enumeration \\citet{Darwiche_2002}."
          },
          "CT": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Model Counting is unsupported by IP \\citet{Darwiche_2002}, and IP compiles to DNF in polynomial time. If DNF supported Model Counting in polynomial time, then IP could too by compiling first. Therefore Model Counting is unsupported by DNF.",
            "caveat": "the polynomial hierarchy collapses"
          },
          "EQ": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Equivalence implies Validity \\citet{Darwiche_2002}, and since Validity is unsupported by DNF \\citet{Darwiche_2002}, then Equivalence is unsupported by DNF as well.",
            "caveat": "P = NP"
          },
          "SE": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Sentential Entailment implies Equivalence \\citet{Darwiche_2002}, and since Equivalence is unsupported by DNF \\citet{Darwiche_2002}, then Sentential Entailment is unsupported by DNF as well.",
            "caveat": "P = NP"
          },
          "IM": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Implicant implies Validity \\citet{Darwiche_2002}, and since Validity is unsupported by DNF \\citet{Darwiche_2002}, then Implicant is unsupported by DNF as well.",
            "caveat": "P = NP"
          }
        },
        "transformations": {
          "NOT_C": {
            "complexity": "no-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Negation ∧ Disjunction implies Conjunction \\citet{Darwiche_2002}, and since Conjunction is unsupported by DNF in quasi-polynomial time \\citet{Darwiche_2002}, and since Disjunction is supported in quasi-polynomial time, then Negation is unsupported by DNF in quasi-polynomial time as well."
          },
          "AND_BC": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "The conjunction of two DNF sentences $\\alpha_1 \\land \\alpha_2$ can be computed by taking all cross products of one term from $\\alpha_1$ and one from $\\alpha_2$, removing redundant literals and inconsistent terms. The result is a DNF of polynomial size (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "AND_C": {
            "complexity": "no-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "It is straightforward to convert a clause into an equivalent DNF formula in polynomial time. Since specific CNF formulas cannot be turned into equivalent DNF formulas in quasi-polynomial space (CNF $\\not\\leq$ DNF), DNF does not satisfy $\\land$C (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "OR_C": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "Disjunction of DNF sentences is trivially another DNF sentence: simply take the union of all terms (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "CD": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "CD is trivially satisfied: replacing literals of the conditioning term by Boolean constants in a DNF and removing inconsistent terms preserves the DNF property (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "FO": {
            "complexity": "poly",
            "refs": [
              "Lang_2000"
            ],
            "description": "DNF satisfies FO \\citet{Lang_2000}. Forgetting variables from a DNF sentence can be done in polytime (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "OR_BC": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since DNF supports Disjunction, it also supports Bounded Disjunction \\citet{Darwiche_2002}."
          },
          "SFO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since DNF supports Forgetting, it also supports Singleton Forgetting \\citet{Darwiche_2002}."
          }
        }
      },
      "tags": []
    },
    {
      "name": "DNNF",
      "fullName": "Decomposable Negation Normal Form",
      "properties": {
        "queries": {
          "CE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001a"
            ],
            "description": "$DNNF$ supports clause entailment (CE) in polynomial time \\citet{Darwiche_2001a}. To test $\\Sigma \\models \\gamma$ for clause $\\gamma$, it suffices to test whether $\\Sigma | \\neg\\gamma$ is inconsistent. Since $DNNF$ satisfies CD and CO, this can be done in polytime."
          },
          "CO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since DNNF supports Clausal Entailment, it also supports Consistency \\citet{Darwiche_2002}."
          },
          "ME": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since DNNF supports Consistency, Conditioning, it also supports Model Enumeration \\citet{Darwiche_2002}."
          },
          "VA": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Validity is unsupported by DNF \\citet{Darwiche_2002}, and DNF compiles to DNNF in polynomial time. If DNNF supported Validity in polynomial time, then DNF could too by compiling first. Therefore Validity is unsupported by DNNF.",
            "caveat": "P = NP"
          },
          "SE": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Sentential Entailment implies Equivalence \\citet{Darwiche_2002}, and since Equivalence is unsupported by DNNF \\citet{Darwiche_2002}, then Sentential Entailment is unsupported by DNNF as well.",
            "caveat": "P = NP"
          },
          "CT": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Model Counting is unsupported by IP \\citet{Darwiche_2002}, and IP compiles to DNNF in polynomial time. If DNNF supported Model Counting in polynomial time, then IP could too by compiling first. Therefore Model Counting is unsupported by DNNF.",
            "caveat": "the polynomial hierarchy collapses"
          },
          "EQ": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Equivalence implies Validity \\citet{Darwiche_2002}, and since Validity is unsupported by DNNF \\citet{Darwiche_2002}, then Equivalence is unsupported by DNNF as well.",
            "caveat": "P = NP"
          },
          "IM": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Implicant implies Validity \\citet{Darwiche_2002}, and since Validity is unsupported by DNNF \\citet{Darwiche_2002}, then Implicant is unsupported by DNNF as well.",
            "caveat": "P = NP"
          }
        },
        "transformations": {
          "NOT_C": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "caveat": "P = NP",
            "description": "If DNNF satisfies $\\neg$C, then any CNF formula could be converted to DNNF in polytime (negate a DNF equivalent of $\\neg\\Sigma$). Since DNNF satisfies CO, this would give P = NP (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "AND_BC": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "caveat": "P = NP",
            "description": "Checking consistency of two OBDDs (which may possess different underlying variable orderings) is NP-complete (Lemma 8.14, \\citet{Meinel_Theobald_1998}). Since OBDD $\\subseteq$ DNNF and DNNF satisfies CO, if DNNF satisfied $\\land$BC then consistency of two OBDDs could be tested in polytime, implying P = NP (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "OR_C": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "Disjunction trivially preserves decomposability since decomposability only constrains $\\land$-nodes. (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "CD": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "Conditioning preserves decomposability: if $\\alpha$ and $\\beta$ do not share variables, then $\\alpha|\\gamma$ and $\\beta|\\gamma$ do not share variables either, since $\\text{Vars}(\\alpha|\\gamma) \\subseteq \\text{Vars}(\\alpha)$ (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "FO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001a"
            ],
            "description": "DNNF satisfies FO: forgetting a set of variables in a DNNF sentence can be performed in polynomial time while preserving decomposability \\citet{Darwiche_2001a} (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "OR_BC": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since DNNF supports Disjunction, it also supports Bounded Disjunction \\citet{Darwiche_2002}."
          },
          "SFO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since DNNF supports Forgetting, it also supports Singleton Forgetting \\citet{Darwiche_2002}."
          },
          "AND_C": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Conjunction implies Bounded Conjunction \\citet{Darwiche_2002}, and since Bounded Conjunction is unsupported by DNNF \\citet{Darwiche_2002}, then Conjunction is unsupported by DNNF as well.",
            "caveat": "P = NP"
          }
        }
      },
      "tags": [],
      "id": "lang_3bebcab7",
      "definition": "The subset of NNF where the children of every AND node operate on completely disjoint sets of variables. This non-overlapping variable property, known as decomposability, guarantees polynomial-time consistency checking \\citet{Darwiche_2001a}.",
      "definitionRefs": []
    },
    {
      "name": "FBDD",
      "fullName": "Free Binary Decision Diagram",
      "properties": {
        "queries": {
          "CO": {
            "complexity": "poly",
            "refs": [
              "Gergov_1994"
            ],
            "description": "$FBDD$ satisfies CO \\citet{Gergov_1994, Darwiche_2002}. Consistency is polynomial: check if the BDD root is not the terminal 0 node."
          },
          "CT": {
            "complexity": "poly",
            "refs": [
              "Gergov_1994"
            ],
            "description": "$FBDD$ satisfies CT \\citet{Gergov_1994, Darwiche_2002}. Model counting on FBDDs can be done in polynomial time by a single bottom-up pass counting satisfying assignments at each node."
          },
          "VA": {
            "complexity": "poly",
            "refs": [
              "Gergov_1994"
            ],
            "description": "$FBDD$ satisfies VA \\citet{Gergov_1994, Darwiche_2002}. Simply check if the BDD root equals the terminal 1 node."
          },
          "CE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001a"
            ],
            "derived": true,
            "description": "FBDD compiles to DNNF in polynomial time, and DNNF supports Clausal Entailment in polynomial time \\citet{Darwiche_2001a}. Therefore FBDD supports Clausal Entailment in polynomial time."
          },
          "ME": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since FBDD supports Consistency, Conditioning, it also supports Model Enumeration \\citet{Darwiche_2002}."
          },
          "IM": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since FBDD supports Validity, Conditioning, it also supports Implicant \\citet{Darwiche_2002}."
          },
          "SE": {
            "complexity": "unknown-to-us",
            "refs": []
          }
        },
        "transformations": {
          "NOT_C": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "Negation of an FBDD is achieved by switching the labels of the 0-sink and 1-sink. The decision property and read-once property are preserved (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "AND_BC": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "caveat": "P = NP",
            "description": "Since OBDD $\\subseteq$ FBDD and FBDD satisfies CO, the NP-completeness of consistency checking for two OBDDs (which may possess different underlying orderings) implies FBDD does not satisfy $\\land$BC unless P = NP (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "AND_C": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "It is straightforward to convert a clause into an equivalent FBDD formula in polynomial time. Since specific CNF formulas cannot be turned into equivalent FBDD formulas in polynomial space (CNF $\\not\\leq$ FBDD), FBDD does not satisfy $\\land$C (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "OR_BC": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "caveat": "P = NP",
            "description": "Since OBDD satisfies $\\neg$C and OBDD $\\subseteq$ FBDD, if FBDD satisfied $\\lor$BC then $\\neg\\alpha_1 \\lor \\neg\\alpha_2$ could be computed and checked for validity in polytime. Since d-DNNF satisfies VA and FBDD $\\subseteq$ d-DNNF, this would solve an NP-hard problem (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "OR_C": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "It is straightforward to convert any term into an equivalent FBDD formula in polynomial time. Since specific DNF formulas cannot be turned into equivalent FBDD formulas in polynomial space (DNF $\\not\\leq$ FBDD), FBDD does not satisfy $\\lor$C (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "CD": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "Conditioning on FBDD is the restrict operation: replace each node labeled by a variable in the conditioning term with one of its children. This preserves the free (read-once) property (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "FO": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "If FBDD satisfies FO, then every DNF can be compiled to an equivalent FBDD of polynomial size. Since DNF $\\not\\leq$ FBDD, this is impossible (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "SFO": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "caveat": "P = NP",
            "description": "If FBDD satisfies SFO, then it satisfies $\\lor$BC (since disjunction can be encoded via SFO with a fresh variable). But FBDD does not satisfy $\\lor$BC unless P = NP (\\citet{Darwiche_2002}, Proposition 5.1)."
          }
        }
      },
      "tags": [],
      "id": "lang_684b1ca7",
      "definition": "A Binary Decision Diagram that allows variables to be tested in any order along any given path, provided no variable is tested more than once per path. This property is called the read-once property \\citet{Gergov_1994}.",
      "definitionRefs": []
    },
    {
      "name": "IP",
      "fullName": "Prime Implicants",
      "properties": {
        "queries": {
          "CT": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "caveat": "the polynomial hierarchy collapses",
            "description": "By duality with $PI$: the negation of a formula in prime implicate form is in prime implicant ($IP$) form. The number of models of $\\neg\\Sigma$ over $\\text{Vars}(\\Sigma)$ is $2^n$ minus the model count of $\\Sigma$. Hence the \\#P-hardness of counting for $PI$ transfers to $IP$ (\\citet{Darwiche_2002}, Proposition 4.1, Table 24)."
          },
          "IM": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "By definition, $IP$ is the set of prime implicants of a formula. A consistent term $\\alpha$ implies $\\Sigma$ iff $\\alpha$ entails some prime implicant of $\\Sigma$. This entailment check between terms runs in polynomial time (\\citet{Darwiche_2002}, Proposition 4.1, Table 24)."
          },
          "SE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "$IP \\subseteq DNF$ and $IP$ satisfies IM, so checking sentential entailment reduces to checking implication between prime implicant forms. Two formulas are equivalent iff they share the same prime implicants (canonical form), giving SE (\\citet{Darwiche_2002}, Proposition 4.1, Table 24)."
          },
          "CE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001a"
            ],
            "derived": true,
            "description": "IP compiles to DNNF in polynomial time, and DNNF supports Clausal Entailment in polynomial time \\citet{Darwiche_2001a}. Therefore IP supports Clausal Entailment in polynomial time."
          },
          "EQ": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since IP supports Sentential Entailment, it also supports Equivalence \\citet{Darwiche_2002}."
          },
          "VA": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since IP supports Implicant, it also supports Validity \\citet{Darwiche_2002}."
          },
          "CO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since IP supports Clausal Entailment, it also supports Consistency \\citet{Darwiche_2002}."
          },
          "ME": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since IP supports Consistency, Conditioning, it also supports Model Enumeration \\citet{Darwiche_2002}."
          }
        },
        "transformations": {
          "NOT_C": {
            "complexity": "no-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "Dual of PI: $\\Sigma_n = \\bigvee_{i=0}^{n-1}(x_{2i} \\land x_{2i+1})$ is in IP form but has $2^n$ prime implicates. Its negation has $2^n$ prime implicants. Hence IP cannot satisfy $\\neg$C (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "AND_BC": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "$\\text{IP}(\\alpha_1 \\land \\alpha_2) = \\max(\\{\\beta_1 \\land \\beta_2 \\mid \\beta_1 \\in \\text{IP}(\\alpha_1), \\beta_2 \\in \\text{IP}(\\alpha_2)\\}, \\models)$ (dual of Proposition 40, Marquis 2000). The maximization removes subsuming terms, yielding an IP form in polytime (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "AND_C": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "It is straightforward to convert a clause into an equivalent IP formula in polynomial time. Since specific CNF formulas cannot be turned into equivalent IP formulas in polynomial space (CNF $\\not\\leq$ IP), IP does not satisfy $\\land$C (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "OR_BC": {
            "complexity": "no-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "Combining prime implicants via disjunction requires distributing and re-minimizing terms, which can lead to an exponential explosion of new prime implicants. Let $\\alpha_1 = \\bigwedge_{i=1}^k p_i$ (one prime implicant) and $\\alpha_2 = \\bigvee_{i=1}^k \\bigvee_{j=1}^m (\\neg p_i \\land q_{i,j})$ ($mk$ prime implicants). Then $\\alpha_1 \\lor \\alpha_2$ has $(m+1)^k + mk$ prime implicants, an exponential blowup \\citet{Chandra_1978} (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "OR_C": {
            "complexity": "no-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Disjunction implies Bounded Disjunction \\citet{Darwiche_2002}, and since Bounded Disjunction is unsupported by IP in quasi-polynomial time \\citet{Darwiche_2002}, then Disjunction is unsupported by IP in quasi-polynomial time as well."
          },
          "CD": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "Given IP formula $\\Sigma = \\bigvee \\gamma_i$, conditioning on $\\gamma$ gives $\\bigvee (\\gamma_i|\\gamma)$. Keeping only the logically weakest surviving terms yields a prime implicants formula equivalent to $\\Sigma|\\gamma$. This requires $O(n^2)$ entailment tests among terms, each polytime (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "SFO": {
            "complexity": "no-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "The number of prime implicants of $\\exists x.\\Sigma$ can be exponentially greater than the number of prime implicants of $\\Sigma$ \\citet{Chandra_1978}. A specific construction with $mk+1$ prime implicants produces $(m+1)^k + mk$ prime implicants after forgetting one variable (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "FO": {
            "complexity": "no-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Forgetting implies Singleton Forgetting \\citet{Darwiche_2002}, and since Singleton Forgetting is unsupported by IP in quasi-polynomial time \\citet{Darwiche_2002}, then Forgetting is unsupported by IP in quasi-polynomial time as well."
          }
        }
      },
      "tags": [],
      "id": "lang_6ae90adc",
      "definition": "A formula represented exactly as the disjunction of all its minimal entailing conjunctions (prime implicants). \\citet{Quine_1952}.",
      "definitionRefs": []
    },
    {
      "name": "MODS",
      "fullName": "Models",
      "properties": {
        "queries": {
          "CO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "A sentence $\\Sigma$ is consistent iff it has at least one model. Given the set of models, we need only check non-emptyness of the set (\\citet{Darwiche_2002}, Proposition 4.1, Table 18)."
          },
          "CT": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "We need only take the cardinality of the set of models (which can be done in linear time) (\\citet{Darwiche_2002}, Proposition 4.1, Table 18)."
          },
          "VA": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "MODS compiles to CNF in polynomial time, and CNF supports Validity in polynomial time \\citet{Darwiche_2002}. Therefore MODS supports Validity in polynomial time."
          },
          "CE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001a"
            ],
            "derived": true,
            "description": "MODS compiles to DNNF in polynomial time, and DNNF supports Clausal Entailment in polynomial time \\citet{Darwiche_2001a}. Therefore MODS supports Clausal Entailment in polynomial time."
          },
          "IM": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "MODS compiles to CNF in polynomial time, and CNF supports Implicant in polynomial time \\citet{Darwiche_2002}. Therefore MODS supports Implicant in polynomial time."
          },
          "EQ": {
            "complexity": "poly",
            "refs": [
              "Bryant_1986",
              "Bryant_1992",
              "Meinel_Theobald_1998"
            ],
            "derived": true,
            "description": "MODS compiles to OBDD$_<$ in polynomial time, and OBDD$_<$ supports Equivalence in polynomial time \\citet{Bryant_1986,Bryant_1992,Meinel_Theobald_1998}. Therefore MODS supports Equivalence in polynomial time."
          },
          "SE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "MODS compiles to IP in polynomial time, and IP supports Sentential Entailment in polynomial time \\citet{Darwiche_2002}. Therefore MODS supports Sentential Entailment in polynomial time."
          },
          "ME": {
            "complexity": "poly",
            "refs": [
              "Bryant_1986"
            ],
            "derived": true,
            "description": "MODS compiles to OBDD$_<$ in polynomial time, and OBDD$_<$ supports Model Enumeration in polynomial time \\citet{Bryant_1986}. Therefore MODS supports Model Enumeration in polynomial time."
          }
        },
        "transformations": {
          "NOT_C": {
            "complexity": "no-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "$\\Sigma = \\bigwedge_{i=1}^n x_i$ has only one model over $\\{x_1,\\ldots,x_n\\}$ but its negation $\\neg\\Sigma$ has $2^n - 1$ models. Hence MODS cannot satisfy $\\neg$C (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "AND_BC": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "The bounded conjunction of two MODS formulas (over the same variables) is simply taking the intersection of their model sets. If the variables differ, it is the intersection of their cylindrical extensions. The result is a MODS sentence in polytime (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "AND_C": {
            "complexity": "no-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "Let $\\Sigma_i = (x_{i,1} \\lor x_{i,2})$ for $i = 1,\\ldots,n$. Each $\\Sigma_i$ has 3 models. But $\\Sigma = \\bigwedge_{i=1}^n \\Sigma_i$ has $3^n$ models, so no polynomial-size MODS representation exists (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "OR_C": {
            "complexity": "no-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "Let $\\alpha_1 = \\bigwedge_{i=1}^n x_i$ (1 model) and $\\alpha_2 = y$ (1 model). Then $\\alpha_1 \\lor \\alpha_2$ has $2^n + 1$ models over $\\text{Vars}(\\alpha_1) \\cup \\text{Vars}(\\alpha_2)$. Hence MODS cannot satisfy $\\lor$C (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "FO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "Given a MODS formula $\\Sigma$ and a set $X$, the MODS representation of $\\exists X.\\Sigma$ is obtained by removing every leaf node labeled by a literal $x$ or $\\neg x$ with $x \\in X$ (Propositions 18 and 20, Lang et al. 2000). See also the polytime FO operation on DNNF from \\citet{Darwiche_2001a} (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "SFO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since MODS supports Forgetting, it also supports Singleton Forgetting \\citet{Darwiche_2002}."
          },
          "CD": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since MODS supports Bounded Conjunction, Singleton Forgetting, it also supports Conditioning \\citet{Darwiche_2002}."
          }
        }
      },
      "tags": [],
      "id": "lang_e02902d0",
      "definition": "The set of satisfying truth assignments for a given formula. It may be interpreted as the disjunction of each model, and thus as a d-SDNNF formula \\citet{Darwiche_2002}.",
      "definitionRefs": []
    },
    {
      "fullName": "Nondeterministic Free Binary Decision Diagram",
      "name": "nFBDD",
      "properties": {
        "queries": {
          "CT": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Colnet_2025"
            ],
            "caveat": "the polynomial hierarchy collapses",
            "description": "Exact model counting for non-deterministic read-once branching programs ($nFBDD$) is \\#P-hard. This is because non-determinism allows multiple computational paths to satisfy the same assignment \\citet{Colnet_2025}."
          },
          "CE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001a"
            ],
            "derived": true,
            "description": "nFBDD compiles to DNNF in polynomial time, and DNNF supports Clausal Entailment in polynomial time \\citet{Darwiche_2001a}. Therefore nFBDD supports Clausal Entailment in polynomial time."
          },
          "CO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since nFBDD supports Clausal Entailment, it also supports Consistency \\citet{Darwiche_2002}."
          },
          "ME": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "nFBDD compiles to DNNF in polynomial time, and DNNF supports Model Enumeration in polynomial time \\citet{Darwiche_2002}. Therefore nFBDD supports Model Enumeration in polynomial time."
          },
          "SE": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Sentential Entailment implies Equivalence \\citet{Darwiche_2002}, and since Equivalence is unsupported by nFBDD \\citet{Darwiche_2002}, then Sentential Entailment is unsupported by nFBDD as well.",
            "caveat": "P = NP"
          },
          "VA": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Validity is unsupported by DNF \\citet{Darwiche_2002}, and DNF compiles to nFBDD in polynomial time. If nFBDD supported Validity in polynomial time, then DNF could too by compiling first. Therefore Validity is unsupported by nFBDD.",
            "caveat": "P = NP"
          },
          "EQ": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Equivalence implies Validity \\citet{Darwiche_2002}, and since Validity is unsupported by nFBDD \\citet{Darwiche_2002}, then Equivalence is unsupported by nFBDD as well.",
            "caveat": "P = NP"
          },
          "IM": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Implicant implies Validity \\citet{Darwiche_2002}, and since Validity is unsupported by nFBDD \\citet{Darwiche_2002}, then Implicant is unsupported by nFBDD as well.",
            "caveat": "P = NP"
          }
        },
        "transformations": {
          "NOT_C": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Negation ∧ Consistency implies Validity \\citet{Darwiche_2002}, and since Validity is unsupported by nFBDD \\citet{Darwiche_2002}, and since Consistency is supported in polynomial time, then Negation is unsupported by nFBDD as well.",
            "caveat": "P = NP"
          }
        }
      },
      "tags": [],
      "id": "lang_1df07cc3",
      "definition": "A generalization of the FBDD that allows for nondeterministic \"guess\" nodes in addition to standard variable decisions. \\citet{Wegener_2000}.",
      "definitionRefs": []
    },
    {
      "name": "NNF",
      "fullName": "Negation Normal Form",
      "properties": {
        "queries": {
          "CO": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Consistency is unsupported by CNF \\citet{Darwiche_2002}, and CNF compiles to NNF in polynomial time. If NNF supported Consistency in polynomial time, then CNF could too by compiling first. Therefore Consistency is unsupported by NNF.",
            "caveat": "P = NP"
          },
          "VA": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Validity is unsupported by DNF \\citet{Darwiche_2002}, and DNF compiles to NNF in polynomial time. If NNF supported Validity in polynomial time, then DNF could too by compiling first. Therefore Validity is unsupported by NNF.",
            "caveat": "P = NP"
          },
          "SE": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Sentential Entailment implies Equivalence \\citet{Darwiche_2002}, and since Equivalence is unsupported by NNF \\citet{Darwiche_2002}, then Sentential Entailment is unsupported by NNF as well.",
            "caveat": "P = NP"
          },
          "CT": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Model Counting is unsupported by IP \\citet{Darwiche_2002}, and IP compiles to NNF in polynomial time. If NNF supported Model Counting in polynomial time, then IP could too by compiling first. Therefore Model Counting is unsupported by NNF.",
            "caveat": "the polynomial hierarchy collapses"
          },
          "EQ": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Equivalence implies Consistency \\citet{Darwiche_2002}, and since Consistency is unsupported by NNF \\citet{Darwiche_2002}, then Equivalence is unsupported by NNF as well.",
            "caveat": "P = NP"
          },
          "IM": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Implicant implies Validity \\citet{Darwiche_2002}, and since Validity is unsupported by NNF \\citet{Darwiche_2002}, then Implicant is unsupported by NNF as well.",
            "caveat": "P = NP"
          },
          "CE": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Clausal Entailment implies Consistency \\citet{Darwiche_2002}, and since Consistency is unsupported by NNF \\citet{Darwiche_2002}, then Clausal Entailment is unsupported by NNF as well.",
            "caveat": "P = NP"
          },
          "ME": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Model Enumeration implies Consistency \\citet{Darwiche_2002}, and since Consistency is unsupported by NNF \\citet{Darwiche_2002}, then Model Enumeration is unsupported by NNF as well.",
            "caveat": "P = NP"
          }
        },
        "transformations": {
          "NOT_C": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "NNF trivially satisfies $\\neg$C since any propositional sentence can be converted to NNF by pushing negations to literals and this preserves the NNF property (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "AND_C": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "Taking the conjunction of NNF sentences $\\alpha_1 \\land \\alpha_2 \\land \\ldots$ trivially produces another NNF sentence, since NNF places no restrictions on $\\land$-nodes (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "OR_C": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "Taking the disjunction of NNF sentences $\\alpha_1 \\lor \\alpha_2 \\lor \\ldots$ trivially produces another NNF sentence, since NNF places no restrictions on $\\lor$-nodes (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "CD": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "CD is trivially satisfied by NNF: replacing literals of the conditioning term by Boolean constants preserves the NNF property (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "FO": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "caveat": "P = NP",
            "description": "If NNF satisfies FO, then every CNF sentence $\\Sigma$ could be tested for consistency in polytime: convert to NNF (trivial), compute $\\exists \\text{Vars}(\\Sigma).\\Sigma$ in polytime, and check if the result is valid. Since CNF consistency is NP-hard, NNF does not satisfy FO unless P = NP (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "AND_BC": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since NNF supports Conjunction, it also supports Bounded Conjunction \\citet{Darwiche_2002}."
          },
          "OR_BC": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since NNF supports Disjunction, it also supports Bounded Disjunction \\citet{Darwiche_2002}."
          },
          "SFO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since NNF supports Conditioning, Bounded Disjunction, it also supports Singleton Forgetting \\citet{Darwiche_2002}."
          }
        }
      },
      "tags": [],
      "id": "lang_5bf00851",
      "definition": "A boolean formula constructed strictly with AND, OR, and literals, where negations are only allowed directly on the variables. It serves as the broad, foundational structural superset for most tractable knowledge compilation languages \\citet{Darwiche_2002}.",
      "definitionRefs": []
    },
    {
      "fullName": "nondeterministic Ordered Binary Decision Diagram",
      "name": "nOBDD",
      "properties": {
        "queries": {
          "CE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001a"
            ],
            "derived": true,
            "description": "nOBDD compiles to DNNF in polynomial time, and DNNF supports Clausal Entailment in polynomial time \\citet{Darwiche_2001a}. Therefore nOBDD supports Clausal Entailment in polynomial time."
          },
          "CO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since nOBDD supports Clausal Entailment, it also supports Consistency \\citet{Darwiche_2002}."
          },
          "ME": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "nOBDD compiles to DNNF in polynomial time, and DNNF supports Model Enumeration in polynomial time \\citet{Darwiche_2002}. Therefore nOBDD supports Model Enumeration in polynomial time."
          },
          "SE": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Sentential Entailment implies Equivalence \\citet{Darwiche_2002}, and since Equivalence is unsupported by nOBDD \\citet{Darwiche_2002}, then Sentential Entailment is unsupported by nOBDD as well.",
            "caveat": "P = NP"
          },
          "VA": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Validity is unsupported by DNF \\citet{Darwiche_2002}, and DNF compiles to nOBDD in polynomial time. If nOBDD supported Validity in polynomial time, then DNF could too by compiling first. Therefore Validity is unsupported by nOBDD.",
            "caveat": "P = NP"
          },
          "CT": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Model Counting is unsupported by IP \\citet{Darwiche_2002}, and IP compiles to nOBDD in polynomial time. If nOBDD supported Model Counting in polynomial time, then IP could too by compiling first. Therefore Model Counting is unsupported by nOBDD.",
            "caveat": "the polynomial hierarchy collapses"
          },
          "EQ": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Equivalence implies Validity \\citet{Darwiche_2002}, and since Validity is unsupported by nOBDD \\citet{Darwiche_2002}, then Equivalence is unsupported by nOBDD as well.",
            "caveat": "P = NP"
          },
          "IM": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Implicant implies Validity \\citet{Darwiche_2002}, and since Validity is unsupported by nOBDD \\citet{Darwiche_2002}, then Implicant is unsupported by nOBDD as well.",
            "caveat": "P = NP"
          }
        },
        "transformations": {
          "NOT_C": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Negation ∧ Consistency implies Validity \\citet{Darwiche_2002}, and since Validity is unsupported by nOBDD \\citet{Darwiche_2002}, and since Consistency is supported in polynomial time, then Negation is unsupported by nOBDD as well.",
            "caveat": "P = NP"
          }
        }
      },
      "tags": [],
      "id": "lang_d24efe0e",
      "definition": "A generalization of the OBDD that permits nondeterministic branching while still enforcing a global linear variable ordering for its standard decision nodes. \\citet{Wegener_2000}.",
      "definitionRefs": []
    },
    {
      "fullName": "Ordered Binary Decision Diagram (wrt a fixed variable order)",
      "name": "OBDD$_<$",
      "properties": {
        "queries": {
          "CO": {
            "complexity": "poly",
            "refs": [
              "Bryant_1986"
            ],
            "description": "Consistency is trivial for OBDDs: check if the diagram root is not the terminal 0 node \\citet{Bryant_1986}."
          },
          "CT": {
            "complexity": "poly",
            "refs": [
              "Bryant_1986"
            ],
            "description": "Model counting on OBDDs can be done in polynomial time by a single bottom-up pass \\citet{Bryant_1986, Bryant_1992}."
          },
          "EQ": {
            "complexity": "poly",
            "refs": [
              "Bryant_1986",
              "Bryant_1992",
              "Meinel_Theobald_1998"
            ],
            "description": "OBDDs with a fixed variable ordering are canonical: two functions are equivalent iff their reduced OBDDs are identical. This makes EQ trivial (structural isomorphism check) \\citet{Bryant_1986, Bryant_1992, Meinel_Theobald_1998} (Theorem 8.11)."
          },
          "ME": {
            "complexity": "poly",
            "refs": [
              "Bryant_1986"
            ],
            "description": "Models of an OBDD can be enumerated in time polynomial in the output size by traversing all root-to-1-sink paths. Each path corresponds to a (partial) assignment that can be expanded to full models."
          },
          "VA": {
            "complexity": "poly",
            "refs": [
              "Bryant_1986"
            ],
            "description": "Validity is trivial for OBDDs: check if the diagram root equals the terminal 1 node \\citet{Bryant_1986}."
          },
          "CE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001a"
            ],
            "derived": true,
            "description": "OBDD$_<$ compiles to DNNF in polynomial time, and DNNF supports Clausal Entailment in polynomial time \\citet{Darwiche_2001a}. Therefore OBDD$_<$ supports Clausal Entailment in polynomial time."
          },
          "IM": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since OBDD$_<$ supports Validity, Conditioning, it also supports Implicant \\citet{Darwiche_2002}."
          },
          "SE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since OBDD$_<$ supports Negation, Bounded Conjunction, Consistency, it also supports Sentential Entailment \\citet{Darwiche_2002}."
          }
        },
        "transformations": {
          "AND_C": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "It is straightforward to convert a clause into an equivalent OBDD$_<$ formula in polynomial time. Since specific CNF formulas cannot be turned into equivalent OBDD$_<$ formulas in polynomial space (CNF $\\not\\leq$ OBDD$_<$), OBDD$_<$ does not satisfy $\\land$C (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "OR_C": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "It is straightforward to convert any term into an equivalent OBDD$_<$ formula in polynomial time. Since specific DNF formulas cannot be turned into equivalent OBDD$_<$ formulas in polynomial space (DNF $\\not\\leq$ OBDD$_<$), OBDD$_<$ does not satisfy $\\lor$C (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "FO": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "If OBDD$_<$ satisfies FO, then every DNF sentence $\\Gamma$ can be compiled to an equivalent OBDD$_<$ of polynomial size (using fresh selector variables and then applying FO). Since DNF $\\not\\leq$ OBDD$_<$, this is impossible (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "SFO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "$\\exists x . \\Sigma \\equiv (\\Sigma|x) \\lor (\\Sigma|\\neg x)$. Since OBDD$_<$ satisfies CD and $\\lor$BC, singleton forgetting can be computed in polytime \\citet{Bryant_1986, Darwiche_2002} (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "NOT_C": {
            "complexity": "poly",
            "refs": [
              "Bryant_1986"
            ],
            "description": "Negation of an OBDD$_<$ is achieved by switching the labels of the 0-sink and 1-sink. The result is an OBDD$_<$ of identical size \\citet{Bryant_1986}."
          },
          "AND_BC": {
            "complexity": "poly",
            "refs": [
              "Bryant_1986"
            ],
            "description": "The Apply algorithm computes the conjunction of two OBDD$_<$ sentences sharing the same variable ordering in polynomial time. The result is a reduced OBDD$_<$ \\citet{Bryant_1986}."
          },
          "OR_BC": {
            "complexity": "poly",
            "refs": [
              "Bryant_1986"
            ],
            "description": "The Apply algorithm computes the disjunction of two OBDD$_<$ sentences sharing the same variable ordering in polynomial time. The result is a reduced OBDD$_<$ \\citet{Bryant_1986}."
          },
          "CD": {
            "complexity": "poly",
            "refs": [
              "Bryant_1986"
            ],
            "description": "Conditioning (the restrict operation) on OBDD$_<$ replaces each node labeled by a variable in the conditioning term with one of its children, according to the sign of the variable. The result is a valid OBDD$_<$ \\citet{Bryant_1986}."
          }
        }
      },
      "tags": [],
      "id": "lang_d69995dd",
      "definition": "The set of all OBDD formulas following a fixed variable order $<$, which is known in advance. This strictness allows the equivalence of two distinct functions to be checked in constant time \\citet{Bryant_1986}.",
      "definitionRefs": [
        "Bryant_1986"
      ]
    },
    {
      "name": "PI",
      "fullName": "Prime Implicates",
      "properties": {
        "queries": {
          "CE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "By definition, $PI$ is the set of prime implicates of a formula. A clause $\\gamma$ is entailed by $\\Sigma$ iff $\\gamma$ subsumes (is a weakening of) some prime implicate of $\\Sigma$. This subsumption check runs in polynomial time (\\citet{Darwiche_2002}, Proposition 4.1, Table 24)."
          },
          "CT": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002",
              "Roth_1996"
            ],
            "caveat": "the polynomial hierarchy collapses",
            "description": "The model counting problem for monotone Krom formulas (conjunctions of clauses with at most two positive literals) is \\#P-complete \\citet{Roth_1996}. Such formulas can be converted to prime implicates form in polynomial time, so $PI$ does not satisfy CT (\\citet{Darwiche_2002}, Proposition 4.1, Table 24)."
          },
          "SE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "$PI \\subseteq CNF$ and $PI$ satisfies CE, so checking $\\Sigma_1 \\models \\Sigma_2$ for $CNF$ $\\Sigma_2$ reduces to checking each clause of $\\Sigma_2$ against the prime implicates of $\\Sigma_1$. Two formulas are equivalent iff they share the same prime implicates (canonical form), giving SE (\\citet{Darwiche_2002}, Proposition 4.1, Table 24)."
          },
          "VA": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "PI compiles to CNF in polynomial time, and CNF supports Validity in polynomial time \\citet{Darwiche_2002}. Therefore PI supports Validity in polynomial time."
          },
          "IM": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "PI compiles to CNF in polynomial time, and CNF supports Implicant in polynomial time \\citet{Darwiche_2002}. Therefore PI supports Implicant in polynomial time."
          },
          "EQ": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since PI supports Sentential Entailment, it also supports Equivalence \\citet{Darwiche_2002}."
          },
          "CO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since PI supports Clausal Entailment, it also supports Consistency \\citet{Darwiche_2002}."
          },
          "ME": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since PI supports Consistency, Conditioning, it also supports Model Enumeration \\citet{Darwiche_2002}."
          }
        },
        "transformations": {
          "NOT_C": {
            "complexity": "no-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "The formula $\\Sigma_n = \\bigwedge_{i=0}^{n-1}(x_{2i} \\lor x_{2i+1})$ is in PI form but has $2^n$ prime implicants. Its negation has $2^n$ prime implicates. Hence PI cannot satisfy $\\neg$C (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "AND_BC": {
            "complexity": "no-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "Combining prime implicates via conjunction requires distributing and re-minimizing clauses, which can lead to an exponential explosion of new prime implicates. Let $\\alpha_1 = \\bigvee_{i=1}^k p_i$ (one prime implicate) and $\\alpha_2 = \\bigwedge_{i=1}^k \\bigwedge_{j=1}^m (\\neg p_i \\lor q_{i,j})$ ($mk$ prime implicates). Then $\\alpha_1 \\land \\alpha_2$ has $(m+1)^k + mk$ prime implicates, an exponential blowup \\citet{Chandra_1978} (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "AND_C": {
            "complexity": "no-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Conjunction implies Bounded Conjunction \\citet{Darwiche_2002}, and since Bounded Conjunction is unsupported by PI in quasi-polynomial time \\citet{Darwiche_2002}, then Conjunction is unsupported by PI in quasi-polynomial time as well."
          },
          "OR_BC": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "$\\text{PI}(\\alpha_1 \\lor \\alpha_2) = \\min(\\{\\beta_1 \\lor \\beta_2 \\mid \\beta_1 \\in \\text{PI}(\\alpha_1), \\beta_2 \\in \\text{PI}(\\alpha_2)\\}, \\models)$ (Proposition 40, Marquis 2000). The minimization removes subsumed clauses, yielding a PI form in polytime (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "OR_C": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "It is straightforward to convert any term into an equivalent PI formula in polynomial time. Since specific DNF formulas cannot be turned into equivalent PI formulas in polynomial space (DNF $\\not\\leq$ PI), PI does not satisfy $\\lor$C (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "CD": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "The prime implicates of $\\Sigma \\land \\gamma$ can be computed in polytime when $\\Sigma$ is in PI form and $\\gamma$ is a term (Proposition 36, Marquis 2000). Since PI satisfies FO, the prime implicates of $\\Sigma|\\gamma \\equiv \\exists\\text{Vars}(\\gamma).(\\Sigma \\land \\gamma)$ follow in polytime (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "FO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "The prime implicates of $\\exists X.\\Sigma$ are exactly the prime implicates of $\\Sigma$ that do not contain any variable from $X$ (Proposition 55, Marquis 2000). Hence FO for PI simply filters out clauses containing forgotten variables (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "SFO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since PI supports Forgetting, it also supports Singleton Forgetting \\citet{Darwiche_2002}."
          }
        }
      },
      "tags": [],
      "id": "lang_27fffab2",
      "definition": "A formula represented exactly as the conjunction of all its minimal entailed disjunctive clauses (prime implicates). \\citet{Quine_1952}.",
      "definitionRefs": []
    },
    {
      "fullName": "Sentential Decision Diagram",
      "name": "SDD",
      "properties": {
        "queries": {
          "CE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001a"
            ],
            "derived": true,
            "description": "SDD compiles to DNNF in polynomial time, and DNNF supports Clausal Entailment in polynomial time \\citet{Darwiche_2001a}. Therefore SDD supports Clausal Entailment in polynomial time."
          },
          "CT": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001b"
            ],
            "derived": true,
            "description": "SDD compiles to d-DNNF in polynomial time, and d-DNNF supports Model Counting in polynomial time \\citet{Darwiche_2001b}. Therefore SDD supports Model Counting in polynomial time."
          },
          "CO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since SDD supports Model Counting, it also supports Consistency \\citet{Darwiche_2002}."
          },
          "VA": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since SDD supports Model Counting, it also supports Validity \\citet{Darwiche_2002}."
          },
          "IM": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since SDD supports Negation, Clausal Entailment, it also supports Implicant \\citet{Darwiche_2002}."
          },
          "ME": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since SDD supports Consistency, Conditioning, it also supports Model Enumeration \\citet{Darwiche_2002}."
          },
          "SE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since SDD supports Negation, Bounded Conjunction, Consistency, it also supports Sentential Entailment \\citet{Darwiche_2002}."
          },
          "EQ": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since SDD supports Sentential Entailment, it also supports Equivalence \\citet{Darwiche_2002}."
          }
        },
        "transformations": {
          "AND_BC": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2011"
            ],
            "description": "The Apply algorithm combines two SDDs using any Boolean operator in polytime. In particular, two SDDs can be conjoined in polytime via Apply \\citet{Darwiche_2011}."
          },
          "OR_BC": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2011"
            ],
            "description": "The Apply algorithm combines two SDDs using any Boolean operator in polytime. In particular, two SDDs can be disjoined in polytime via Apply \\citet{Darwiche_2011}."
          },
          "NOT_C": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2011"
            ],
            "description": "An SDD can be negated in polytime by applying exclusive-or with $\\top$ using the Apply algorithm \\citet{Darwiche_2011}."
          },
          "CD": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2011"
            ],
            "description": "Conditioning an SDD $f$ on a literal $l$ is equivalent to computing $f \\land l$. Since any literal is a trivially small SDD and SDD supports $\\land$BC in polytime via Apply, conditioning is polytime \\citet{Darwiche_2011}."
          },
          "SFO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since SDD supports Conditioning, Bounded Disjunction, it also supports Singleton Forgetting \\citet{Darwiche_2002}."
          }
        }
      },
      "tags": [],
      "id": "lang_1afefbe2",
      "definition": "A representation that generalizes OBDDs by replacing binary decision nodes with \"primes\" and \"subs\", which are subcircuits also represented as SDDs. At each decision node, there is a set of (mutually exclusive and exhaustive) \"primes\", each with a corresponding \"sub\". Evaluating a decision node entails checking which prime is satisfied by the input variables, then evaluating that prime's sub. The SDD respects a vtree $T$ in the same way as an SDNNF \\citet{Darwiche_2011}.",
      "definitionRefs": []
    },
    {
      "fullName": "Sentential Decision Diagram (wrt a fixed variable tree)",
      "name": "SDD$_T$",
      "properties": {
        "queries": {},
        "transformations": {}
      },
      "tags": [],
      "id": "lang_9c84a267",
      "definition": "The set of all SDD formulas respecting a fixed variable tree (vtree) $T$. \\citet{Darwiche_2011}.",
      "definitionRefs": []
    },
    {
      "fullName": "Structured Decomposable Negation Normal Form",
      "name": "SDNNF",
      "properties": {
        "queries": {
          "CE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001a"
            ],
            "derived": true,
            "description": "SDNNF compiles to DNNF in polynomial time, and DNNF supports Clausal Entailment in polynomial time \\citet{Darwiche_2001a}. Therefore SDNNF supports Clausal Entailment in polynomial time."
          },
          "CO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since SDNNF supports Clausal Entailment, it also supports Consistency \\citet{Darwiche_2002}."
          },
          "ME": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "SDNNF compiles to DNNF in polynomial time, and DNNF supports Model Enumeration in polynomial time \\citet{Darwiche_2002}. Therefore SDNNF supports Model Enumeration in polynomial time."
          },
          "SE": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Sentential Entailment implies Equivalence \\citet{Darwiche_2002}, and since Equivalence is unsupported by SDNNF \\citet{Darwiche_2002}, then Sentential Entailment is unsupported by SDNNF as well.",
            "caveat": "P = NP"
          },
          "VA": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Validity is unsupported by DNF \\citet{Darwiche_2002}, and DNF compiles to SDNNF in polynomial time. If SDNNF supported Validity in polynomial time, then DNF could too by compiling first. Therefore Validity is unsupported by SDNNF.",
            "caveat": "P = NP"
          },
          "CT": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Model Counting is unsupported by IP \\citet{Darwiche_2002}, and IP compiles to SDNNF in polynomial time. If SDNNF supported Model Counting in polynomial time, then IP could too by compiling first. Therefore Model Counting is unsupported by SDNNF.",
            "caveat": "the polynomial hierarchy collapses"
          },
          "EQ": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Equivalence implies Validity \\citet{Darwiche_2002}, and since Validity is unsupported by SDNNF \\citet{Darwiche_2002}, then Equivalence is unsupported by SDNNF as well.",
            "caveat": "P = NP"
          },
          "IM": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Implicant implies Validity \\citet{Darwiche_2002}, and since Validity is unsupported by SDNNF \\citet{Darwiche_2002}, then Implicant is unsupported by SDNNF as well.",
            "caveat": "P = NP"
          }
        },
        "transformations": {
          "NOT_C": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since Negation ∧ Consistency implies Validity \\citet{Darwiche_2002}, and since Validity is unsupported by SDNNF \\citet{Darwiche_2002}, and since Consistency is supported in polynomial time, then Negation is unsupported by SDNNF as well.",
            "caveat": "P = NP"
          }
        }
      },
      "tags": [],
      "id": "lang_b13b0d78",
      "definition": "A DNNF that respects a vtree $T$, in the sense that the decomposability of variables across AND nodes is strictly governed by the hierarchical structure of $T$. This guarantees that variable partitions occur systematically \\citet{Pipatsrisawat_2008}.",
      "definitionRefs": []
    },
    {
      "fullName": "Structured Decomposable Negation Normal Form (wrt a fixed variable tree)",
      "name": "SDNNF$_T$",
      "properties": {
        "queries": {},
        "transformations": {}
      },
      "tags": [],
      "id": "lang_3c803ba1",
      "definition": "The set of all SDNNF formulas respecting a fixed vtree $T$. \\citet{Pipatsrisawat_2008}.",
      "definitionRefs": []
    },
    {
      "fullName": "Unambiguous Free Binary Decision Diagram",
      "name": "uFBDD",
      "properties": {
        "queries": {
          "CE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001a"
            ],
            "derived": true,
            "description": "uFBDD compiles to DNNF in polynomial time, and DNNF supports Clausal Entailment in polynomial time \\citet{Darwiche_2001a}. Therefore uFBDD supports Clausal Entailment in polynomial time."
          },
          "CT": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001b"
            ],
            "derived": true,
            "description": "uFBDD compiles to d-DNNF in polynomial time, and d-DNNF supports Model Counting in polynomial time \\citet{Darwiche_2001b}. Therefore uFBDD supports Model Counting in polynomial time."
          },
          "CO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since uFBDD supports Model Counting, it also supports Consistency \\citet{Darwiche_2002}."
          },
          "VA": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since uFBDD supports Model Counting, it also supports Validity \\citet{Darwiche_2002}."
          },
          "IM": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "uFBDD compiles to d-DNNF in polynomial time, and d-DNNF supports Implicant in polynomial time \\citet{Darwiche_2002}. Therefore uFBDD supports Implicant in polynomial time."
          },
          "ME": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "uFBDD compiles to d-DNNF in polynomial time, and d-DNNF supports Model Enumeration in polynomial time \\citet{Darwiche_2002}. Therefore uFBDD supports Model Enumeration in polynomial time."
          },
          "SE": {
            "complexity": "unknown-to-us",
            "refs": []
          }
        },
        "transformations": {}
      },
      "tags": [],
      "id": "lang_4e62a038",
      "definition": "A restricted form of a nondeterministic FBDD where every satisfying assignment has exactly one valid accepting path. This \"unambiguity\" preserves the ability to perform efficient model counting while allowing for greater compression \\citet{Wegener_2000}.",
      "definitionRefs": []
    },
    {
      "fullName": "Unambiguous Ordered Binary Decision Diagram",
      "name": "uOBDD",
      "properties": {
        "queries": {
          "CE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001a"
            ],
            "derived": true,
            "description": "uOBDD compiles to DNNF in polynomial time, and DNNF supports Clausal Entailment in polynomial time \\citet{Darwiche_2001a}. Therefore uOBDD supports Clausal Entailment in polynomial time."
          },
          "CT": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001b"
            ],
            "derived": true,
            "description": "uOBDD compiles to d-DNNF in polynomial time, and d-DNNF supports Model Counting in polynomial time \\citet{Darwiche_2001b}. Therefore uOBDD supports Model Counting in polynomial time."
          },
          "CO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since uOBDD supports Model Counting, it also supports Consistency \\citet{Darwiche_2002}."
          },
          "VA": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since uOBDD supports Model Counting, it also supports Validity \\citet{Darwiche_2002}."
          },
          "IM": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "uOBDD compiles to d-DNNF in polynomial time, and d-DNNF supports Implicant in polynomial time \\citet{Darwiche_2002}. Therefore uOBDD supports Implicant in polynomial time."
          },
          "ME": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "uOBDD compiles to d-DNNF in polynomial time, and d-DNNF supports Model Enumeration in polynomial time \\citet{Darwiche_2002}. Therefore uOBDD supports Model Enumeration in polynomial time."
          },
          "SE": {
            "complexity": "unknown-to-us",
            "refs": []
          }
        },
        "transformations": {}
      },
      "tags": [],
      "id": "lang_c2df8c2b",
      "definition": "A nondeterministic OBDD restricted to unambiguous choices, maintaining efficient counting capabilities while strictly following a global variable order. It provides a middle ground between the strictness of OBDDs and the compression of nondeterminism \\citet{Wegener_2000}.",
      "definitionRefs": []
    },
    {
      "name": "OBDD",
      "fullName": "Ordered Binary Decision Diagram",
      "properties": {
        "queries": {
          "CT": {
            "complexity": "poly",
            "refs": [
              "Bryant_1986",
              "Darwiche_2002"
            ],
            "description": "Any query concerning $OBDD$ is equivalent to the corresponding query concerning $OBDD_<$ when only one DAG is involved. Since $OBDD_<$ satisfies CO, VA and CT, so does $OBDD$ (\\citet{Darwiche_2002}, Proposition 4.1, Table 20)."
          },
          "EQ": {
            "complexity": "poly",
            "refs": [
              "Meinel_Theobald_1998",
              "Darwiche_2002"
            ],
            "description": "$OBDD$ satisfies EQ (Theorem 8.11, Meinel \\& Theobald 1998). Any equivalence query on a single $OBDD$ reduces to the corresponding query on $OBDD_<$, and $OBDD_<$ supports EQ (\\citet{Darwiche_2002}, Proposition 4.1, Table 20)."
          },
          "SE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "OBDD compiles to SDD in polynomial time, and SDD supports Sentential Entailment in polynomial time \\citet{Darwiche_2002}. Therefore OBDD supports Sentential Entailment in polynomial time."
          },
          "CO": {
            "complexity": "poly",
            "refs": [
              "Gergov_1994"
            ],
            "derived": true,
            "description": "OBDD compiles to FBDD in polynomial time, and FBDD supports Consistency in polynomial time \\citet{Gergov_1994}. Therefore OBDD supports Consistency in polynomial time."
          },
          "VA": {
            "complexity": "poly",
            "refs": [
              "Gergov_1994"
            ],
            "derived": true,
            "description": "OBDD compiles to FBDD in polynomial time, and FBDD supports Validity in polynomial time \\citet{Gergov_1994}. Therefore OBDD supports Validity in polynomial time."
          },
          "CE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001a"
            ],
            "derived": true,
            "description": "OBDD compiles to DNNF in polynomial time, and DNNF supports Clausal Entailment in polynomial time \\citet{Darwiche_2001a}. Therefore OBDD supports Clausal Entailment in polynomial time."
          },
          "ME": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since OBDD supports Consistency, Conditioning, it also supports Model Enumeration \\citet{Darwiche_2002}."
          },
          "IM": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since OBDD supports Validity, Conditioning, it also supports Implicant \\citet{Darwiche_2002}."
          }
        },
        "transformations": {
          "NOT_C": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "Negation of an OBDD is achieved by switching the labels of the 0-sink and 1-sink. The ordered variable property is preserved since the single ordering is not affected (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "AND_BC": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "caveat": "P = NP",
            "description": "Checking consistency of two OBDDs (which may possess different underlying orderings) is NP-complete (Lemma 8.14, \\citet{Meinel_Theobald_1998}). Since OBDD satisfies CO, if OBDD satisfied $\\land$BC consistency could be tested in polytime, implying P = NP (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "AND_C": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "It is straightforward to convert a clause into an equivalent OBDD formula in polynomial time. Since specific CNF formulas cannot be turned into equivalent OBDD formulas in polynomial space (CNF $\\not\\leq$ OBDD), OBDD does not satisfy $\\land$C (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "OR_BC": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "caveat": "P = NP",
            "description": "Since OBDD satisfies $\\neg$C, $\\alpha_1 \\land \\alpha_2$ is inconsistent iff $\\neg\\alpha_1 \\lor \\neg\\alpha_2$ is valid. If OBDD satisfied $\\lor$BC, the disjunction could be computed in polytime and validity tested (OBDD satisfies VA). Since consistency of two OBDDs with different orderings is NP-hard, P = NP would follow (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "OR_C": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "It is straightforward to convert any term into an equivalent OBDD formula in polynomial time. Since specific DNF formulas cannot be turned into equivalent OBDD formulas in polynomial space (DNF $\\not\\leq$ OBDD), OBDD does not satisfy $\\lor$C (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "CD": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "Since OBDD $\\subseteq$ FBDD and FBDD satisfies CD (the restrict operation), OBDD also satisfies CD. The variable ordering is preserved under conditioning (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "FO": {
            "complexity": "no-poly-unknown-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "If OBDD satisfies FO, then every DNF can be compiled to an equivalent OBDD of polynomial size. Since DNF $\\not\\leq$ OBDD, this is impossible (\\citet{Darwiche_2002}, Proposition 5.1)."
          },
          "SFO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "description": "Since only one OBDD sentence is considered in the transformation, and OBDD$_<$ satisfies SFO, OBDD also satisfies SFO (\\citet{Darwiche_2002}, Proposition 5.1)."
          }
        }
      },
      "tags": [],
      "id": "lang_b9d72a7c",
      "definition": "A Binary Decision Diagram where all variable decisions must follow a strict, uniform linear order $<$ across every path in the graph. They are strongly canonical and support powerful polytime Boolean operations, making them ubiquitous in formal hardware verification \\citet{Bryant_1986}.",
      "definitionRefs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "lang_981b62f0",
      "name": "dec-DNNF",
      "fullName": "Decision Decomposable Negation Normal Form",
      "properties": {
        "queries": {
          "CE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001a"
            ],
            "derived": true,
            "description": "dec-DNNF compiles to DNNF in polynomial time, and DNNF supports Clausal Entailment in polynomial time \\citet{Darwiche_2001a}. Therefore dec-DNNF supports Clausal Entailment in polynomial time."
          },
          "CT": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001b"
            ],
            "derived": true,
            "description": "dec-DNNF compiles to d-DNNF in polynomial time, and d-DNNF supports Model Counting in polynomial time \\citet{Darwiche_2001b}. Therefore dec-DNNF supports Model Counting in polynomial time."
          },
          "CO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since dec-DNNF supports Model Counting, it also supports Consistency \\citet{Darwiche_2002}."
          },
          "VA": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since dec-DNNF supports Model Counting, it also supports Validity \\citet{Darwiche_2002}."
          },
          "IM": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "dec-DNNF compiles to d-DNNF in polynomial time, and d-DNNF supports Implicant in polynomial time \\citet{Darwiche_2002}. Therefore dec-DNNF supports Implicant in polynomial time."
          },
          "ME": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "dec-DNNF compiles to d-DNNF in polynomial time, and d-DNNF supports Model Enumeration in polynomial time \\citet{Darwiche_2002}. Therefore dec-DNNF supports Model Enumeration in polynomial time."
          },
          "SE": {
            "complexity": "unknown-to-us",
            "refs": []
          }
        },
        "transformations": {}
      },
      "tags": [],
      "definition": "A subset of DNNF where standard logical OR nodes are entirely replaced by decision nodes, similar to those found in BDDs. Because it relies explicitly on variable conditioning, it serves as the natural compilation trace of exhaustive DPLL-based SAT solvers \\citet{Oztok_2014}.",
      "definitionRefs": []
    },
    {
      "id": "lang_0f27d539",
      "name": "dec-SDNNF",
      "fullName": "Structured Decision Decomposable Negation Normal Form",
      "properties": {
        "queries": {
          "CE": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001a"
            ],
            "derived": true,
            "description": "dec-SDNNF compiles to DNNF in polynomial time, and DNNF supports Clausal Entailment in polynomial time \\citet{Darwiche_2001a}. Therefore dec-SDNNF supports Clausal Entailment in polynomial time."
          },
          "CT": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2001b"
            ],
            "derived": true,
            "description": "dec-SDNNF compiles to d-DNNF in polynomial time, and d-DNNF supports Model Counting in polynomial time \\citet{Darwiche_2001b}. Therefore dec-SDNNF supports Model Counting in polynomial time."
          },
          "CO": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since dec-SDNNF supports Model Counting, it also supports Consistency \\citet{Darwiche_2002}."
          },
          "VA": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "Since dec-SDNNF supports Model Counting, it also supports Validity \\citet{Darwiche_2002}."
          },
          "IM": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "dec-SDNNF compiles to d-DNNF in polynomial time, and d-DNNF supports Implicant in polynomial time \\citet{Darwiche_2002}. Therefore dec-SDNNF supports Implicant in polynomial time."
          },
          "ME": {
            "complexity": "poly",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "dec-SDNNF compiles to d-DNNF in polynomial time, and d-DNNF supports Model Enumeration in polynomial time \\citet{Darwiche_2002}. Therefore dec-SDNNF supports Model Enumeration in polynomial time."
          },
          "EQ": {
            "complexity": "unknown-poly-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "dec-SDNNF compiles to SDD in quasi-polynomial time, and SDD supports Equivalence in quasi-polynomial time \\citet{Darwiche_2002}. Therefore dec-SDNNF supports Equivalence in at most quasi-polynomial time."
          },
          "SE": {
            "complexity": "unknown-poly-quasi",
            "refs": [
              "Darwiche_2002"
            ],
            "derived": true,
            "description": "dec-SDNNF compiles to SDD in quasi-polynomial time, and SDD supports Sentential Entailment in quasi-polynomial time \\citet{Darwiche_2002}. Therefore dec-SDNNF supports Sentential Entailment in at most quasi-polynomial time."
          }
        },
        "transformations": {}
      },
      "tags": [],
      "definition": "A decision DNNF whose underlying variable decisions strictly follow a hierarchical variable tree (vtree). This tree-driven structure standardizes the compilation trace and bridges the gap to sentential decision diagrams \\citet{Oztok_2014}.",
      "definitionRefs": []
    },
    {
      "id": "lang_4ae03bc8",
      "name": "dec-SDNNF$_<$",
      "fullName": "Structured Decision Decomposable Negation Normal Form (wrt a fixed variable tree)",
      "properties": {
        "queries": {},
        "transformations": {}
      },
      "tags": [],
      "definition": "The set of all dec-SDNNF$_T$ formulas that follow a fixed vtree $T$. \\citet{Oztok_2014}.",
      "definitionRefs": []
    },
    {
      "id": "lang_82fa749e",
      "name": "cSDD$_T$",
      "fullName": "Canonical/Compressed Sentential Decision Diagram (wrt a fixed variable tree)",
      "properties": {
        "queries": {},
        "transformations": {}
      },
      "tags": [],
      "definition": "The set of all cSDD formulas that respect a predefined variable tree (vtree) $T$. \\citet{Darwiche_2011}.",
      "definitionRefs": []
    }
  ],
  "references": [
    {
      "id": "Bryant_1986",
      "bibtex": "@article{Bryant_1986,\n  title={Graph-based algorithms for boolean function manipulation},\n  author={Bryant, Randal E},\n  journal={Computers, IEEE Transactions on},\n  volume={100},\n  number={8},\n  pages={677--691},\n  year={1986},\n  publisher={IEEE}\n}",
      "title": "R. E. Bryant, \"Graph-based algorithms for boolean function manipulation,\" Computers, IEEE Transactions on, vol. 100, pp. 677–691, 1986.",
      "href": "#"
    },
    {
      "id": "Bryant_1992",
      "bibtex": "@article{Bryant_1992,\n  author={Bryant, Randal E.},\n  title={Symbolic Boolean manipulation with ordered binary-decision diagrams},\n  journal={ACM Computing Surveys},\n  volume={24},\n  number={3},\n  pages={293--318},\n  year={1992},\n  publisher={ACM},\n  doi={10.1145/136035.136043}\n}",
      "title": "R. E. Bryant, \"Symbolic Boolean manipulation with ordered binary-decision diagrams,\" ACM Computing Surveys, vol. 24, no. 3, pp. 293–318, 1992.",
      "href": "https://doi.org/10.1145/136035.136043"
    },
    {
      "id": "Darwiche_2002",
      "bibtex": "@article{Darwiche_2002,\n   title={A Knowledge Compilation Map},\n   volume={17},\n   ISSN={1076-9757},\n   url={http://dx.doi.org/10.1613/jair.989},\n   DOI={10.1613/jair.989},\n   journal={Journal of Artificial Intelligence Research},\n   publisher={AI Access Foundation},\n   author={Darwiche, A. and Marquis, P.},\n   year={2002},\n   month=sep, pages={229–264} }",
      "title": "A. Darwiche and P. Marquis, \"A Knowledge Compilation Map,\" Journal of Artificial Intelligence Research, vol. 17, pp. 229–264, 2002.",
      "href": "http://dx.doi.org/10.1613/jair.989"
    },
    {
      "id": "Gogic_1995",
      "bibtex": "@article{Gogic_1995,\n   title={The Comparative Study of Knowledge Compilation},\n   journal={Journal of Artificial Intelligence Research},\n   volume={2},\n   pages={147--182},\n   url={https://doi.org/10.1613/jair.110},\n   DOI={10.1613/jair.110},\n   author={Gogic, Goran and Kautz, Henry and Papadimitriou, Christos H. and Selman, Bart},\n   year={1995},\n   publisher={AI Access Foundation}\n }",
      "title": "G. Gogic, H. Kautz, C. H. Papadimitriou, and B. Selman, \"The Comparative Study of Knowledge Compilation,\" Journal of Artificial Intelligence Research, vol. 2, pp. 147–182, 1995.",
      "href": "https://doi.org/10.1613/jair.110"
    },
    {
      "id": "Gergov_1994",
      "bibtex": "@ARTICLE{Gergov_1994,\n  author={Gergov, J. and Meinel, C.},\n  journal={IEEE Transactions on Computers}, \n  title={Efficient Boolean manipulation with OBDD's can be extended to FBDD's}, \n  year={1994},\n  volume={43},\n  number={10},\n  pages={1197-1209},\n  keywords={Boolean functions;Circuit testing;Data structures;Performance evaluation;Circuit synthesis;Input variables;Design optimization;Logic;Hardware design languages},\n  doi={10.1109/12.324545}}",
      "title": "J. Gergov and C. Meinel, \"Efficient Boolean manipulation with OBDD's can be extended to FBDD's,\" IEEE Transactions on Computers, vol. 43, pp. 1197-1209, 1994.",
      "href": "https://doi.org/10.1109/12.324545"
    },
    {
      "id": "Darwiche_2000",
      "bibtex": "@misc{Darwiche_2000,\n      title={On the tractable counting of theory models and its application to belief revision and truth maintenance}, \n      author={Adnan Darwiche},\n      year={2000},\n      eprint={cs/0003044},\n      archivePrefix={arXiv},\n      primaryClass={cs.AI},\n      url={https://arxiv.org/abs/cs/0003044}, \n}",
      "title": "Adnan Darwiche, \"On the tractable counting of theory models and its application to belief revision and truth maintenance,\" 2000.",
      "href": "https://arxiv.org/abs/cs/0003044"
    },
    {
      "id": "Darwiche_2001a",
      "bibtex": "@inproceedings{Darwiche_2001a,\n  author={Darwiche, Adnan},\n  title={Decomposable Negation Normal Form},\n  booktitle={Journal of the ACM},\n  volume={48},\n  number={4},\n  pages={608--647},\n  year={2001},\n  publisher={ACM}\n}",
      "title": "Adnan Darwiche, \"Decomposable Negation Normal Form,\" Journal of the ACM, vol. 48, no. 4, pp. 608–647, 2001.",
      "href": "https://doi.org/10.1145/502090.502091"
    },
    {
      "id": "Selman_1996",
      "bibtex": "@article{Selman_1996,\nauthor = {Selman, Bart and Kautz, Henry},\ntitle = {Knowledge compilation and theory approximation},\nyear = {1996},\nissue_date = {March 1996},\npublisher = {Association for Computing Machinery},\naddress = {New York, NY, USA},\nvolume = {43},\nnumber = {2},\nissn = {0004-5411},\nurl = {https://doi.org/10.1145/226643.226644},\ndoi = {10.1145/226643.226644},\nabstract = {Computational efficiency is a central concern in the design of knowledge representation systems. In order to obtain efficient systems, it has been suggested that one should limit the form of the statements in the knowledge base or use an incomplete inference mechanism. The former approach is often too restrictive for practical applications, whereas the latter leads to uncertainty about exactly what can and cannot be inferred from the knowledge base. We present a third alternative, in which knowledge given in a general representation language is translated (compiled) into a tractable form—allowing for efficient subsequent query answering.We show how propositional logical theories can be compiled into Horn theories that approximate the original information. The approximations bound the original theory from below and above in terms of logical strength. The procedures are extended to other tractable languages (for example, binary clauses) and to the first-order case. Finally, we demonstrate the generality of our approach by compiling concept descriptions in a general frame-based language into a tractable form.},\njournal = {J. ACM},\nmonth = mar,\npages = {193–224},\nnumpages = {32},\nkeywords = {Horn clauses, efficient reasoning methods, knowledge compilation, knowledge-base optimization, query evaluation, theory approximation}\n}",
      "title": "B. Selman and H. Kautz, \"Knowledge compilation and theory approximation,\" J. ACM, vol. 43, pp. 193–224, 1996.",
      "href": "https://doi.org/10.1145/226643.226644"
    },
    {
      "id": "Cadoli_1997",
      "bibtex": "@article{Cadoli_1997,\n  title={A survey on knowledge compilation},\n  author={Marco Cadoli and Francesco M. Donini},\n  journal={AI Communications},\n  year={1997},\n  volume={10},\n  pages={137 - 150},\n  url={https://api.semanticscholar.org/CorpusID:16746005}\n}",
      "title": "Marco Cadoli and Francesco M. Donini, \"A survey on knowledge compilation,\" AI Communications, vol. 10, pp. 137 - 150, 1997.",
      "href": "https://api.semanticscholar.org/CorpusID:16746005"
    },
    {
      "id": "Wegener_1987",
      "bibtex": "@book{Wegener_1987,\n\tauthor = {Ingo Wegener},\n\teditor = {},\n\tpublisher = {Wiley},\n\ttitle = {The Complexity of Boolean Functions},\n\tyear = {1987}\n}",
      "title": "Ingo Wegener, \"The Complexity of Boolean Functions,\" 1987.",
      "href": "#"
    },
    {
      "id": "Amarilli_2018",
      "bibtex": "@article{Amarilli_2018,\n  author       = {Antoine Amarilli and\n                  Florent Capelli and\n                  Mika{\\\"{e}}l Monet and\n                  Pierre Senellart},\n  title        = {Connecting Knowledge Compilation Classes and Width Parameters},\n  journal      = {CoRR},\n  volume       = {abs/1811.02944},\n  year         = {2018},\n  url          = {http://arxiv.org/abs/1811.02944},\n  eprinttype    = {arXiv},\n  eprint       = {1811.02944},\n  timestamp    = {Thu, 22 Nov 2018 17:58:30 +0100},\n  biburl       = {https://dblp.org/rec/journals/corr/abs-1811-02944.bib},\n  bibsource    = {dblp computer science bibliography, https://dblp.org}\n}",
      "title": "Antoine Amarilli, Florent Capelli, Mikaël Monet, and Pierre Senellart, \"Connecting Knowledge Compilation Classes and Width Parameters,\" CoRR, vol. abs/1811.02944, 2018.",
      "href": "http://arxiv.org/abs/1811.02944"
    },
    {
      "id": "Bova_2016",
      "bibtex": "@inproceedings{Bova_2016,\n  TITLE = {{Knowledge Compilation Meets Communication Complexity}},\n  AUTHOR = {Bova, Simone and Capelli, Florent and Mengel, Stefan and Slivovsky, Friedrich},\n  URL = {https://univ-artois.hal.science/hal-03301001},\n  BOOKTITLE = {{25th International Joint Conference on Artificial Intelligence (IJCAI'16)}},\n  ADDRESS = {New York, NY, USA, Unknown Region},\n  EDITOR = {Subbarao Kambhampati},\n  PUBLISHER = {{IJCAI/AAAI Press}},\n  PAGES = {1008--1014},\n  YEAR = {2016},\n  HAL_ID = {hal-03301001},\n  HAL_VERSION = {v1},\n}",
      "title": "S. Bova, F. Capelli, S. Mengel, and F. Slivovsky, \"Knowledge Compilation Meets Communication Complexity,\" 25th International Joint Conference on Artificial Intelligence (IJCAI'16), pp. 1008–1014, 2016.",
      "href": "https://univ-artois.hal.science/hal-03301001"
    },
    {
      "id": "Beame_2013",
      "bibtex": "@misc{Beame_2013,\n      title={Model Counting of Query Expressions: Limitations of Propositional Methods}, \n      author={Paul Beame and Jerry Li and Sudeepa Roy and Dan Suciu},\n      year={2013},\n      eprint={1312.4125},\n      archivePrefix={arXiv},\n      primaryClass={cs.DB},\n      url={https://arxiv.org/abs/1312.4125}, \n}",
      "title": "Paul Beame, Jerry Li, Sudeepa Roy, and Dan Suciu, \"Model Counting of Query Expressions: Limitations of Propositional Methods,\" 2013.",
      "href": "https://arxiv.org/abs/1312.4125"
    },
    {
      "id": "Bollig_2018",
      "bibtex": "@misc{Bollig_2018,\n      title={On the Relative Succinctness of Sentential Decision Diagrams}, \n      author={Beate Bollig and Matthias Buttkus},\n      year={2018},\n      eprint={1802.04544},\n      archivePrefix={arXiv},\n      primaryClass={cs.CC},\n      url={https://arxiv.org/abs/1802.04544}, \n}",
      "title": "Beate Bollig and Matthias Buttkus, \"On the Relative Succinctness of Sentential Decision Diagrams,\" 2018.",
      "href": "https://arxiv.org/abs/1802.04544"
    },
    {
      "id": "Bodlaender_1993",
      "bibtex": "@inproceedings{Bodlaender_1993,\ntitle = \"A Linear Time Algorithm for Finding Tree-decompositions of Small Treewidth\",\nabstract = \"In this paper, we give, for constant k, a linear time algorithm, that given a graph G = (V, E), determines whether the treewidth of G is at most k, and if so, finds a treedecomposition of G with treewidth at most k. A consequence is that every minor-closed class of graphs that does not contain all planar graphs has a linear time recognition algorithm. \",\nkeywords = \"graph algorithms, graph minors, partial k-trees, pathwidth, treewidth\",\nauthor = \"Bodlaender, \\{Hans L.\\}\",\nyear = \"1993\",\ndoi = \"10.1145/167088.167161\",\nlanguage = \"English\",\nseries = \"STOC '93\",\npublisher = \"Association for Computing Machinery\",\npages = \"226--234\",\nbooktitle = \"Proceedings of the Twenty-fifth Annual ACM Symposium on Theory of Computing\",\n}",
      "title": "\\. L. Bodlaender, \"A Linear Time Algorithm for Finding Tree-decompositions of Small Treewidth,\" Proceedings of the Twenty-fifth Annual ACM Symposium on Theory of Computing, pp. 226–234, 1993.",
      "href": "https://doi.org/10.1145/167088.167161"
    },
    {
      "id": "Wegener_2000",
      "bibtex": "@book{Wegener_2000,\n  title={Branching Programs and Binary Decision Diagrams: Theory and Applications},\n  author={Wegener, I.},\n  isbn={9780898719789},\n  lccn={00035749},\n  series={Discrete Mathematics and Applications},\n  url={https://books.google.com/books?id=xqqJj42ZoXcC},\n  year={2000},\n  publisher={Society for Industrial and Applied Mathematics}\n}",
      "title": "I. Wegener, \"Branching Programs and Binary Decision Diagrams: Theory and Applications,\" 2000.",
      "href": "https://books.google.com/books?id=xqqJj42ZoXcC"
    },
    {
      "id": "Beame_2015",
      "bibtex": "@misc{Beame_2015,\n      title={New Limits for Knowledge Compilation and Applications to Exact Model Counting}, \n      author={Paul Beame and Vincent Liew},\n      year={2015},\n      eprint={1506.02639},\n      archivePrefix={arXiv},\n      primaryClass={cs.AI},\n      url={https://arxiv.org/abs/1506.02639}, \n}",
      "title": "Paul Beame and Vincent Liew, \"New Limits for Knowledge Compilation and Applications to Exact Model Counting,\" 2015.",
      "href": "https://arxiv.org/abs/1506.02639"
    },
    {
      "id": "Pipatsrisawat_2010",
      "bibtex": "@phdthesis{Pipatsrisawat_2010,\n  author       = {Thammanit Pipatsrisawat},\n  title        = {Reasoning with Propositional Knowledge: Frameworks for Boolean Satisfiability and Knowledge Compilation},\n  school       = {University of California, Los Angeles},\n  year         = {2010},\n  address      = {Los Angeles, CA, USA},\n  note         = {PhD thesis},\n  url          = {https://escholarship.org/content/qt2vz8n06q/qt2vz8n06q.pdf}\n}",
      "title": "Thammanit Pipatsrisawat, \"Reasoning with Propositional Knowledge: Frameworks for Boolean Satisfiability and Knowledge Compilation,\" 2010.",
      "href": "https://escholarship.org/content/qt2vz8n06q/qt2vz8n06q.pdf"
    },
    {
      "id": "Capelli_2016",
      "bibtex": "@phdthesis{Capelli_2016,\n  author       = {Florent Capelli},\n  title        = {Structural Restrictions of CNF-formulas: Applications to Model Counting and Knowledge Compilation},\n  school       = {Universit{\\'e} Paris-Diderot (Paris 7), Sorbonne Paris Cit{\\'e}},\n  year         = {2016},\n  address      = {Paris, France},\n  note         = {PhD thesis},\n  url          = {https://florent.capelli.me/publi/these_capelli.pdf}\n}",
      "title": "Florent Capelli, \"Structural Restrictions of CNF-formulas: Applications to Model Counting and Knowledge Compilation,\" 2016.",
      "href": "https://florent.capelli.me/publi/these_capelli.pdf"
    },
    {
      "id": "Darwiche_2011",
      "bibtex": "@inproceedings{Darwiche_2011,\nauthor = {Darwiche, Adnan},\ntitle = {SDD: a new canonical representation of propositional knowledge bases},\nyear = {2011},\nisbn = {9781577355144},\npublisher = {AAAI Press},\nabstract = {We identify a new representation of propositional knowledge bases, the Sentential Decision Diagram (SDD), which is interesting for a number of reasons. First, it is canonical in the presence of additional properties that resemble reduction rules of OBDDs. Second, SDDs can be combined using any Boolean operator in polytime. Third, CNFs with n variables and treewidth w have canonical SDDs of size O(n2w), which is tighter than the bound on OBDDs based on pathwidth. Finally, every OBDD is an SDD. Hence, working with the latter does not preclude the former.},\nbooktitle = {Proceedings of the Twenty-Second International Joint Conference on Artificial Intelligence - Volume Two},\npages = {819–826},\nnumpages = {8},\nlocation = {Barcelona, Catalonia, Spain},\nseries = {IJCAI'11}\n}",
      "title": "A. Darwiche, \"SDD: a new canonical representation of propositional knowledge bases,\" Proceedings of the Twenty-Second International Joint Conference on Artificial Intelligence - Volume Two, pp. 819–826, 2011.",
      "href": "#"
    },
    {
      "id": "Van den Broeck_2015",
      "bibtex": "@article{Van den Broeck_Darwiche_2015, title={On the Role of Canonicity in Knowledge Compilation}, volume={29}, url={https://ojs.aaai.org/index.php/AAAI/article/view/9423}, DOI={10.1609/aaai.v29i1.9423}, abstractNote={ &lt;p&gt; Knowledge compilation is a powerful reasoning paradigm with many applications across AI and computer science more broadly. We consider the problem of bottom-up compilation of knowledge bases, which is usually predicated on the existence of a polytime function for combining compilations using Boolean operators (usually called an Apply function). While such a polytime Apply function is known to exist for certain languages (e.g., OBDDs) and not exist for others (e.g., DNNFs), its existence for certain languages remains unknown. Among the latter is the recently introduced language of Sentential Decision Diagrams (SDDs): while a polytime Apply function exists for SDDs, it was unknown whether such a function exists for the important subset of compressed SDDs which are canonical. We resolve this open question in this paper and consider some of its theoretical and practical implications. Some of the findings we report question the common wisdom on the relationship between bottom-up compilation, language canonicity and the complexity of the Apply function. &lt;/p&gt; }, number={1}, journal={Proceedings of the AAAI Conference on Artificial Intelligence}, author={Van den Broeck, Guy and Darwiche, Adnan}, year={2015}, month={Feb.} }",
      "title": "G. Van den Broeck and A. Darwiche, \"On the Role of Canonicity in Knowledge Compilation,\" Proceedings of the AAAI Conference on Artificial Intelligence, vol. 29, 2015.",
      "href": "https://ojs.aaai.org/index.php/AAAI/article/view/9423"
    },
    {
      "id": "Bova_2016_a",
      "bibtex": "@article{Bova_2016_a, title={SDDs Are Exponentially More Succinct than OBDDs}, volume={30}, url={https://ojs.aaai.org/index.php/AAAI/article/view/10107}, DOI={10.1609/aaai.v30i1.10107}, abstractNote={ &lt;p&gt; Introduced by Darwiche (2011), sentential decision diagrams (SDDs) are essentially as tractable as ordered binary decision diagrams (OBDDs), but tend to be more succinct in practice. This makes SDDs a prominent representation language, with many applications in artificial intelligence and knowledge compilation. We prove that SDDs are more succinct than OBDDs also in theory, by constructing a family of boolean functions where each member has polynomial SDD size but exponential OBDD size. This exponential separation improves a quasipolynomial separation recently established by Razgon (2014), and settles an open problem in knowledge compilation (Darwiche, 2011). &lt;/p&gt; }, number={1}, journal={Proceedings of the AAAI Conference on Artificial Intelligence}, author={Bova, Simone}, year={2016}, month={Feb.} }",
      "title": "S. Bova, \"SDDs Are Exponentially More Succinct than OBDDs,\" Proceedings of the AAAI Conference on Artificial Intelligence, vol. 30, 2016.",
      "href": "https://ojs.aaai.org/index.php/AAAI/article/view/10107"
    },
    {
      "id": "Sauerhoff_2003",
      "bibtex": "@article{Sauerhoff_2003,\ntitle = {Approximation of boolean functions by combinatorial rectangles},\njournal = {Theoretical Computer Science},\nvolume = {301},\nnumber = {1},\npages = {45-78},\nyear = {2003},\nissn = {0304-3975},\ndoi = {https://doi.org/10.1016/S0304-3975(02)00568-6},\nurl = {https://www.sciencedirect.com/science/article/pii/S0304397502005686},\nauthor = {Martin Sauerhoff},\nkeywords = {Branching programs, Communication complexity, Lower bounds, Approximation, Nondeterminism, Randomness},\nabstract = {This paper deals with the number of monochromatic combinatorial rectangles required to approximate a boolean function on a constant fraction of all inputs, where each rectangle may use its own partition of the input variables. The main result of the paper is that the number of rectangles required for the approximation of boolean functions in this model is very sensitive to the allowed error. There is an explicitly defined sequence of boolean functions fn on n variables such that fn has rectangle approximations with a constant number of rectangles and one-sided error 13+o(1) or two-sided error 14+o(1), but, on the other hand, fn requires exponentially many rectangles if the error bounds are decreased by an arbitrarily small constant. As applications of this result, the following separation results for read-once branching programs are obtained. The functions from the main result require only linear size for nondeterministic read-once branching programs and randomized read-once branching programs with two-sided error 13+o(1), while randomized read-once branching programs with constant two-sided error smaller than 13 and unambiguous nondeterministic read-once branching programs require exponential size.}\n}",
      "title": "Martin Sauerhoff, \"Approximation of boolean functions by combinatorial rectangles,\" Theoretical Computer Science, vol. 301, pp. 45-78, 2003.",
      "href": "https://www.sciencedirect.com/science/article/pii/S0304397502005686"
    },
    {
      "id": "Jukna_2002",
      "bibtex": "@article{Jukna_2002, title={Triangle-Freeness is Hard to Detect}, volume={11}, DOI={10.1017/S0963548302005333}, number={6}, journal={Combinatorics, Probability and Computing}, author={Jukna, S. and Schnitger, G.}, year={2002}, pages={549–569}}",
      "title": "S. Jukna and G. Schnitger, \"Triangle-Freeness is Hard to Detect,\" Combinatorics, Probability and Computing, vol. 11, pp. 549–569, 2002.",
      "href": "https://doi.org/10.1017/S0963548302005333"
    },
    {
      "id": "Vinall-Smeeth_2024",
      "bibtex": "@misc{Vinall-Smeeth_2024,\n      title={Structured d-DNNF Is Not Closed Under Negation}, \n      author={Harry Vinall-Smeeth},\n      year={2024},\n      eprint={2402.04832},\n      archivePrefix={arXiv},\n      primaryClass={cs.AI},\n      url={https://arxiv.org/abs/2402.04832}, \n}",
      "title": "Harry Vinall-Smeeth, \"Structured d-DNNF Is Not Closed Under Negation,\" 2024.",
      "href": "https://arxiv.org/abs/2402.04832"
    },
    {
      "id": "Kaleyski_2016",
      "bibtex": "@mastersthesis{Kaleyski_2016,\n  author       = {Kaleyski, Nikolay Stoyanov},\n  title        = {Boolean methods in knowledge compilation},\n  school       = {Charles University, Faculty of Mathematics and Physics},\n  year         = {2016},\n  address      = {Prague, Czech Republic},\n  type         = {Master’s thesis},\n  keywords     = {Boolean functions, knowledge compilation, PI, MODS, prime implicants},\n  note         = {Master’s thesis, Department of Theoretical Computer Science and Mathematical Logic},\n  url          = {https://dspace.cuni.cz/bitstream/handle/20.500.11956/83080/DPTX_2014_2_11320_0_450653_0_169085.pdf?sequence=1}\n}",
      "title": "N. S. Kaleyski, \"Boolean methods in knowledge compilation,\" 2016.",
      "href": "https://dspace.cuni.cz/bitstream/handle/20.500.11956/83080/DPTX_2014_2_11320_0_450653_0_169085.pdf?sequence=1"
    },
    {
      "id": "Meinel_Theobald_1998",
      "bibtex": "@book{Meinel_Theobald_1998,\n  author = {Meinel, Christoph and Theobald, Thorsten},\n  title = {Algorithms and Data Structures in VLSI Design: OBDD - Foundations and Applications},\n  year = {1998},\n  isbn = {3540644865},\n  publisher = {Springer-Verlag},\n  address = {Berlin, Heidelberg}\n}",
      "title": "C. Meinel and T. Theobald, \"Algorithms and Data Structures in VLSI Design: OBDD - Foundations and Applications,\" Springer-Verlag, 1998.",
      "href": "https://doi.org/10.1007/978-3-642-58940-9"
    },
    {
      "id": "Darwiche_2001b",
      "bibtex": "@inproceedings{Darwiche_2001b,\n  author = {Darwiche, Adnan},\n  title = {On the Tractable Counting of Theory Models and its Application to Truth Maintenance and Belief Revision},\n  booktitle = {Journal of Applied Non-Classical Logics},\n  volume = {11},\n  number = {1--2},\n  pages = {11--34},\n  year = {2001},\n  publisher = {Taylor \\& Francis}\n}",
      "title": "A. Darwiche, \"On the Tractable Counting of Theory Models and its Application to Truth Maintenance and Belief Revision,\" Journal of Applied Non-Classical Logics, 2001.",
      "href": "https://doi.org/10.3166/jancl.11.11-34"
    },
    {
      "id": "Roth_1996",
      "bibtex": "@article{Roth_1996,\n  author = {Roth, Dan},\n  title = {On the Hardness of Approximate Reasoning},\n  journal = {Artificial Intelligence},\n  volume = {82},\n  number = {1--2},\n  pages = {273--302},\n  year = {1996},\n  publisher = {Elsevier}\n}",
      "title": "D. Roth, \"On the Hardness of Approximate Reasoning,\" Artificial Intelligence, 1996.",
      "href": "https://doi.org/10.1016/0004-3702(94)00092-1"
    },
    {
      "id": "Marquis_2000",
      "bibtex": "@article{Marquis_2000,\n  author = {Marquis, Pierre},\n  title = {Consequence Finding Algorithms},\n  journal = {Handbook of Defeasible Reasoning and Uncertainty Management Systems},\n  volume = {5},\n  pages = {41--145},\n  year = {2000},\n  publisher = {Springer}\n}",
      "title": "P. Marquis, \"Consequence Finding Algorithms,\" Handbook of Defeasible Reasoning and Uncertainty Management Systems, Springer, 2000.",
      "href": "https://doi.org/10.1007/978-94-017-1735-9_2"
    },
    {
      "id": "Lang_2000",
      "bibtex": "@article{Lang_2000,\n  author = {Lang, J\\'er\\^ome and Liberatore, Paolo and Marquis, Pierre},\n  title = {Propositional Independence: Formula-Variable Independence and Forgetting},\n  journal = {Journal of Artificial Intelligence Research},\n  volume = {18},\n  pages = {391--443},\n  year = {2003},\n  publisher = {AAAI Press}\n}",
      "title": "J. Lang, P. Liberatore, and P. Marquis, \"Propositional Independence: Formula-Variable Independence and Forgetting,\" Journal of Artificial Intelligence Research, 2003.",
      "href": "https://doi.org/10.1613/jair.1158"
    },
    {
      "id": "Chandra_1978",
      "bibtex": "@article{Chandra_1978,\n  author = {Chandra, Ashok K. and Markowsky, George},\n  title = {On the Number of Prime Implicants},\n  journal = {Discrete Mathematics},\n  volume = {24},\n  number = {1},\n  pages = {7--11},\n  year = {1978},\n  publisher = {Elsevier}\n}",
      "title": "A. K. Chandra and G. Markowsky, \"On the Number of Prime Implicants,\" Discrete Mathematics, 1978.",
      "href": "https://doi.org/10.1016/0012-365X(78)90172-1"
    },
    {
      "id": "Zhegalkin_1927",
      "bibtex": "@article{Zhegalkin_1927,\n  title={On the Technique of Calculating Propositions in Symbolic Logic},\n  author={Zhegalkin, Ivan I},\n  journal={Matematicheskii Sbornik},\n  volume={34},\n  number={1},\n  pages={9--28},\n  year={1927}\n}",
      "title": "I. I. Zhegalkin, \"On the Technique of Calculating Propositions in Symbolic Logic,\" Matematicheskii Sbornik, 1927.",
      "href": "https://mathnet.ru/eng/sm7277"
    },
    {
      "id": "Lee_1959",
      "bibtex": "@article{Lee_1959,\n  title={Representation of Switching Circuits by Binary-Decision Programs},\n  author={Lee, C. Y.},\n  journal={Bell System Technical Journal},\n  volume={38},\n  number={4},\n  pages={985--999},\n  year={1959},\n  publisher={Alcatel-Lucent}\n}",
      "title": "C. Y. Lee, \"Representation of Switching Circuits by Binary-Decision Programs,\" Bell System Technical Journal, 1959.",
      "href": "https://doi.org/10.1002/j.1538-7305.1959.tb01585.x"
    },
    {
      "id": "Boole_1847",
      "bibtex": "@book{Boole_1847,\n  title={The Mathematical Analysis of Logic: Being an Essay Towards a Calculus of Deductive Reasoning},\n  author={Boole, George},\n  year={1847},\n  publisher={Macmillan, Barclay, \\& Macmillan}\n}",
      "title": "G. Boole, \"The Mathematical Analysis of Logic: Being an Essay Towards a Calculus of Deductive Reasoning,\" Macmillan, Barclay, & Macmillan, 1847.",
      "href": "https://archive.org/details/mathematicalana00boolgoog"
    },
    {
      "id": "Quine_1952",
      "bibtex": "@article{Quine_1952,\n  title={The Problem of Simplifying Truth Functions},\n  author={Quine, Willard V.},\n  journal={The American Mathematical Monthly},\n  volume={59},\n  number={8},\n  pages={521--531},\n  year={1952},\n  publisher={Taylor \\& Francis}\n}",
      "title": "W. V. Quine, \"The Problem of Simplifying Truth Functions,\" The American Mathematical Monthly, 1952.",
      "href": "https://doi.org/10.2307/2308219"
    },
    {
      "id": "Pipatsrisawat_2008",
      "bibtex": "@inproceedings{Pipatsrisawat_2008,\n  title={New Compilation Languages Based on Structured Decomposability},\n  author={Pipatsrisawat, Knot and Darwiche, Adnan},\n  booktitle={Proceedings of the 23rd National Conference on Artificial Intelligence - Volume 1},\n  pages={517--522},\n  year={2008},\n  publisher={AAAI Press}\n}",
      "title": "K. Pipatsrisawat and A. Darwiche, \"New Compilation Languages Based on Structured Decomposability,\" Proceedings of the 23rd National Conference on Artificial Intelligence, AAAI Press, 2008.",
      "href": "https://dl.acm.org/doi/10.5555/1620163.1620241"
    },
    {
      "id": "Oztok_2014",
      "bibtex": "@inproceedings{Oztok_2014,\n  title={On Compiling CNF into Decision-DNNF},\n  author={Oztok, Umut and Darwiche, Adnan},\n  booktitle={International Conference on Principles and Practice of Constraint Programming},\n  pages={42--57},\n  year={2014},\n  publisher={Springer}\n}",
      "title": "U. Oztok and A. Darwiche, \"On Compiling CNF into Decision-DNNF,\" International Conference on Principles and Practice of Constraint Programming, Springer, 2014.",
      "href": "https://doi.org/10.1007/978-3-319-10428-7_6"
    },
    {
      "id": "Colnet_2025",
      "bibtex": "@inproceedings{Colnet_2025,\n  author={de Colnet, Alexis and Meel, Kuldeep S.},\n  title={An FPRAS for Model Counting for Non-Deterministic Read-Once Branching Programs},\n  booktitle={28th International Conference on Database Theory (ICDT 2025)},\n  year={2025},\n  doi={10.4230/LIPIcs.ICDT.2025.10},\n  note={See also arXiv:2406.16515}\n}",
      "title": "A. de Colnet and K. S. Meel, \"An FPRAS for Model Counting for Non-Deterministic Read-Once Branching Programs\", 28th International Conference on Database Theory (ICDT 2025), 2025.",
      "href": "https://doi.org/10.4230/LIPIcs.ICDT.2025.10"
    }
  ],
  "tags": {
    "decomposability": {
      "label": "Decomposability",
      "color": "#84cc16",
      "description": "Conjunctions have disjoint variable scopes"
    },
    "determinism": {
      "label": "Determinism",
      "color": "#ef4444",
      "description": "Disjunctions are mutually exclusive"
    },
    "smoothness": {
      "label": "Smoothness",
      "color": "#06b6d4",
      "description": "All disjuncts mention the same variables"
    },
    "flatness": {
      "label": "Flatness",
      "color": "#7c3aed",
      "description": "Formula has bounded height"
    },
    "ordering": {
      "label": "Ordering",
      "color": "#f97316",
      "description": "Variables follow a fixed ordering"
    },
    "read-once": {
      "label": "Read-Once",
      "color": "#ec4899",
      "description": "Each variable appears at most once on any path"
    },
    "decision": {
      "label": "Decision",
      "color": "#8b5cf6",
      "description": "Based on decision diagram structure"
    },
    "structured": {
      "label": "Structured",
      "color": "#10b981",
      "description": "Decomposition follows a structured pattern"
    }
  },
  "operations": {
    "queries": {
      "CO": {
        "code": "CO",
        "label": "Consistency",
        "description": "Check if the formula is satisfiable"
      },
      "VA": {
        "code": "VA",
        "label": "Validity",
        "description": "Check if the formula is a tautology"
      },
      "CE": {
        "code": "CE",
        "label": "Clausal Entailment",
        "description": "Check if a clause is entailed"
      },
      "IM": {
        "code": "IM",
        "label": "Implicant",
        "description": "Find an implicant of the formula"
      },
      "EQ": {
        "code": "EQ",
        "label": "Equivalence",
        "description": "Check logical equivalence of two formulas"
      },
      "SE": {
        "code": "SE",
        "label": "Sentential Entailment",
        "description": "Check if one formula entails another"
      },
      "CT": {
        "code": "CT",
        "label": "Model Counting",
        "description": "Count the number of satisfying assignments"
      },
      "ME": {
        "code": "ME",
        "label": "Model Enumeration",
        "description": "Enumerate all satisfying assignments"
      }
    },
    "transformations": {
      "CD": {
        "code": "CD",
        "label": "Conditioning",
        "description": "Restrict formula given variable assignments"
      },
      "FO": {
        "code": "FO",
        "label": "Forgetting",
        "description": "Existentially quantify out variables"
      },
      "SFO": {
        "code": "SFO",
        "label": "Singleton Forgetting",
        "description": "Forget a single variable"
      },
      "AND_C": {
        "code": "∧C",
        "label": "Conjunction",
        "description": "Compute conjunction of formulas"
      },
      "AND_BC": {
        "code": "∧BC",
        "label": "Bounded Conjunction",
        "description": "Conjunction with bounded result size"
      },
      "OR_C": {
        "code": "∨C",
        "label": "Disjunction",
        "description": "Compute disjunction of formulas"
      },
      "OR_BC": {
        "code": "∨BC",
        "label": "Bounded Disjunction",
        "description": "Disjunction with bounded result size"
      },
      "NOT_C": {
        "code": "¬C",
        "label": "Negation",
        "description": "Negate the formula"
      }
    }
  },
  "adjacencyMatrix": {
    "languageIds": [
      "lang_8f666aa0",
      "lang_bb65ddb5",
      "lang_89649e36",
      "lang_83e3b023",
      "lang_6c130090",
      "lang_ea9b5299",
      "lang_91f812d0",
      "lang_4c204bf3",
      "lang_3bebcab7",
      "lang_684b1ca7",
      "lang_6ae90adc",
      "lang_e02902d0",
      "lang_1df07cc3",
      "lang_5bf00851",
      "lang_d24efe0e",
      "lang_d69995dd",
      "lang_27fffab2",
      "lang_1afefbe2",
      "lang_9c84a267",
      "lang_b13b0d78",
      "lang_3c803ba1",
      "lang_4e62a038",
      "lang_c2df8c2b",
      "lang_b9d72a7c",
      "lang_981b62f0",
      "lang_0f27d539",
      "lang_4ae03bc8",
      "lang_82fa749e"
    ],
    "matrix": [
      [
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null
      ],
      [
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null
      ],
      [
        null,
        null,
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Van den Broeck_2015",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. cSDD compiles to DNNF in polynomial time \\citet{Van den Broeck_2015,Amarilli_2018}. If CNF compiles to cSDD in quasi-polynomial time, then PI compiles to DNNF in at most quasi-polynomial time. This contradicts the fact that PI cannot compile to DNNF in quasi-polynomial time \\citet{Bova_2016}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. If CNF compiles to d-DNNF in quasi-polynomial time, then PI compiles to DNNF in at most quasi-polynomial time. This contradicts the fact that PI cannot compile to DNNF in quasi-polynomial time \\citet{Bova_2016}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If CNF compiles to d-SDNNF in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. If CNF compiles to DNF in quasi-polynomial time, then PI compiles to DNF in at most quasi-polynomial time. This contradicts the fact that PI cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. If CNF compiles to DNNF in quasi-polynomial time, then PI compiles to DNNF in at most quasi-polynomial time. This contradicts the fact that PI cannot compile to DNNF in quasi-polynomial time \\citet{Bova_2016}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to d-DNNF in polynomial time \\citet{Darwiche_2002}. If CNF compiles to FBDD in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. If CNF compiles to IP in quasi-polynomial time, then CNF compiles to DNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "MODS compiles to d-DNNF in polynomial time \\citet{Darwiche_2002}. If CNF compiles to MODS in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "nFBDD compiles to DNNF in polynomial time \\citet{Amarilli_2018}. If CNF compiles to nFBDD in quasi-polynomial time, then CNF compiles to DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "poly",
          "description": "As defined by \\citet{Darwiche_2002}, $CNF$ is a subset of $NNF$. Therefore, a polynomial compilation is trivial.",
          "refs": [
            "Darwiche_2002"
          ]
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "nOBDD compiles to DNNF in polynomial time \\citet{Amarilli_2018}. If CNF compiles to nOBDD in quasi-polynomial time, then CNF compiles to DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to d-DNNF in polynomial time \\citet{Darwiche_2002,Amarilli_2018}. If CNF compiles to OBDD$_<$ in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "description": "It is well-known that some $CNF$ formulas (i.e. the negation of the parity function $\\neg PARITY_n=\\neg\\bigoplus_{i=1}^n x_i$) have exponentially many prime implicants.",
          "refs": [
            "Darwiche_2002"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "SDD compiles to d-DNNF in polynomial time \\citet{Van den Broeck_2015,Amarilli_2018}. If CNF compiles to SDD in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "SDNNF compiles to DNNF in polynomial time \\citet{Amarilli_2018}. If CNF compiles to SDNNF in quasi-polynomial time, then CNF compiles to DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "uFBDD compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If CNF compiles to uFBDD in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "uOBDD compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If CNF compiles to uOBDD in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If CNF compiles to OBDD in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "dec-DNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If CNF compiles to dec-DNNF in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "dec-SDNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If CNF compiles to dec-SDNNF in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        null,
        null
      ],
      [
        null,
        null,
        null,
        null,
        {
          "status": "poly",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "cSDD compiles to SDD in polynomial time \\citet{Van den Broeck_2015}. SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. d-SDNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from cSDD to d-DNNF."
        },
        {
          "status": "poly",
          "refs": [
            "Van den Broeck_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "cSDD compiles to SDD in polynomial time \\citet{Van den Broeck_2015}. SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. Therefore a polynomial compilation exists from cSDD to d-SDNNF."
        },
        null,
        null,
        {
          "status": "poly",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "cSDD compiles to SDD in polynomial time \\citet{Van den Broeck_2015}. SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. SDNNF compiles to DNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from cSDD to DNNF."
        },
        null,
        null,
        null,
        {
          "status": "unknown-poly-quasi",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "cSDD compiles to SDD in polynomial time \\citet{Van den Broeck_2015}. SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. d-SDNNF compiles to uOBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. uOBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from cSDD to nFBDD."
        },
        {
          "status": "poly",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "cSDD compiles to SDD in polynomial time \\citet{Van den Broeck_2015}. SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. SDNNF compiles to DNNF in polynomial time \\citet{Amarilli_2018}. DNNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from cSDD to NNF."
        },
        {
          "status": "unknown-poly-quasi",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "cSDD compiles to SDD in polynomial time \\citet{Van den Broeck_2015}. SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. d-SDNNF compiles to uOBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. uOBDD compiles to nOBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from cSDD to nOBDD."
        },
        null,
        null,
        {
          "status": "poly",
          "description": "As defined by \\citet{Van den Broeck_2015}, $cSDD$ is the compressed subset of $SDD$, so compilation is trivial.",
          "refs": [
            "Van den Broeck_2015"
          ],
          "derived": false
        },
        null,
        {
          "status": "poly",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "cSDD compiles to SDD in polynomial time \\citet{Van den Broeck_2015}. SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from cSDD to SDNNF."
        },
        null,
        {
          "status": "unknown-poly-quasi",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "cSDD compiles to SDD in polynomial time \\citet{Van den Broeck_2015}. SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. d-SDNNF compiles to uOBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. uOBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from cSDD to uFBDD."
        },
        {
          "status": "unknown-poly-quasi",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "cSDD compiles to SDD in polynomial time \\citet{Van den Broeck_2015}. SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. d-SDNNF compiles to uOBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. Therefore a quasi-polynomial compilation exists from cSDD to uOBDD."
        },
        null,
        null,
        null,
        null,
        null
      ],
      [
        null,
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to d-DNNF in polynomial time \\citet{Darwiche_2002,Amarilli_2018}. If d-DNNF compiles to CNF in quasi-polynomial time, then OBDD$_<$ compiles to CNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018",
            "Van den Broeck_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to d-DNNF in polynomial time \\citet{Darwiche_2002}. cSDD compiles to SDNNF in polynomial time \\citet{Van den Broeck_2015,Amarilli_2018}. If d-DNNF compiles to cSDD in quasi-polynomial time, then FBDD compiles to SDNNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to SDNNF in quasi-polynomial time \\citet{Capelli_2016,Pipatsrisawat_2010}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to d-DNNF in polynomial time \\citet{Darwiche_2002}. d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. If d-DNNF compiles to d-SDNNF in quasi-polynomial time, then FBDD compiles to SDNNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to SDNNF in quasi-polynomial time \\citet{Capelli_2016,Pipatsrisawat_2010}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018",
            "Wegener_2000"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to d-DNNF in polynomial time \\citet{Darwiche_2002}. DNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018,Wegener_2000}. If d-DNNF compiles to DNF in quasi-polynomial time, then FBDD compiles to SDNNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to SDNNF in quasi-polynomial time \\citet{Capelli_2016,Pipatsrisawat_2010}."
        },
        {
          "status": "poly",
          "description": "As formalized by \\citet{Darwiche_2002} and originally introduced in \\citet{Darwiche_2001}, $d$-$DNNF$ is a subset of $DNNF$ satisfying the determinism property, making a polynomial compilation trivial.",
          "refs": [
            "Darwiche_2002"
          ]
        },
        {
          "status": "no-quasi",
          "description": "$d$-$DNNF$s can polynomially represent the disjunction of two functions with conflicting variable orders, which forces $FBDD$s to grow exponentially to track the state of both orders within a single \"read-once\" path.",
          "refs": [
            "Darwiche_2000"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. If d-DNNF compiles to IP in quasi-polynomial time, then d-DNNF compiles to DNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018,Wegener_2000}."
        },
        {
          "status": "no-quasi",
          "description": "The $OR_n$ function $\\bigvee_{i=1}^nx_i$ can be represented in $O(n)$ as a $d$-$DNNF$ formula but has $2^n-1$ models.",
          "refs": [
            "Darwiche_2002"
          ],
          "derived": false
        },
        {
          "status": "no-poly-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "noPolyDescription": {
            "description": "dec-SDNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If d-DNNF compiles to nFBDD in polynomial time, then dec-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that dec-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.",
            "refs": [
              "Amarilli_2018",
              "Beame_2013"
            ],
            "derived": true
          },
          "quasiDescription": {
            "description": "d-DNNF compiles to uFBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from d-DNNF to nFBDD.",
            "refs": [
              "Amarilli_2018",
              "Beame_2013"
            ],
            "derived": true
          },
          "description": "First, we show no polynomial compilation exists.\ndec-SDNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If d-DNNF compiles to nFBDD in polynomial time, then dec-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that dec-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.\n\nNow, we show a quasi-polynomial compilation exists.\nd-DNNF compiles to uFBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from d-DNNF to nFBDD."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. DNNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from d-DNNF to NNF."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to d-DNNF in polynomial time \\citet{Darwiche_2002}. nOBDD compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. If d-DNNF compiles to nOBDD in quasi-polynomial time, then FBDD compiles to SDNNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to SDNNF in quasi-polynomial time \\citet{Capelli_2016,Pipatsrisawat_2010}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to d-SDNNF in polynomial time \\citet{Darwiche_2002,Amarilli_2018}. If d-DNNF compiles to OBDD$_<$ in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. If d-DNNF compiles to PI in quasi-polynomial time, then d-DNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Van den Broeck_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. If d-DNNF compiles to SDD in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "SDNNF compiles to nOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. If d-DNNF compiles to SDNNF in quasi-polynomial time, then d-DNNF compiles to nOBDD in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to nOBDD in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        null,
        {
          "status": "no-poly-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": false,
          "noPolyDescription": {
            "description": "uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If d-DNNF compiles to uFBDD in polynomial time, then d-DNNF compiles to nFBDD in polynomial time. This contradicts the fact that d-DNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.",
            "refs": [
              "Amarilli_2018",
              "Beame_2013"
            ],
            "derived": true
          },
          "quasiDescription": {
            "description": "The quasi-polynomial compilation from $dec$-$DNNF$ to $FBDD$ yields a $uFBDD$ when applied to a $d$-$DNNF$.",
            "refs": [
              "Amarilli_2018",
              "Beame_2013"
            ],
            "derived": false
          },
          "description": "First, we show no polynomial compilation exists.\nuFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If d-DNNF compiles to uFBDD in polynomial time, then d-DNNF compiles to nFBDD in polynomial time. This contradicts the fact that d-DNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.\n\nNow, we show a quasi-polynomial compilation exists.\nThe quasi-polynomial compilation from $dec$-$DNNF$ to $FBDD$ yields a $uFBDD$ when applied to a $d$-$DNNF$."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "uOBDD compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. If d-DNNF compiles to uOBDD in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. If d-DNNF compiles to OBDD in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "description": "Shown by Corollary 3.5 of \\citet{Beame_2013}.",
          "refs": [
            "Beame_2013"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "dec-SDNNF compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. If d-DNNF compiles to dec-SDNNF in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        null,
        null
      ],
      [
        null,
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to d-SDNNF in polynomial time \\citet{Darwiche_2002,Amarilli_2018}. If d-SDNNF compiles to CNF in quasi-polynomial time, then OBDD$_<$ compiles to CNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-poly-unknown-quasi",
          "refs": [
            "Van den Broeck_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "cSDD compiles to SDD in polynomial time \\citet{Van den Broeck_2015}. If d-SDNNF compiles to cSDD in polynomial time, then d-SDNNF compiles to SDD in polynomial time. This contradicts the fact that d-SDNNF cannot compile to SDD in polynomial time \\citet{Vinall-Smeeth_2024}."
        },
        {
          "status": "poly",
          "description": "As defined by \\citet{Amarilli_2018}, a $d$-$SDNNF$ is simply a structured $d$-$DNNF$, so compilation is trivial.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        null,
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to d-SDNNF in polynomial time \\citet{Darwiche_2002,Amarilli_2018}. If d-SDNNF compiles to DNF in quasi-polynomial time, then OBDD$_<$ compiles to DNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. SDNNF compiles to DNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from d-SDNNF to DNNF."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Van den Broeck_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. If d-SDNNF compiles to FBDD in quasi-polynomial time, then SDD compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that SDD cannot compile to FBDD in quasi-polynomial time \\citet{Bollig_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. If d-SDNNF compiles to IP in quasi-polynomial time, then d-SDNNF compiles to DNF in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "MODS compiles to CNF in polynomial time \\citet{Darwiche_2002}. If d-SDNNF compiles to MODS in quasi-polynomial time, then d-SDNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-poly-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": true,
          "noPolyDescription": {
            "description": "dec-SDNNF compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. If d-SDNNF compiles to nFBDD in polynomial time, then dec-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that dec-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.",
            "refs": [
              "Amarilli_2018",
              "Bollig_2018",
              "Beame_2015"
            ],
            "derived": true
          },
          "quasiDescription": {
            "description": "d-SDNNF compiles to uOBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. uOBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from d-SDNNF to nFBDD.",
            "refs": [
              "Amarilli_2018",
              "Bollig_2018",
              "Beame_2015"
            ],
            "derived": true
          },
          "description": "First, we show no polynomial compilation exists.\ndec-SDNNF compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. If d-SDNNF compiles to nFBDD in polynomial time, then dec-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that dec-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.\n\nNow, we show a quasi-polynomial compilation exists.\nd-SDNNF compiles to uOBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. uOBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from d-SDNNF to nFBDD."
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. SDNNF compiles to DNNF in polynomial time \\citet{Amarilli_2018}. DNNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from d-SDNNF to NNF."
        },
        {
          "status": "no-poly-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": true,
          "noPolyDescription": {
            "description": "nOBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If d-SDNNF compiles to nOBDD in polynomial time, then d-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that d-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}.",
            "refs": [
              "Amarilli_2018",
              "Bollig_2018",
              "Beame_2015"
            ],
            "derived": true
          },
          "quasiDescription": {
            "description": "d-SDNNF compiles to uOBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. uOBDD compiles to nOBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from d-SDNNF to nOBDD.",
            "refs": [
              "Amarilli_2018",
              "Bollig_2018",
              "Beame_2015"
            ],
            "derived": true
          },
          "description": "First, we show no polynomial compilation exists.\nnOBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If d-SDNNF compiles to nOBDD in polynomial time, then d-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that d-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}.\n\nNow, we show a quasi-polynomial compilation exists.\nd-SDNNF compiles to uOBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. uOBDD compiles to nOBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from d-SDNNF to nOBDD."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to FBDD in polynomial time \\citet{Darwiche_2002}. If d-SDNNF compiles to OBDD$_<$ in quasi-polynomial time, then d-SDNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to FBDD in quasi-polynomial time \\citet{Van den Broeck_2015}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. If d-SDNNF compiles to PI in quasi-polynomial time, then d-SDNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-poly-unknown-quasi",
          "description": "Theorem 1 of \\citet{Vinall-Smeeth_2024} proved that there exists a family of functions $f_n$ with $d$-$SDNNF$ of size $n$ but any $SDD$ representing $f_n$ has size $n^{\\Omega(log(n))}$.",
          "refs": [
            "Vinall-Smeeth_2024"
          ],
          "derived": false
        },
        null,
        {
          "status": "poly",
          "description": "As defined by \\citet{Amarilli_2018}, $d$-$SDNNF$ is simply the subset of $SDNNF$ satisfying determinism.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        null,
        {
          "status": "no-poly-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": true,
          "noPolyDescription": {
            "description": "uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If d-SDNNF compiles to uFBDD in polynomial time, then d-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that d-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}.",
            "refs": [
              "Amarilli_2018",
              "Bollig_2018",
              "Beame_2015"
            ],
            "derived": true
          },
          "quasiDescription": {
            "description": "d-SDNNF compiles to uOBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. uOBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from d-SDNNF to uFBDD.",
            "refs": [
              "Amarilli_2018",
              "Bollig_2018",
              "Beame_2015"
            ],
            "derived": true
          },
          "description": "First, we show no polynomial compilation exists.\nuFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If d-SDNNF compiles to uFBDD in polynomial time, then d-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that d-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}.\n\nNow, we show a quasi-polynomial compilation exists.\nd-SDNNF compiles to uOBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. uOBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from d-SDNNF to uFBDD."
        },
        {
          "status": "no-poly-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": false,
          "noPolyDescription": {
            "description": "uOBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If d-SDNNF compiles to uOBDD in polynomial time, then d-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that d-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}.",
            "refs": [
              "Amarilli_2018",
              "Bollig_2018",
              "Beame_2015"
            ],
            "derived": true
          },
          "quasiDescription": {
            "description": "Theorem 2 of \\citet{Bollig_2018} shows that $SDNNF$ can be compiled into $nOBDD$ by adapting the compilation of \\citet{Beame_2015} from $DNNF$ to $nFBDD$; proposition 2 of \\citet{Bollig_2018} shows that this $nOBDD$ is unambiguous if the $SDNNF$ is deterministic.",
            "refs": [
              "Amarilli_2018",
              "Bollig_2018",
              "Beame_2015"
            ],
            "derived": false
          },
          "description": "First, we show no polynomial compilation exists.\nuOBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If d-SDNNF compiles to uOBDD in polynomial time, then d-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that d-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}.\n\nNow, we show a quasi-polynomial compilation exists.\nTheorem 2 of \\citet{Bollig_2018} shows that $SDNNF$ can be compiled into $nOBDD$ by adapting the compilation of \\citet{Beame_2015} from $DNNF$ to $nFBDD$; proposition 2 of \\citet{Bollig_2018} shows that this $nOBDD$ is unambiguous if the $SDNNF$ is deterministic."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD compiles to FBDD in polynomial time \\citet{Darwiche_2002}. If d-SDNNF compiles to OBDD in quasi-polynomial time, then d-SDNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to FBDD in quasi-polynomial time \\citet{Van den Broeck_2015}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Van den Broeck_2015",
            "Beame_2013",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "dec-DNNF compiles to FBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If d-SDNNF compiles to dec-DNNF in quasi-polynomial time, then d-SDNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to FBDD in quasi-polynomial time \\citet{Van den Broeck_2015}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "description": "dec-SDNNF compiles to FBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If d-SDNNF compiles to dec-SDNNF in quasi-polynomial time, then d-SDNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to FBDD in quasi-polynomial time \\citet{Van den Broeck_2015}."
        },
        null,
        null
      ],
      [
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null
      ],
      [
        null,
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. If DNF compiles to CNF in quasi-polynomial time, then IP compiles to CNF in at most quasi-polynomial time. This contradicts the fact that IP cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "cSDD compiles to d-DNNF in polynomial time \\citet{Van den Broeck_2015,Amarilli_2018}. If DNF compiles to cSDD in quasi-polynomial time, then DNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that DNF cannot compile to d-DNNF in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "description": "Because counting the models of a $d$-$DNNF$ is in P and counting the models of a $DNF$ is \\#P-complete, $DNF$ cannot be polynomially compiled into $d$-$DNNF$ unconditionally. Such a transformation implies P = \\#P, collapsing the polynomial hierarchy \\citep{Darwiche_2002}.",
          "caveat": "the polynomial hierarchy collapses",
          "refs": [
            "Darwiche_2002"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If DNF compiles to d-SDNNF in quasi-polynomial time, then DNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that DNF cannot compile to d-DNNF in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Darwiche_2002}."
        },
        null,
        null,
        {
          "status": "poly",
          "description": "As defined by \\citet{Darwiche_2002}, $DNF$ is a subset of $DNNF$. Therefore, a polynomial compilation is trivial.",
          "refs": [
            "Darwiche_2002"
          ]
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. If DNF compiles to FBDD in quasi-polynomial time, then IP compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that IP cannot compile to FBDD in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Darwiche_2002,Wegener_1987}."
        },
        {
          "status": "no-quasi",
          "description": "It is well-known that some $DNF$ formulas (i.e. the parity function $PARITY_n=\\bigoplus_{i=1}^n x_i$) have exponentially many prime implicates.",
          "refs": [
            "Darwiche_2002"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "MODS compiles to CNF in polynomial time \\citet{Darwiche_2002}. If DNF compiles to MODS in quasi-polynomial time, then DNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that DNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018",
            "Wegener_2000"
          ],
          "hidden": false,
          "derived": true,
          "description": "DNF compiles to nOBDD in polynomial time \\citet{Amarilli_2018,Wegener_2000}. nOBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from DNF to nFBDD."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "DNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. DNNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from DNF to NNF."
        },
        {
          "status": "poly",
          "refs": [],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to FBDD in polynomial time \\citet{Darwiche_2002}. If DNF compiles to OBDD$_<$ in quasi-polynomial time, then DNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that DNF cannot compile to FBDD in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. If DNF compiles to PI in quasi-polynomial time, then DNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that DNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "SDD compiles to d-DNNF in polynomial time \\citet{Van den Broeck_2015,Amarilli_2018}. If DNF compiles to SDD in quasi-polynomial time, then DNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that DNF cannot compile to d-DNNF in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Darwiche_2002}."
        },
        null,
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018",
            "Wegener_2000"
          ],
          "hidden": false,
          "derived": true,
          "description": "DNF compiles to nOBDD in polynomial time \\citet{Amarilli_2018,Wegener_2000}. nOBDD compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from DNF to SDNNF."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "uFBDD compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If DNF compiles to uFBDD in quasi-polynomial time, then DNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that DNF cannot compile to d-DNNF in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "uOBDD compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If DNF compiles to uOBDD in quasi-polynomial time, then DNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that DNF cannot compile to d-DNNF in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "OBDD compiles to FBDD in polynomial time \\citet{Darwiche_2002}. If DNF compiles to OBDD in quasi-polynomial time, then DNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that DNF cannot compile to FBDD in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "dec-DNNF compiles to FBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If DNF compiles to dec-DNNF in quasi-polynomial time, then DNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that DNF cannot compile to FBDD in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "dec-SDNNF compiles to FBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If DNF compiles to dec-SDNNF in quasi-polynomial time, then DNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that DNF cannot compile to FBDD in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Darwiche_2002}."
        },
        null,
        null
      ],
      [
        null,
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. If DNNF compiles to CNF in quasi-polynomial time, then d-DNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. If DNNF compiles to cSDD in quasi-polynomial time, then d-DNNF compiles to cSDD in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to cSDD in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018,Van den Broeck_2015}."
        },
        {
          "status": "no-quasi",
          "description": "Proposition 7 of \\citet{Bova_2016} shows that the Sauerhoff function $S_n$ has $DNNF$ size $O(n^2)$. Theorem 9 shows that $S_n$ has $d$-$DNNF$ size $2^{\\Omega(n)}$.",
          "refs": [
            "Bova_2016"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. If DNNF compiles to d-SDNNF in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. If DNNF compiles to DNF in quasi-polynomial time, then d-DNNF compiles to DNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018,Wegener_2000}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. If DNNF compiles to FBDD in quasi-polynomial time, then d-DNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to FBDD in quasi-polynomial time \\citet{Darwiche_2000}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. If DNNF compiles to IP in quasi-polynomial time, then d-DNNF compiles to DNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018,Wegener_2000}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. MODS compiles to CNF in polynomial time \\citet{Darwiche_2002}. If DNNF compiles to MODS in quasi-polynomial time, then d-DNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-poly-quasi",
          "refs": [
            "Darwiche_2002",
            "Bodlaender_1993"
          ],
          "hidden": false,
          "derived": false,
          "noPolyDescription": {
            "description": "d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. If DNNF compiles to nFBDD in polynomial time, then d-DNNF compiles to nFBDD in polynomial time. This contradicts the fact that d-DNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.",
            "refs": [
              "Darwiche_2002",
              "Bodlaender_1993"
            ],
            "derived": true
          },
          "quasiDescription": {
            "description": "Section 5 of \\citet{Bodlaender_1993} extends the compilation of $dec$-$DNNF$s into $FBDD$s (shown in \\citet{Beame_2013}) to show that $DNNF$ can be quasi-polynomial-time compiled into $nFBDD$.",
            "refs": [
              "Bodlaender_1993"
            ],
            "derived": false
          },
          "description": "First, we show no polynomial compilation exists.\nd-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. If DNNF compiles to nFBDD in polynomial time, then d-DNNF compiles to nFBDD in polynomial time. This contradicts the fact that d-DNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.\n\nNow, we show a quasi-polynomial compilation exists.\nSection 5 of \\citet{Bodlaender_1993} extends the compilation of $dec$-$DNNF$s into $FBDD$s (shown in \\citet{Beame_2013}) to show that $DNNF$ can be quasi-polynomial-time compiled into $nFBDD$."
        },
        {
          "status": "poly",
          "description": "As defined by \\citet{Darwiche_2002}, $DNNF$ is a subset of $NNF$, so a polynomial compilation is trivial.",
          "refs": [
            "Darwiche_2002"
          ]
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. If DNNF compiles to nOBDD in quasi-polynomial time, then d-DNNF compiles to nOBDD in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to nOBDD in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. OBDD$_<$ compiles to d-SDNNF in polynomial time \\citet{Darwiche_2002,Amarilli_2018}. If DNNF compiles to OBDD$_<$ in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. If DNNF compiles to PI in quasi-polynomial time, then d-DNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Van den Broeck_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. If DNNF compiles to SDD in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. SDNNF compiles to nOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. If DNNF compiles to SDNNF in quasi-polynomial time, then d-DNNF compiles to nOBDD in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to nOBDD in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "uFBDD compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If DNNF compiles to uFBDD in quasi-polynomial time, then DNNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that DNNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Bova_2016}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. uOBDD compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. If DNNF compiles to uOBDD in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. OBDD compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. If DNNF compiles to OBDD in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Beame_2013",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. dec-DNNF compiles to FBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If DNNF compiles to dec-DNNF in quasi-polynomial time, then d-DNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to FBDD in quasi-polynomial time \\citet{Darwiche_2000}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. dec-SDNNF compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. If DNNF compiles to dec-SDNNF in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        null,
        null
      ],
      [
        null,
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to FBDD in polynomial time \\citet{Darwiche_2002}. If FBDD compiles to CNF in quasi-polynomial time, then OBDD$_<$ compiles to CNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "cSDD compiles to SDNNF in polynomial time \\citet{Van den Broeck_2015,Amarilli_2018}. If FBDD compiles to cSDD in quasi-polynomial time, then FBDD compiles to SDNNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to SDNNF in quasi-polynomial time \\citet{Capelli_2016,Pipatsrisawat_2010}."
        },
        {
          "status": "poly",
          "description": "As defined by \\citet{Darwiche_2002}, $FBDD$ is a subset of $d$-$DNNF$, so a polynomial compilation is trivial.",
          "refs": [
            "Darwiche_2002"
          ]
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. If FBDD compiles to d-SDNNF in quasi-polynomial time, then FBDD compiles to SDNNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to SDNNF in quasi-polynomial time \\citet{Capelli_2016,Pipatsrisawat_2010}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Wegener_2000"
          ],
          "hidden": false,
          "derived": true,
          "description": "DNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018,Wegener_2000}. If FBDD compiles to DNF in quasi-polynomial time, then FBDD compiles to SDNNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to SDNNF in quasi-polynomial time \\citet{Capelli_2016,Pipatsrisawat_2010}."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to d-DNNF in polynomial time \\citet{Darwiche_2002}. d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from FBDD to DNNF."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. If FBDD compiles to IP in quasi-polynomial time, then FBDD compiles to DNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to DNF in quasi-polynomial time \\citet{Amarilli_2018,Wegener_2000}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "MODS compiles to CNF in polynomial time \\citet{Darwiche_2002}. If FBDD compiles to MODS in quasi-polynomial time, then FBDD compiles to CNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from FBDD to nFBDD."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to d-DNNF in polynomial time \\citet{Darwiche_2002}. d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. DNNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from FBDD to NNF."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "nOBDD compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. If FBDD compiles to nOBDD in quasi-polynomial time, then FBDD compiles to SDNNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to SDNNF in quasi-polynomial time \\citet{Capelli_2016,Pipatsrisawat_2010}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to d-SDNNF in polynomial time \\citet{Darwiche_2002,Amarilli_2018}. If FBDD compiles to OBDD$_<$ in quasi-polynomial time, then FBDD compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to d-SDNNF in quasi-polynomial time \\citet{Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. If FBDD compiles to PI in quasi-polynomial time, then FBDD compiles to CNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Van den Broeck_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. If FBDD compiles to SDD in quasi-polynomial time, then FBDD compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to d-SDNNF in quasi-polynomial time \\citet{Amarilli_2018}."
        },
        null,
        {
          "status": "no-quasi",
          "description": "Appendix D.2 of \\citet{Pipatsrisawat_2010} and Section 6.3 of \\citet{Capelli_2016} independently proved this result using different techniques.",
          "refs": [
            "Capelli_2016",
            "Pipatsrisawat_2010"
          ],
          "derived": false
        },
        null,
        {
          "status": "poly",
          "description": "As defined by \\citet{Amarilli_2018}, $FBDD$ is the subset of $uFBDD$ with no $\\vee$-nodes.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "uOBDD compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. If FBDD compiles to uOBDD in quasi-polynomial time, then FBDD compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to d-SDNNF in quasi-polynomial time \\citet{Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "description": "The hidden weighted bit function $HWB_n$ has $OBDD$ size $2^{\\Omega(n/4)}$ \\citet{Bryant_1986} but $FBDD$ size $O(n^2)$ \\citet{Gergov_1994}.",
          "refs": [
            "Gergov_1994"
          ],
          "derived": false
        },
        {
          "status": "poly",
          "description": "Rewrite each decision node labeled $x$ as $(x \\wedge D_0) \\vee (\\neg x \\wedge D_1)$, where $D_0$ and $D_1$ are the rewritings of the 0- and 1-successors. The introduced $\\vee$-gates are decision gates and the $\\wedge$-gates are decomposable, so all $\\vee$-gates arise from decision node rewrites, yielding a $dec$-$DNNF$ in linear time \\citet{Amarilli_2018}.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "dec-SDNNF compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. If FBDD compiles to dec-SDNNF in quasi-polynomial time, then FBDD compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to d-SDNNF in quasi-polynomial time \\citet{Amarilli_2018}."
        },
        null,
        null
      ],
      [
        null,
        null,
        {
          "status": "no-quasi",
          "description": "Consider the $DNF$ formula $\\Pi_n=\\bigvee_{i=0}^{n-1}(x_{2i} \\wedge x_{2i+1})$. This formula is in prime implicants form and each clause in $\\Pi_n$ is an essential prime implicant of it. Hence its negation $\\neg\\Pi_n\\in IP$.\n\nSince the early work of Quine, we know that the number of essential prime implicates of a formula is a lower bound on the number of clauses that can be found in any $CNF$ representation of it. However, since $\\Pi_n$ has $2^n$ prime implicants, $\\neg\\Pi_n$ has $2^n$ prime implicates, so any $CNF$ representation of $\\neg\\Pi_n$ must have at least $2^n$ clauses.",
          "refs": [
            "Darwiche_2002"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2001b",
            "Darwiche_2002",
            "Van den Broeck_2015"
          ],
          "caveat": "the polynomial hierarchy collapses OR P=NP",
          "hidden": false,
          "derived": true,
          "description": "cSDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. If IP compiles to cSDD in quasi-polynomial time, then IP compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that IP cannot compile to d-SDNNF in quasi-polynomial time unless the polynomial hierarchy collapses OR P=NP."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2001b",
            "Darwiche_2002",
            "Amarilli_2018",
            "Beame_2013"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to uFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If IP compiles to d-DNNF in quasi-polynomial time, then IP compiles to uFBDD in at most quasi-polynomial time. This contradicts the fact that IP cannot compile to uFBDD in quasi-polynomial time unless the polynomial hierarchy collapses."
        },
        {
          "status": "no-quasi",
          "caveat": "P=NP",
          "refs": [],
          "derived": false
        },
        null,
        {
          "status": "poly",
          "description": "As defined by \\citet{Darwiche_2002}, $IP$ is a subset of $DNF$. Therefore, a polynomial compilation is trivial.",
          "refs": [
            "Darwiche_2002"
          ]
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. DNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from IP to DNNF."
        },
        {
          "status": "no-quasi",
          "description": "The negation of the clique detection function $\\neg\\Sigma_{n,k}$ has $O(n^3)$ prime implicants (hence polynomial $IP$ size), but any $FBDD$ for $\\neg\\Sigma_{n,k}$ has exponential size for suitable $k$ \\citet{Darwiche_2002,Wegener_1987}.",
          "refs": [
            "Darwiche_2002",
            "Wegener_1987"
          ],
          "derived": false
        },
        null,
        {
          "status": "no-quasi",
          "description": "The $OR_n$ function $\\bigvee_{i=1}^nx_i$ can be represented in $O(n)$ as a $IP$ formula but has $2^n-1$ models.",
          "refs": [
            "Darwiche_2002"
          ],
          "derived": false
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018",
            "Wegener_2000"
          ],
          "hidden": false,
          "derived": true,
          "description": "IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. DNF compiles to nOBDD in polynomial time \\citet{Amarilli_2018,Wegener_2000}. nOBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from IP to nFBDD."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. DNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. DNNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from IP to NNF."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018",
            "Wegener_2000"
          ],
          "hidden": false,
          "derived": true,
          "description": "IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. DNF compiles to nOBDD in polynomial time \\citet{Amarilli_2018,Wegener_2000}. Therefore a polynomial compilation exists from IP to nOBDD."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to FBDD in polynomial time \\citet{Darwiche_2002}. If IP compiles to OBDD$_<$ in quasi-polynomial time, then IP compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that IP cannot compile to FBDD in quasi-polynomial time \\citet{Darwiche_2002,Wegener_1987}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. If IP compiles to PI in quasi-polynomial time, then IP compiles to CNF in at most quasi-polynomial time. This contradicts the fact that IP cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2001b",
            "Darwiche_2002",
            "Van den Broeck_2015",
            "Amarilli_2018"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "SDD compiles to d-DNNF in polynomial time \\citet{Van den Broeck_2015,Amarilli_2018}. If IP compiles to SDD in quasi-polynomial time, then IP compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that IP cannot compile to d-DNNF in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Darwiche_2001b,Darwiche_2002,Amarilli_2018,Beame_2013}."
        },
        null,
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018",
            "Wegener_2000"
          ],
          "hidden": false,
          "derived": true,
          "description": "IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. DNF compiles to nOBDD in polynomial time \\citet{Amarilli_2018,Wegener_2000}. nOBDD compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from IP to SDNNF."
        },
        null,
        {
          "status": "no-quasi",
          "description": "Via counting",
          "refs": [],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2001b",
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "uOBDD compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If IP compiles to uOBDD in quasi-polynomial time, then IP compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that IP cannot compile to d-DNNF in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Darwiche_2001b,Darwiche_2002,Amarilli_2018,Beame_2013}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD compiles to FBDD in polynomial time \\citet{Darwiche_2002}. If IP compiles to OBDD in quasi-polynomial time, then IP compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that IP cannot compile to FBDD in quasi-polynomial time \\citet{Darwiche_2002,Wegener_1987}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Beame_2013",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "dec-DNNF compiles to FBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If IP compiles to dec-DNNF in quasi-polynomial time, then IP compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that IP cannot compile to FBDD in quasi-polynomial time \\citet{Darwiche_2002,Wegener_1987}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "description": "dec-SDNNF compiles to FBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If IP compiles to dec-SDNNF in quasi-polynomial time, then IP compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that IP cannot compile to FBDD in quasi-polynomial time \\citet{Darwiche_2002,Wegener_1987}."
        },
        null,
        null
      ],
      [
        null,
        null,
        {
          "status": "poly",
          "description": "A Shannon tree for any $MODS$ formula can be generated in polynomial time. Paths from the root to 0-leaves yield a $CNF$ representation \\citet{Darwiche_2002}.",
          "refs": [
            "Darwiche_2002"
          ],
          "derived": false
        },
        null,
        {
          "status": "poly",
          "description": "As defined by \\citet{Darwiche_2002}, $MODS$ is a subset of $d$-$DNNF$. Therefore, a polynomial compilation is trivial.",
          "refs": [
            "Darwiche_2002"
          ]
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "MODS compiles to OBDD$_<$ in polynomial time \\citet{Darwiche_2002}. OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to dec-SDNNF in polynomial time \\citet{Amarilli_2018}. dec-SDNNF compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from MODS to d-SDNNF."
        },
        null,
        {
          "status": "poly",
          "description": "As defined by \\citet{Darwiche_2002}, $MODS$ is a subset of $DNF$ (any $MODS$ formula can be written as a disjunction of the individual models). Therefore, a polynomial compilation is trivial.",
          "refs": [
            "Darwiche_2002"
          ]
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "MODS compiles to d-DNNF in polynomial time \\citet{Darwiche_2002}. d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from MODS to DNNF."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "MODS compiles to OBDD$_<$ in polynomial time \\citet{Darwiche_2002}. OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to FBDD in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from MODS to FBDD."
        },
        {
          "status": "poly",
          "description": "The Quine-McCluskey algorithm generates an $IP$ formula in polynomial time.",
          "refs": [
            "Wegener_1987"
          ],
          "derived": false
        },
        null,
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "MODS compiles to OBDD$_<$ in polynomial time \\citet{Darwiche_2002}. OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to uOBDD in polynomial time \\citet{Amarilli_2018}. uOBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from MODS to nFBDD."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "MODS compiles to d-DNNF in polynomial time \\citet{Darwiche_2002}. d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. DNNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from MODS to NNF."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "MODS compiles to OBDD$_<$ in polynomial time \\citet{Darwiche_2002}. OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to uOBDD in polynomial time \\citet{Amarilli_2018}. uOBDD compiles to nOBDD in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from MODS to nOBDD."
        },
        {
          "status": "poly",
          "description": "A Shannon tree for any $MODS$ formula following order $<$ can be generated in polynomial time. This tree can be reduced into a corresponding $OBDD_<$ in polynomial time \\citet{Darwiche_2002}.",
          "refs": [
            "Darwiche_2002"
          ],
          "derived": false
        },
        {
          "status": "no-poly-quasi",
          "description": "\\citet{Kaleyski_2016} constructs a family of Boolean functions $\\psi_i$ with $MODS$ size $\\Theta(2^{2i})$ but $PI$ size $\\Omega(2^{(i-1)^2/4})$, ruling out a polynomial transformation. Whether an exponential separation exists remains open.",
          "refs": [
            "Kaleyski_2016"
          ],
          "derived": false
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Darwiche_2011"
          ],
          "hidden": false,
          "derived": true,
          "description": "MODS compiles to OBDD$_<$ in polynomial time \\citet{Darwiche_2002}. OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to SDD in polynomial time \\citet{Darwiche_2011}. Therefore a polynomial compilation exists from MODS to SDD."
        },
        null,
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "MODS compiles to OBDD$_<$ in polynomial time \\citet{Darwiche_2002}. OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to dec-SDNNF in polynomial time \\citet{Amarilli_2018}. dec-SDNNF compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from MODS to SDNNF."
        },
        null,
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "MODS compiles to OBDD$_<$ in polynomial time \\citet{Darwiche_2002}. OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to uOBDD in polynomial time \\citet{Amarilli_2018}. uOBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from MODS to uFBDD."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "MODS compiles to OBDD$_<$ in polynomial time \\citet{Darwiche_2002}. OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to uOBDD in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from MODS to uOBDD."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "MODS compiles to OBDD$_<$ in polynomial time \\citet{Darwiche_2002}. OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from MODS to OBDD."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "MODS compiles to OBDD$_<$ in polynomial time \\citet{Darwiche_2002}. OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to dec-SDNNF in polynomial time \\citet{Amarilli_2018}. dec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from MODS to dec-DNNF."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "MODS compiles to OBDD$_<$ in polynomial time \\citet{Darwiche_2002}. OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to dec-SDNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from MODS to dec-SDNNF."
        },
        null,
        null
      ],
      [
        null,
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013",
            "Wegener_2000"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to nFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If nFBDD compiles to CNF in quasi-polynomial time, then d-DNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013",
            "Wegener_2000"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to nFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If nFBDD compiles to cSDD in quasi-polynomial time, then d-DNNF compiles to cSDD in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to cSDD in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Darwiche_2002,Amarilli_2018,Van den Broeck_2015}."
        },
        {
          "status": "no-quasi",
          "description": "The Sauerhoff function has an $nFBDD$ of size $O(n^2)$ over $n^2$ variables, but as a $d$-$DNNF$ has size $2^{\\Omega(n)}$.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013",
            "Wegener_2000"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to nFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If nFBDD compiles to d-SDNNF in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Darwiche_2002,Amarilli_2018}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to nFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If nFBDD compiles to DNF in quasi-polynomial time, then d-DNNF compiles to DNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018,Wegener_2000}."
        },
        {
          "status": "poly",
          "description": "Rewrite each decision node labeled $x$ as $(x \\wedge D_0) \\vee (\\neg x \\wedge D_1)$, where $D_0, D_1$ are the rewritings of the 0- and 1-successors. The $\\wedge$-gates are decomposable, yielding a $DNNF$ in linear time \\citet{Amarilli_2018}.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "description": "Consider the Boolean functions $\\psi_n,\\phi_n:\\{0,1\\}^{n^2}\\to\\{0,1\\}$ that respectively test whether, in an $n \\times n$ Boolean matrix, either the number of 1's is odd and there is a full row of 1's, or the number of 1's is even and there is a column full of 1's. An $FBDD$ of size $O(n^2)$ may simulate either $\\psi_n$ or $\\phi_n$, and thus the $uFBDD$ $\\psi_n\\vee\\phi_n$ is of size $O(n^2)$; however, an $FBDD$ for $\\psi_n\\vee\\phi_n$ is provably of size $2^{\\Omega(n^{1/2})}$ \\citet{Amarilli_2018}.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013",
            "Wegener_2000",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to nFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. If nFBDD compiles to IP in quasi-polynomial time, then d-DNNF compiles to DNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018,Wegener_2000}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to nFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. MODS compiles to CNF in polynomial time \\citet{Darwiche_2002}. If nFBDD compiles to MODS in quasi-polynomial time, then d-DNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        null,
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "nFBDD compiles to DNNF in polynomial time \\citet{Amarilli_2018}. DNNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from nFBDD to NNF."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to nFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If nFBDD compiles to nOBDD in quasi-polynomial time, then d-DNNF compiles to nOBDD in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to nOBDD in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to nFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. OBDD$_<$ compiles to d-SDNNF in polynomial time \\citet{Darwiche_2002,Amarilli_2018}. If nFBDD compiles to OBDD$_<$ in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013",
            "Wegener_2000",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to nFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. If nFBDD compiles to PI in quasi-polynomial time, then d-DNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013",
            "Wegener_2000",
            "Van den Broeck_2015"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to nFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. If nFBDD compiles to SDD in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Darwiche_2002,Amarilli_2018}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to nFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. SDNNF compiles to nOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. If nFBDD compiles to SDNNF in quasi-polynomial time, then d-DNNF compiles to nOBDD in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to nOBDD in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        null,
        {
          "status": "no-quasi",
          "description": "The Sauerhoff function has an $nFBDD$ of size $O(n^2)$ over $n^2$ variables, but as a $d$-$DNNF$, which generalize $uFBDD$, has size $2^{\\Omega(n)}$.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013",
            "Wegener_2000"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to nFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. uOBDD compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. If nFBDD compiles to uOBDD in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to nFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. OBDD compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. If nFBDD compiles to OBDD in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to nFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. dec-DNNF compiles to FBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If nFBDD compiles to dec-DNNF in quasi-polynomial time, then d-DNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to FBDD in quasi-polynomial time \\citet{Darwiche_2000}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to nFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. dec-SDNNF compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. If nFBDD compiles to dec-SDNNF in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        null,
        null
      ],
      [
        null,
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. If NNF compiles to CNF in quasi-polynomial time, then d-DNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "CNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. If NNF compiles to cSDD in quasi-polynomial time, then CNF compiles to cSDD in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to cSDD in quasi-polynomial time \\citet{Darwiche_2002,Van den Broeck_2015,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "CNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. If NNF compiles to d-DNNF in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "CNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. d-SDNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If NNF compiles to d-SDNNF in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "CNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. If NNF compiles to DNF in quasi-polynomial time, then CNF compiles to DNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "CNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. If NNF compiles to DNNF in quasi-polynomial time, then CNF compiles to DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "CNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. FBDD compiles to d-DNNF in polynomial time \\citet{Darwiche_2002}. If NNF compiles to FBDD in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "CNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. If NNF compiles to IP in quasi-polynomial time, then CNF compiles to DNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "CNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. MODS compiles to d-DNNF in polynomial time \\citet{Darwiche_2002}. If NNF compiles to MODS in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "CNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. nFBDD compiles to DNNF in polynomial time \\citet{Amarilli_2018}. If NNF compiles to nFBDD in quasi-polynomial time, then CNF compiles to DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "CNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. nOBDD compiles to DNNF in polynomial time \\citet{Amarilli_2018}. If NNF compiles to nOBDD in quasi-polynomial time, then CNF compiles to DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "CNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. OBDD$_<$ compiles to d-DNNF in polynomial time \\citet{Darwiche_2002,Amarilli_2018}. If NNF compiles to OBDD$_<$ in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "CNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. If NNF compiles to PI in quasi-polynomial time, then CNF compiles to PI in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to PI in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Van den Broeck_2015",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "CNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. SDD compiles to d-DNNF in polynomial time \\citet{Van den Broeck_2015,Amarilli_2018}. If NNF compiles to SDD in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "CNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. SDNNF compiles to DNNF in polynomial time \\citet{Amarilli_2018}. If NNF compiles to SDNNF in quasi-polynomial time, then CNF compiles to DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "CNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. uFBDD compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If NNF compiles to uFBDD in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "CNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. uOBDD compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If NNF compiles to uOBDD in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "CNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. OBDD compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If NNF compiles to OBDD in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "CNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. dec-DNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If NNF compiles to dec-DNNF in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "CNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. dec-SDNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If NNF compiles to dec-SDNNF in quasi-polynomial time, then CNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that CNF cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        null,
        null
      ],
      [
        null,
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015",
            "Wegener_2000"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to nOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. If nOBDD compiles to CNF in quasi-polynomial time, then d-SDNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Wegener_2000",
            "Van den Broeck_2015",
            "Bollig_2018",
            "Beame_2015"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "cSDD compiles to uOBDD in at worst quasi-polynomial time \\citet{Van den Broeck_2015,Amarilli_2018,Bollig_2018,Beame_2015}. If nOBDD compiles to cSDD in quasi-polynomial time, then nOBDD compiles to uOBDD in at most quasi-polynomial time. This contradicts the fact that nOBDD cannot compile to uOBDD in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Wegener_2000"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "DNF compiles to nOBDD in polynomial time. If nOBDD compiles to d-DNNF in quasi-polynomial time, then DNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that DNF cannot compile to d-DNNF in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Wegener_2000",
            "Bollig_2018",
            "Beame_2015"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to uOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. If nOBDD compiles to d-SDNNF in quasi-polynomial time, then nOBDD compiles to uOBDD in at most quasi-polynomial time. This contradicts the fact that nOBDD cannot compile to uOBDD in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Amarilli_2018}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to nOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. If nOBDD compiles to DNF in quasi-polynomial time, then d-SDNNF compiles to DNF in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "nOBDD compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. SDNNF compiles to DNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from nOBDD to DNNF."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015",
            "Wegener_2000",
            "Darwiche_2002"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to nOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. If nOBDD compiles to FBDD in quasi-polynomial time, then d-SDNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to FBDD in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Van den Broeck_2015}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015",
            "Wegener_2000",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to nOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. If nOBDD compiles to IP in quasi-polynomial time, then d-SDNNF compiles to DNF in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015",
            "Wegener_2000",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to nOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. MODS compiles to CNF in polynomial time \\citet{Darwiche_2002}. If nOBDD compiles to MODS in quasi-polynomial time, then d-SDNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "poly",
          "description": "As defined by \\citet{Amarilli_2018}, $nOBDD$ is the subset of $nFBDD$ satisfying an order of the variables, so compilation entails discarding the order.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "nOBDD compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. SDNNF compiles to DNNF in polynomial time \\citet{Amarilli_2018}. DNNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from nOBDD to NNF."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015",
            "Wegener_2000",
            "Darwiche_2002"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to nOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. OBDD$_<$ compiles to FBDD in polynomial time \\citet{Darwiche_2002}. If nOBDD compiles to OBDD$_<$ in quasi-polynomial time, then d-SDNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to FBDD in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Van den Broeck_2015}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015",
            "Wegener_2000",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to nOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. If nOBDD compiles to PI in quasi-polynomial time, then d-SDNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Wegener_2000",
            "Van den Broeck_2015"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. If nOBDD compiles to SDD in quasi-polynomial time, then nOBDD compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that nOBDD cannot compile to d-SDNNF in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Amarilli_2018,Wegener_2000,Bollig_2018,Beame_2015}."
        },
        null,
        {
          "status": "poly",
          "description": "Construct a right-linear v-tree from the variable order, then rewrite each decision node labeled $x$ as $(x \\wedge D_0) \\vee (\\neg x \\wedge D_1)$, where $D_0, D_1$ are the rewritings of the 0- and 1-successors. The v-tree alignment ensures every $\\wedge$-gate respects the variable partition, yielding an $SDNNF$ in linear time \\citet{Amarilli_2018}.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Wegener_2000"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "DNF compiles to nOBDD in polynomial time. uFBDD compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If nOBDD compiles to uFBDD in quasi-polynomial time, then DNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that DNF cannot compile to d-DNNF in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "description": "Any $DNF$ can be represented as an $nOBDD$ in linear time; however the family of $DNF$s $(\\phi_n)_{n\\in\\N}$ built from expander graphs have treewidth linear in their size. Thus, any $uOBDD$ for $\\phi_n$ is of size $2^{\\Omega(|\\phi_n|)}$. (TODO: write intuitive explanation or define expander graph separator)",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015",
            "Wegener_2000",
            "Darwiche_2002"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to nOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. OBDD compiles to FBDD in polynomial time \\citet{Darwiche_2002}. If nOBDD compiles to OBDD in quasi-polynomial time, then d-SDNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to FBDD in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Van den Broeck_2015}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015",
            "Wegener_2000",
            "Beame_2013"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to nOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. dec-DNNF compiles to FBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If nOBDD compiles to dec-DNNF in quasi-polynomial time, then d-SDNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to FBDD in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Van den Broeck_2015}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015",
            "Wegener_2000",
            "Beame_2013"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to nOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. dec-SDNNF compiles to FBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If nOBDD compiles to dec-SDNNF in quasi-polynomial time, then d-SDNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to FBDD in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Van den Broeck_2015}."
        },
        null,
        null
      ],
      [
        null,
        null,
        {
          "status": "no-quasi",
          "description": "The parity function $PARITY_n=\\bigoplus_{i=1}^n x_i$ has linear size $OBDD_<$ representations but only exponential size $CNF$ representations.",
          "refs": [
            "Darwiche_2002"
          ],
          "derived": false
        },
        null,
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to dec-SDNNF in polynomial time \\citet{Amarilli_2018}. dec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. dec-DNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from OBDD$_<$ to d-DNNF."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to dec-SDNNF in polynomial time \\citet{Amarilli_2018}. dec-SDNNF compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from OBDD$_<$ to d-SDNNF."
        },
        null,
        {
          "status": "no-quasi",
          "description": "The parity function $PARITY_n=\\bigoplus_{i=1}^n x_i$ has linear size $OBDD_<$ representations but only exponential size $DNF$ representations.",
          "refs": [
            "Darwiche_2002"
          ],
          "derived": false
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to dec-SDNNF in polynomial time \\citet{Amarilli_2018}. dec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. dec-DNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from OBDD$_<$ to DNNF."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to FBDD in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from OBDD$_<$ to FBDD."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. If OBDD$_<$ compiles to IP in quasi-polynomial time, then OBDD$_<$ compiles to DNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "MODS compiles to CNF in polynomial time \\citet{Darwiche_2002}. If OBDD$_<$ compiles to MODS in quasi-polynomial time, then OBDD$_<$ compiles to CNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to uOBDD in polynomial time \\citet{Amarilli_2018}. uOBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from OBDD$_<$ to nFBDD."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to dec-SDNNF in polynomial time \\citet{Amarilli_2018}. dec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. dec-DNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. DNNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from OBDD$_<$ to NNF."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to uOBDD in polynomial time \\citet{Amarilli_2018}. uOBDD compiles to nOBDD in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from OBDD$_<$ to nOBDD."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. If OBDD$_<$ compiles to PI in quasi-polynomial time, then OBDD$_<$ compiles to CNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Darwiche_2011"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to SDD in polynomial time \\citet{Darwiche_2011}. Therefore a polynomial compilation exists from OBDD$_<$ to SDD."
        },
        null,
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to dec-SDNNF in polynomial time \\citet{Amarilli_2018}. dec-SDNNF compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from OBDD$_<$ to SDNNF."
        },
        null,
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to uOBDD in polynomial time \\citet{Amarilli_2018}. uOBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from OBDD$_<$ to uFBDD."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to uOBDD in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from OBDD$_<$ to uOBDD."
        },
        {
          "status": "poly",
          "description": "As defined by \\citet{Darwiche_2002}, $OBDD_<$ is a subset of $OBDD$. Therefore, a polynomial compilation is trivial.",
          "refs": [
            "Darwiche_2002"
          ]
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to dec-SDNNF in polynomial time \\citet{Amarilli_2018}. dec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from OBDD$_<$ to dec-DNNF."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. OBDD compiles to dec-SDNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from OBDD$_<$ to dec-SDNNF."
        },
        null,
        null
      ],
      [
        null,
        null,
        {
          "status": "poly",
          "description": "As defined by \\citet{Darwiche_2002}, $PI$ is a subset of $CNF$. Therefore, a polynomial compilation is trivial.",
          "refs": [
            "Darwiche_2002"
          ]
        },
        {
          "status": "no-quasi",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "cSDD compiles to DNNF in polynomial time \\citet{Van den Broeck_2015,Amarilli_2018}. If PI compiles to cSDD in quasi-polynomial time, then PI compiles to DNNF in at most quasi-polynomial time. This contradicts the fact that PI cannot compile to DNNF in quasi-polynomial time \\citet{Bova_2016}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. If PI compiles to d-DNNF in quasi-polynomial time, then PI compiles to DNNF in at most quasi-polynomial time. This contradicts the fact that PI cannot compile to DNNF in quasi-polynomial time \\citet{Bova_2016}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If PI compiles to d-SDNNF in quasi-polynomial time, then PI compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that PI cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        null,
        {
          "status": "no-quasi",
          "description": "The pairwise CNF $\\Sigma_n = \\bigwedge_{i=0}^{n-1}(x_{2i} \\vee x_{2i+1})$ has $2^n$ prime implicates; its negation $\\neg\\Sigma_n \\in PI$ therefore has $2^n$ essential prime implicants, forcing any $DNF$ representation to have at least $2^n$ terms \\citet{Darwiche_2002}.",
          "refs": [
            "Darwiche_2002"
          ]
        },
        {
          "status": "no-quasi",
          "description": "Proposition 11 of \\citet{Bova_2016} shows that the $JS_n$ has $PI$ size $O(n^2)$. Proposition 12 of \\citet{Bova_2016} shows that $JS_n$ has $DNNF$ size $2^{\\Omega(n^2)}$.",
          "refs": [
            "Bova_2016"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "description": "The clique detection function $\\Sigma_{n,k}$ has $O(n^3)$ prime implicates (hence polynomial $PI$ size), but any $FBDD$ for $\\Sigma_{n,k}$ has exponential size for suitable $k$ \\citet{Wegener_1987,Darwiche_2002}.",
          "refs": [
            "Wegener_1987",
            "Darwiche_2002"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. If PI compiles to IP in quasi-polynomial time, then PI compiles to DNF in at most quasi-polynomial time. This contradicts the fact that PI cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "description": "The $OR_n$ function $\\bigvee_{i=1}^nx_i$ can be represented in $O(n)$ as a $PI$ formula but has $2^n-1$ models.",
          "refs": [
            "Darwiche_2002"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "nFBDD compiles to DNNF in polynomial time \\citet{Amarilli_2018}. If PI compiles to nFBDD in quasi-polynomial time, then PI compiles to DNNF in at most quasi-polynomial time. This contradicts the fact that PI cannot compile to DNNF in quasi-polynomial time \\citet{Bova_2016}."
        },
        {
          "status": "poly",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. CNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from PI to NNF."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "nOBDD compiles to DNNF in polynomial time \\citet{Amarilli_2018}. If PI compiles to nOBDD in quasi-polynomial time, then PI compiles to DNNF in at most quasi-polynomial time. This contradicts the fact that PI cannot compile to DNNF in quasi-polynomial time \\citet{Bova_2016}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to d-DNNF in polynomial time \\citet{Darwiche_2002,Amarilli_2018}. If PI compiles to OBDD$_<$ in quasi-polynomial time, then PI compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that PI cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "SDD compiles to d-DNNF in polynomial time \\citet{Van den Broeck_2015,Amarilli_2018}. If PI compiles to SDD in quasi-polynomial time, then PI compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that PI cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "SDNNF compiles to DNNF in polynomial time \\citet{Amarilli_2018}. If PI compiles to SDNNF in quasi-polynomial time, then PI compiles to DNNF in at most quasi-polynomial time. This contradicts the fact that PI cannot compile to DNNF in quasi-polynomial time \\citet{Bova_2016}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "uFBDD compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If PI compiles to uFBDD in quasi-polynomial time, then PI compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that PI cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "uOBDD compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If PI compiles to uOBDD in quasi-polynomial time, then PI compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that PI cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If PI compiles to OBDD in quasi-polynomial time, then PI compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that PI cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "dec-DNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If PI compiles to dec-DNNF in quasi-polynomial time, then PI compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that PI cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "dec-SDNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If PI compiles to dec-SDNNF in quasi-polynomial time, then PI compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that PI cannot compile to d-DNNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        null,
        null
      ],
      [
        null,
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Darwiche_2011"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to SDD in polynomial time \\citet{Darwiche_2002,Darwiche_2011}. If SDD compiles to CNF in quasi-polynomial time, then OBDD$_<$ compiles to CNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        null,
        {
          "status": "poly",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. d-SDNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from SDD to d-DNNF."
        },
        {
          "status": "poly",
          "description": "$SDD$ is a strict subset of $d$-$SDNNF$.",
          "refs": [
            "Van den Broeck_2015"
          ],
          "derived": false
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Darwiche_2011"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to SDD in polynomial time \\citet{Darwiche_2002,Darwiche_2011}. If SDD compiles to DNF in quasi-polynomial time, then OBDD$_<$ compiles to DNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "poly",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. SDNNF compiles to DNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from SDD to DNNF."
        },
        {
          "status": "no-quasi",
          "description": "The weighted sum function $WS_n$ can be represented by SDDs of size $O(n^3)$ (Corollary 3 of \\citet{Bollig_2018}), but has exponential $FBDD$ size. Therefore, $P(SDD) \\not\\subseteq P(FBDD)$, which combined with the known result $P(FBDD) \\not\\subseteq P(SDD)$ from \\citet{Beame_2015}, establishes that $SDD$ and $FBDD$ are incomparable (Corollary 4 of \\citet{Bollig_2018}).",
          "refs": [
            "Bollig_2018"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Darwiche_2011"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to SDD in polynomial time \\citet{Darwiche_2002,Darwiche_2011}. IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. If SDD compiles to IP in quasi-polynomial time, then OBDD$_<$ compiles to DNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Darwiche_2011"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to SDD in polynomial time \\citet{Darwiche_2002,Darwiche_2011}. MODS compiles to CNF in polynomial time \\citet{Darwiche_2002}. If SDD compiles to MODS in quasi-polynomial time, then OBDD$_<$ compiles to CNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "unknown-poly-quasi",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. d-SDNNF compiles to uOBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. uOBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from SDD to nFBDD."
        },
        {
          "status": "poly",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. SDNNF compiles to DNNF in polynomial time \\citet{Amarilli_2018}. DNNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from SDD to NNF."
        },
        {
          "status": "unknown-poly-quasi",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. d-SDNNF compiles to uOBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. uOBDD compiles to nOBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from SDD to nOBDD."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to FBDD in polynomial time \\citet{Darwiche_2002}. If SDD compiles to OBDD$_<$ in quasi-polynomial time, then SDD compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that SDD cannot compile to FBDD in quasi-polynomial time \\citet{Bollig_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Darwiche_2011"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to SDD in polynomial time \\citet{Darwiche_2002,Darwiche_2011}. PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. If SDD compiles to PI in quasi-polynomial time, then OBDD$_<$ compiles to CNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        null,
        null,
        {
          "status": "poly",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from SDD to SDNNF."
        },
        null,
        {
          "status": "unknown-poly-quasi",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. d-SDNNF compiles to uOBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. uOBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from SDD to uFBDD."
        },
        {
          "status": "unknown-poly-quasi",
          "refs": [
            "Van den Broeck_2015",
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. d-SDNNF compiles to uOBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. Therefore a quasi-polynomial compilation exists from SDD to uOBDD."
        },
        {
          "status": "no-quasi",
          "description": "$OBDD$ representations of $HWB_n$ are $2^{\\Omega(n)}$\\citet{Bryant_1986}, but an $SDD$ can represent $HWB_n$ in size $O(n^3)$\\citet{Bova_2016_a}.",
          "refs": [
            "Bryant_1986",
            "Bova_2016_a"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Beame_2013",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "dec-DNNF compiles to FBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If SDD compiles to dec-DNNF in quasi-polynomial time, then SDD compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that SDD cannot compile to FBDD in quasi-polynomial time \\citet{Bollig_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "description": "dec-SDNNF compiles to FBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If SDD compiles to dec-SDNNF in quasi-polynomial time, then SDD compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that SDD cannot compile to FBDD in quasi-polynomial time \\citet{Bollig_2018}."
        },
        null,
        null
      ],
      [
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null
      ],
      [
        null,
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. If SDNNF compiles to CNF in quasi-polynomial time, then d-SDNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "nOBDD compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. If SDNNF compiles to cSDD in quasi-polynomial time, then nOBDD compiles to cSDD in at most quasi-polynomial time. This contradicts the fact that nOBDD cannot compile to cSDD in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Amarilli_2018,Wegener_2000,Van den Broeck_2015,Bollig_2018,Beame_2015}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Wegener_2000"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "DNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018,Wegener_2000}. If SDNNF compiles to d-DNNF in quasi-polynomial time, then DNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that DNF cannot compile to d-DNNF in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Wegener_2000"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "nOBDD compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. If SDNNF compiles to d-SDNNF in quasi-polynomial time, then nOBDD compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that nOBDD cannot compile to d-SDNNF in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Amarilli_2018,Wegener_2000,Bollig_2018,Beame_2015}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. If SDNNF compiles to DNF in quasi-polynomial time, then d-SDNNF compiles to DNF in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "poly",
          "description": "As defined by \\citet{Amarilli_2018}, a structured $DNNF$ is a triple of the corresponding $DNNF$, the v-tree $T$, and a mapping $\\rho$; as such, extracting a $DNNF$ from a $SDNNF$ is trivial.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. If SDNNF compiles to FBDD in quasi-polynomial time, then d-SDNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to FBDD in quasi-polynomial time \\citet{Van den Broeck_2015}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. If SDNNF compiles to IP in quasi-polynomial time, then d-SDNNF compiles to DNF in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. MODS compiles to CNF in polynomial time \\citet{Darwiche_2002}. If SDNNF compiles to MODS in quasi-polynomial time, then d-SDNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-poly-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": true,
          "noPolyDescription": {
            "description": "d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. If SDNNF compiles to nFBDD in polynomial time, then d-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that d-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}.",
            "refs": [
              "Amarilli_2018",
              "Bollig_2018",
              "Beame_2015"
            ],
            "derived": true
          },
          "quasiDescription": {
            "description": "SDNNF compiles to nOBDD in at worst quasi-polynomial time \\citet{Bollig_2018,Beame_2015}. nOBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from SDNNF to nFBDD.",
            "refs": [
              "Bollig_2018",
              "Beame_2015",
              "Amarilli_2018"
            ],
            "derived": true
          },
          "description": "First, we show no polynomial compilation exists.\nd-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. If SDNNF compiles to nFBDD in polynomial time, then d-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that d-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}.\n\nNow, we show a quasi-polynomial compilation exists.\nSDNNF compiles to nOBDD in at worst quasi-polynomial time \\citet{Bollig_2018,Beame_2015}. nOBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from SDNNF to nFBDD."
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "SDNNF compiles to DNNF in polynomial time \\citet{Amarilli_2018}. DNNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from SDNNF to NNF."
        },
        {
          "status": "no-poly-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": false,
          "noPolyDescription": {
            "description": "d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. nOBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If SDNNF compiles to nOBDD in polynomial time, then d-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that d-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}.",
            "refs": [
              "Amarilli_2018",
              "Bollig_2018",
              "Beame_2015"
            ],
            "derived": true
          },
          "quasiDescription": {
            "description": "Theorem 2 of \\citet{Bollig_2018} shows that $SDNNF$ can be compiled into $nOBDD$ by adapting the compilation of \\citet{Beame_2015} from $DNNF$ to $nFBDD$.",
            "refs": [
              "Bollig_2018",
              "Beame_2015"
            ],
            "derived": false
          },
          "description": "First, we show no polynomial compilation exists.\nd-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. nOBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If SDNNF compiles to nOBDD in polynomial time, then d-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that d-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}.\n\nNow, we show a quasi-polynomial compilation exists.\nTheorem 2 of \\citet{Bollig_2018} shows that $SDNNF$ can be compiled into $nOBDD$ by adapting the compilation of \\citet{Beame_2015} from $DNNF$ to $nFBDD$."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. OBDD$_<$ compiles to FBDD in polynomial time \\citet{Darwiche_2002}. If SDNNF compiles to OBDD$_<$ in quasi-polynomial time, then d-SDNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to FBDD in quasi-polynomial time \\citet{Van den Broeck_2015}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. If SDNNF compiles to PI in quasi-polynomial time, then d-SDNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Van den Broeck_2015"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "nOBDD compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. If SDNNF compiles to SDD in quasi-polynomial time, then nOBDD compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that nOBDD cannot compile to d-SDNNF in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Amarilli_2018,Wegener_2000,Bollig_2018,Beame_2015}."
        },
        null,
        null,
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Wegener_2000"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "DNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018,Wegener_2000}. uFBDD compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. If SDNNF compiles to uFBDD in quasi-polynomial time, then DNF compiles to d-DNNF in at most quasi-polynomial time. This contradicts the fact that DNF cannot compile to d-DNNF in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "caveat": "the polynomial hierarchy collapses",
          "hidden": false,
          "derived": true,
          "description": "nOBDD compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. uOBDD compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. If SDNNF compiles to uOBDD in quasi-polynomial time, then nOBDD compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that nOBDD cannot compile to d-SDNNF in quasi-polynomial time unless the polynomial hierarchy collapses \\citet{Amarilli_2018,Wegener_2000,Bollig_2018,Beame_2015}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. OBDD compiles to FBDD in polynomial time \\citet{Darwiche_2002}. If SDNNF compiles to OBDD in quasi-polynomial time, then d-SDNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to FBDD in quasi-polynomial time \\citet{Van den Broeck_2015}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. dec-DNNF compiles to FBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If SDNNF compiles to dec-DNNF in quasi-polynomial time, then d-SDNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to FBDD in quasi-polynomial time \\citet{Van den Broeck_2015}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. dec-SDNNF compiles to FBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If SDNNF compiles to dec-SDNNF in quasi-polynomial time, then d-SDNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to FBDD in quasi-polynomial time \\citet{Van den Broeck_2015}."
        },
        null,
        null
      ],
      [
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null
      ],
      [
        null,
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to uFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If uFBDD compiles to CNF in quasi-polynomial time, then d-DNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to uFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If uFBDD compiles to cSDD in quasi-polynomial time, then d-DNNF compiles to cSDD in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to cSDD in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018,Van den Broeck_2015}."
        },
        {
          "status": "poly",
          "description": "Rewrite each decision node labeled $x$ as $(x \\wedge D_0) \\vee (\\neg x \\wedge D_1)$, where $D_0, D_1$ are the rewritings of the 0- and 1-successors. The $\\wedge$-gates are decomposable, and unambiguity of the $uFBDD$ ensures all introduced $\\vee$-gates are deterministic, yielding a $d$-$DNNF$ in linear time \\citet{Amarilli_2018}.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to uFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If uFBDD compiles to d-SDNNF in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to uFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If uFBDD compiles to DNF in quasi-polynomial time, then d-DNNF compiles to DNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018,Wegener_2000}."
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. nFBDD compiles to DNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from uFBDD to DNNF."
        },
        {
          "status": "no-quasi",
          "description": "Consider the Boolean functions $\\phi_n, \\psi_n: \\{0,1\\}^{n^2}\\to\\{0,1\\}$, which respectively test whether, in an $n\\times n$ Boolean matrix, that the number of 1's is odd and there is a row full of 1's, and that the number of 1's is even and there is a column full of 1's. \\citet{Bova_2016} and \\citet{Wegener_2000} show that an $FBDD$ expression for $\\phi_n \\vee \\psi_n$ has necessarily size $2^{\\Omega(n^{1/2})}$; but since an $FBDD$ of size $O(n^2)$ may test $\\phi_n$ or $\\psi_n$ separately (shown by Proposition 3.1 of \\citet{Amarilli_2018}), a $uFBDD$ for $\\phi_n\\vee \\psi_n$ may be obtained by simply adding an $\\vee$-gate joining these two $FBDD$ expressions, since $\\phi_n \\wedge \\psi_n$ is unsatisfiable.",
          "refs": [
            "Bova_2016",
            "Amarilli_2018",
            "Wegener_2000"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to uFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. If uFBDD compiles to IP in quasi-polynomial time, then d-DNNF compiles to DNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018,Wegener_2000}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to uFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. MODS compiles to CNF in polynomial time \\citet{Darwiche_2002}. If uFBDD compiles to MODS in quasi-polynomial time, then d-DNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "poly",
          "description": "As defined by \\citet{Amarilli_2018}, $uFBDD$ is the subset of $nFBDD$ satisfying unambiguity.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. nFBDD compiles to DNNF in polynomial time \\citet{Amarilli_2018}. DNNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from uFBDD to NNF."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to uFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If uFBDD compiles to nOBDD in quasi-polynomial time, then d-DNNF compiles to nOBDD in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to nOBDD in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to uFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. OBDD$_<$ compiles to d-SDNNF in polynomial time \\citet{Darwiche_2002,Amarilli_2018}. If uFBDD compiles to OBDD$_<$ in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to uFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. If uFBDD compiles to PI in quasi-polynomial time, then d-DNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013",
            "Van den Broeck_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to uFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. If uFBDD compiles to SDD in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to uFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. SDNNF compiles to nOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. If uFBDD compiles to SDNNF in quasi-polynomial time, then d-DNNF compiles to nOBDD in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to nOBDD in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        null,
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to uFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. uOBDD compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. If uFBDD compiles to uOBDD in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to uFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. OBDD compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. If uFBDD compiles to OBDD in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to uFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. dec-DNNF compiles to FBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If uFBDD compiles to dec-DNNF in quasi-polynomial time, then d-DNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to FBDD in quasi-polynomial time \\citet{Darwiche_2000}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-DNNF compiles to uFBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. dec-SDNNF compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. If uFBDD compiles to dec-SDNNF in quasi-polynomial time, then d-DNNF compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that d-DNNF cannot compile to d-SDNNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        null,
        null
      ],
      [
        null,
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to uOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. If uOBDD compiles to CNF in quasi-polynomial time, then d-SDNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        null,
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "uOBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. uFBDD compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from uOBDD to d-DNNF."
        },
        {
          "status": "poly",
          "description": "Construct a right-linear v-tree from the variable order, then rewrite each decision node labeled $x$ as $(x \\wedge D_0) \\vee (\\neg x \\wedge D_1)$, where $D_0, D_1$ are the rewritings of the 0- and 1-successors. The v-tree alignment ensures structuredness, and unambiguity of the $uOBDD$ makes all introduced $\\vee$-gates deterministic, yielding a $d$-$SDNNF$ in linear time \\citet{Amarilli_2018}.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to uOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. If uOBDD compiles to DNF in quasi-polynomial time, then d-SDNNF compiles to DNF in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "uOBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. nFBDD compiles to DNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from uOBDD to DNNF."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015",
            "Van den Broeck_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to uOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. If uOBDD compiles to FBDD in quasi-polynomial time, then d-SDNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to FBDD in quasi-polynomial time \\citet{Van den Broeck_2015}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to uOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. If uOBDD compiles to IP in quasi-polynomial time, then d-SDNNF compiles to DNF in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to uOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. MODS compiles to CNF in polynomial time \\citet{Darwiche_2002}. If uOBDD compiles to MODS in quasi-polynomial time, then d-SDNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "uOBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from uOBDD to nFBDD."
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "uOBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. nFBDD compiles to DNNF in polynomial time \\citet{Amarilli_2018}. DNNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from uOBDD to NNF."
        },
        {
          "status": "poly",
          "description": "As defined by \\citet{Amarilli_2018}, $uOBDD$ is the subset of $nOBDD$ satisfying unambiguity.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015",
            "Van den Broeck_2015",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to uOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. OBDD$_<$ compiles to FBDD in polynomial time \\citet{Darwiche_2002}. If uOBDD compiles to OBDD$_<$ in quasi-polynomial time, then d-SDNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to FBDD in quasi-polynomial time \\citet{Van den Broeck_2015}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to uOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. If uOBDD compiles to PI in quasi-polynomial time, then d-SDNNF compiles to CNF in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002,Amarilli_2018}."
        },
        null,
        null,
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "uOBDD compiles to nOBDD in polynomial time \\citet{Amarilli_2018}. nOBDD compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from uOBDD to SDNNF."
        },
        null,
        {
          "status": "poly",
          "description": "As defined by \\citet{Amarilli_2018}, $uOBDD$ is the subset of $uFBDD$ satisfying an order of the variables, so compilation entails discarding the order.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        null,
        {
          "status": "no-quasi",
          "description": "The hidden weighted bit function $HWB_n$ has polynomial $uOBDD$ size, but $OBDD$ size $2^{\\Omega(n)}$ \\citet{Amarilli_2018}.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015",
            "Van den Broeck_2015",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "description": "d-SDNNF compiles to uOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. dec-SDNNF compiles to FBDD in quasi-polynomial time \\citet{Amarilli_2018,Beame_2013}. If uOBDD compiles to dec-SDNNF in quasi-polynomial time, then d-SDNNF compiles to FBDD in at most quasi-polynomial time. This contradicts the fact that d-SDNNF cannot compile to FBDD in quasi-polynomial time \\citet{Van den Broeck_2015}."
        },
        null,
        null
      ],
      [
        null,
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. If OBDD compiles to CNF in quasi-polynomial time, then OBDD$_<$ compiles to CNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        null,
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD compiles to dec-SDNNF in polynomial time \\citet{Amarilli_2018}. dec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. dec-DNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from OBDD to d-DNNF."
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD compiles to dec-SDNNF in polynomial time \\citet{Amarilli_2018}. dec-SDNNF compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from OBDD to d-SDNNF."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. If OBDD compiles to DNF in quasi-polynomial time, then OBDD$_<$ compiles to DNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD compiles to dec-SDNNF in polynomial time \\citet{Amarilli_2018}. dec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. dec-DNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from OBDD to DNNF."
        },
        {
          "status": "poly",
          "description": "As defined by \\citet{Darwiche_2002}, $OBDD$ is a subset of $FBDD$. Therefore a polynomial time compilation is trivial.",
          "refs": [
            "Darwiche_2002"
          ]
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. If OBDD compiles to IP in quasi-polynomial time, then OBDD$_<$ compiles to DNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. MODS compiles to CNF in polynomial time \\citet{Darwiche_2002}. If OBDD compiles to MODS in quasi-polynomial time, then OBDD$_<$ compiles to CNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD compiles to uOBDD in polynomial time \\citet{Amarilli_2018}. uOBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from OBDD to nFBDD."
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD compiles to dec-SDNNF in polynomial time \\citet{Amarilli_2018}. dec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. dec-DNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. DNNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from OBDD to NNF."
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD compiles to uOBDD in polynomial time \\citet{Amarilli_2018}. uOBDD compiles to nOBDD in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from OBDD to nOBDD."
        },
        {
          "status": "no-quasi",
          "description": "The function $\\bigwedge_{i=1}^n(x_i\\Leftrightarrow y_i)$ has an $OBDD_<$ representation of size polynomial in $n$ whenever $<$ satisfies $x_1<y_1<...<x_n<y_n$ but exponential in $n$ if $<$ satisfies $x_1<x_2<...<x_n<y_1<y_2<...<y_n$",
          "refs": [
            "Darwiche_2002"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to OBDD in polynomial time \\citet{Darwiche_2002}. PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. If OBDD compiles to PI in quasi-polynomial time, then OBDD$_<$ compiles to CNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "poly",
          "description": "As established by \\citet{Darwiche_2011}, every $OBDD$ is a right-linear $SDD$. Thus, $SDD$ strictly generalizes $OBDD$.",
          "refs": [
            "Darwiche_2011"
          ],
          "derived": false
        },
        null,
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD compiles to dec-SDNNF in polynomial time \\citet{Amarilli_2018}. dec-SDNNF compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from OBDD to SDNNF."
        },
        null,
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD compiles to uOBDD in polynomial time \\citet{Amarilli_2018}. uOBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from OBDD to uFBDD."
        },
        {
          "status": "poly",
          "description": "As defined by \\citet{Amarilli_2018}, $OBDD$ is the subset of $uOBDD$ without any $\\vee$-node.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        null,
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD compiles to dec-SDNNF in polynomial time \\citet{Amarilli_2018}. dec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from OBDD to dec-DNNF."
        },
        {
          "status": "poly",
          "description": "Construct a right-linear v-tree from the variable order, then rewrite each decision node labeled $x$ as $(x \\wedge D_0) \\vee (\\neg x \\wedge D_1)$, where $D_0, D_1$ are the rewritings of the 0- and 1-successors. The v-tree alignment ensures structuredness, and since all $\\vee$-gates arise from decision node rewrites, every $\\vee$-gate is a decision gate, yielding a $dec$-$SDNNF$ in linear time \\citet{Amarilli_2018}.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        null,
        null
      ],
      [
        null,
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. If dec-DNNF compiles to CNF in quasi-polynomial time, then FBDD compiles to CNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. If dec-DNNF compiles to cSDD in quasi-polynomial time, then FBDD compiles to cSDD in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to cSDD in quasi-polynomial time \\citet{Van den Broeck_2015,Amarilli_2018}."
        },
        {
          "status": "poly",
          "description": "As defined by \\citet{Amarilli_2018}, $dec$-$DNNF$ is the subset of $d$-$DNNF$ satisfying the decision property.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. If dec-DNNF compiles to d-SDNNF in quasi-polynomial time, then FBDD compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to d-SDNNF in quasi-polynomial time \\citet{Amarilli_2018}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. If dec-DNNF compiles to DNF in quasi-polynomial time, then FBDD compiles to DNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to DNF in quasi-polynomial time \\citet{Amarilli_2018,Wegener_2000}."
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "dec-DNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from dec-DNNF to DNNF."
        },
        {
          "status": "no-poly-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": false,
          "noPolyDescription": {
            "description": "dec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. FBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If dec-DNNF compiles to FBDD in polynomial time, then dec-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that dec-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.",
            "refs": [
              "Amarilli_2018",
              "Beame_2013"
            ],
            "derived": true
          },
          "quasiDescription": {
            "description": "Corollary 3.2 of \\citet{Beame_2013} show quasi-polynomial compilation from $dec$-$DNNF$ to $FBDD$",
            "refs": [
              "Beame_2013"
            ],
            "derived": false
          },
          "description": "First, we show no polynomial compilation exists.\ndec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. FBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If dec-DNNF compiles to FBDD in polynomial time, then dec-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that dec-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.\n\nNow, we show a quasi-polynomial compilation exists.\nCorollary 3.2 of \\citet{Beame_2013} show quasi-polynomial compilation from $dec$-$DNNF$ to $FBDD$"
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. If dec-DNNF compiles to IP in quasi-polynomial time, then FBDD compiles to DNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to DNF in quasi-polynomial time \\citet{Amarilli_2018,Wegener_2000}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. MODS compiles to CNF in polynomial time \\citet{Darwiche_2002}. If dec-DNNF compiles to MODS in quasi-polynomial time, then FBDD compiles to CNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-poly-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "noPolyDescription": {
            "description": "dec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. If dec-DNNF compiles to nFBDD in polynomial time, then dec-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that dec-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.",
            "refs": [
              "Amarilli_2018",
              "Beame_2013"
            ],
            "derived": true
          },
          "quasiDescription": {
            "description": "dec-DNNF compiles to FBDD in at worst quasi-polynomial time \\citet{Beame_2013}. FBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from dec-DNNF to nFBDD.",
            "refs": [
              "Beame_2013",
              "Amarilli_2018"
            ],
            "derived": true
          },
          "description": "First, we show no polynomial compilation exists.\ndec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. If dec-DNNF compiles to nFBDD in polynomial time, then dec-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that dec-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.\n\nNow, we show a quasi-polynomial compilation exists.\ndec-DNNF compiles to FBDD in at worst quasi-polynomial time \\citet{Beame_2013}. FBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from dec-DNNF to nFBDD."
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "dec-DNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. DNNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from dec-DNNF to NNF."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. If dec-DNNF compiles to nOBDD in quasi-polynomial time, then FBDD compiles to nOBDD in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to nOBDD in quasi-polynomial time \\citet{Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. OBDD$_<$ compiles to d-SDNNF in polynomial time \\citet{Darwiche_2002,Amarilli_2018}. If dec-DNNF compiles to OBDD$_<$ in quasi-polynomial time, then FBDD compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to d-SDNNF in quasi-polynomial time \\citet{Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. If dec-DNNF compiles to PI in quasi-polynomial time, then FBDD compiles to CNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Van den Broeck_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. SDD compiles to d-SDNNF in polynomial time \\citet{Van den Broeck_2015}. If dec-DNNF compiles to SDD in quasi-polynomial time, then FBDD compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to d-SDNNF in quasi-polynomial time \\citet{Amarilli_2018}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. SDNNF compiles to nOBDD in quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. If dec-DNNF compiles to SDNNF in quasi-polynomial time, then FBDD compiles to nOBDD in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to nOBDD in quasi-polynomial time \\citet{Amarilli_2018}."
        },
        null,
        {
          "status": "no-poly-quasi",
          "refs": [
            "Beame_2013",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "noPolyDescription": {
            "description": "uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If dec-DNNF compiles to uFBDD in polynomial time, then dec-DNNF compiles to nFBDD in polynomial time. This contradicts the fact that dec-DNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.",
            "refs": [
              "Beame_2013",
              "Amarilli_2018"
            ],
            "derived": true
          },
          "quasiDescription": {
            "description": "dec-DNNF compiles to FBDD in at worst quasi-polynomial time \\citet{Beame_2013}. FBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from dec-DNNF to uFBDD.",
            "refs": [
              "Beame_2013",
              "Amarilli_2018"
            ],
            "derived": true
          },
          "description": "First, we show no polynomial compilation exists.\nuFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If dec-DNNF compiles to uFBDD in polynomial time, then dec-DNNF compiles to nFBDD in polynomial time. This contradicts the fact that dec-DNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.\n\nNow, we show a quasi-polynomial compilation exists.\ndec-DNNF compiles to FBDD in at worst quasi-polynomial time \\citet{Beame_2013}. FBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from dec-DNNF to uFBDD."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. uOBDD compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. If dec-DNNF compiles to uOBDD in quasi-polynomial time, then FBDD compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to d-SDNNF in quasi-polynomial time \\citet{Amarilli_2018}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. OBDD compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. If dec-DNNF compiles to OBDD in quasi-polynomial time, then FBDD compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to d-SDNNF in quasi-polynomial time \\citet{Amarilli_2018}."
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "FBDD compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. dec-SDNNF compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. If dec-DNNF compiles to dec-SDNNF in quasi-polynomial time, then FBDD compiles to d-SDNNF in at most quasi-polynomial time. This contradicts the fact that FBDD cannot compile to d-SDNNF in quasi-polynomial time \\citet{Amarilli_2018}."
        },
        null,
        null
      ],
      [
        null,
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to dec-SDNNF in polynomial time \\citet{Darwiche_2002,Amarilli_2018}. If dec-SDNNF compiles to CNF in quasi-polynomial time, then OBDD$_<$ compiles to CNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        null,
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "dec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. dec-DNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from dec-SDNNF to d-DNNF."
        },
        {
          "status": "poly",
          "description": "As defined by \\citet{Amarilli_2018}, $dec$-$SDNNF$ is the subset of $d$-$SDNNF$ satisfying the decision property, so compilation is trivial.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        null,
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to dec-SDNNF in polynomial time \\citet{Darwiche_2002,Amarilli_2018}. If dec-SDNNF compiles to DNF in quasi-polynomial time, then OBDD$_<$ compiles to DNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "dec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. dec-DNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from dec-SDNNF to DNNF."
        },
        {
          "status": "no-poly-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "noPolyDescription": {
            "description": "FBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If dec-SDNNF compiles to FBDD in polynomial time, then dec-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that dec-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.",
            "refs": [
              "Amarilli_2018",
              "Beame_2013"
            ],
            "derived": true
          },
          "quasiDescription": {
            "description": "dec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. dec-DNNF compiles to FBDD in at worst quasi-polynomial time \\citet{Beame_2013}. Therefore a quasi-polynomial compilation exists from dec-SDNNF to FBDD.",
            "refs": [
              "Amarilli_2018",
              "Beame_2013"
            ],
            "derived": true
          },
          "description": "First, we show no polynomial compilation exists.\nFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If dec-SDNNF compiles to FBDD in polynomial time, then dec-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that dec-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.\n\nNow, we show a quasi-polynomial compilation exists.\ndec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. dec-DNNF compiles to FBDD in at worst quasi-polynomial time \\citet{Beame_2013}. Therefore a quasi-polynomial compilation exists from dec-SDNNF to FBDD."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to dec-SDNNF in polynomial time \\citet{Darwiche_2002,Amarilli_2018}. IP compiles to DNF in polynomial time \\citet{Darwiche_2002}. If dec-SDNNF compiles to IP in quasi-polynomial time, then OBDD$_<$ compiles to DNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to DNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to dec-SDNNF in polynomial time \\citet{Darwiche_2002,Amarilli_2018}. MODS compiles to CNF in polynomial time \\citet{Darwiche_2002}. If dec-SDNNF compiles to MODS in quasi-polynomial time, then OBDD$_<$ compiles to CNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-poly-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": false,
          "noPolyDescription": {
            "description": "Shown by Proposition 3.10 of \\citet{Amarilli_2018}",
            "refs": [
              "Amarilli_2018"
            ],
            "derived": false
          },
          "quasiDescription": {
            "description": "dec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. dec-DNNF compiles to FBDD in at worst quasi-polynomial time \\citet{Beame_2013}. FBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from dec-SDNNF to nFBDD.",
            "refs": [
              "Amarilli_2018",
              "Beame_2013"
            ],
            "derived": true
          },
          "description": "First, we show no polynomial compilation exists.\nShown by Proposition 3.10 of \\citet{Amarilli_2018}\n\nNow, we show a quasi-polynomial compilation exists.\ndec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. dec-DNNF compiles to FBDD in at worst quasi-polynomial time \\citet{Beame_2013}. FBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from dec-SDNNF to nFBDD."
        },
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": true,
          "description": "dec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. dec-DNNF compiles to d-DNNF in polynomial time \\citet{Amarilli_2018}. d-DNNF compiles to DNNF in polynomial time \\citet{Darwiche_2002}. DNNF compiles to NNF in polynomial time \\citet{Darwiche_2002}. Therefore a polynomial compilation exists from dec-SDNNF to NNF."
        },
        {
          "status": "no-poly-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": true,
          "noPolyDescription": {
            "description": "nOBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If dec-SDNNF compiles to nOBDD in polynomial time, then dec-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that dec-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.",
            "refs": [
              "Amarilli_2018",
              "Bollig_2018",
              "Beame_2015"
            ],
            "derived": true
          },
          "quasiDescription": {
            "description": "dec-SDNNF compiles to OBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. OBDD compiles to uOBDD in polynomial time \\citet{Amarilli_2018}. uOBDD compiles to nOBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from dec-SDNNF to nOBDD.",
            "refs": [
              "Amarilli_2018",
              "Bollig_2018",
              "Beame_2015"
            ],
            "derived": true
          },
          "description": "First, we show no polynomial compilation exists.\nnOBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If dec-SDNNF compiles to nOBDD in polynomial time, then dec-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that dec-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.\n\nNow, we show a quasi-polynomial compilation exists.\ndec-SDNNF compiles to OBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. OBDD compiles to uOBDD in polynomial time \\citet{Amarilli_2018}. uOBDD compiles to nOBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from dec-SDNNF to nOBDD."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD compiles to dec-SDNNF in polynomial time \\citet{Amarilli_2018}. If dec-SDNNF compiles to OBDD$_<$ in quasi-polynomial time, then OBDD compiles to OBDD$_<$ in at most quasi-polynomial time. This contradicts the fact that OBDD cannot compile to OBDD$_<$ in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "no-quasi",
          "refs": [
            "Darwiche_2002",
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "OBDD$_<$ compiles to dec-SDNNF in polynomial time \\citet{Darwiche_2002,Amarilli_2018}. PI compiles to CNF in polynomial time \\citet{Darwiche_2002}. If dec-SDNNF compiles to PI in quasi-polynomial time, then OBDD$_<$ compiles to CNF in at most quasi-polynomial time. This contradicts the fact that OBDD$_<$ cannot compile to CNF in quasi-polynomial time \\citet{Darwiche_2002}."
        },
        {
          "status": "unknown-poly-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015",
            "Darwiche_2011"
          ],
          "hidden": false,
          "derived": true,
          "description": "dec-SDNNF compiles to OBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. OBDD compiles to SDD in polynomial time \\citet{Darwiche_2011}. Therefore a quasi-polynomial compilation exists from dec-SDNNF to SDD."
        },
        null,
        {
          "status": "poly",
          "refs": [
            "Amarilli_2018"
          ],
          "hidden": false,
          "derived": true,
          "description": "dec-SDNNF compiles to d-SDNNF in polynomial time \\citet{Amarilli_2018}. d-SDNNF compiles to SDNNF in polynomial time \\citet{Amarilli_2018}. Therefore a polynomial compilation exists from dec-SDNNF to SDNNF."
        },
        null,
        {
          "status": "no-poly-quasi",
          "refs": [
            "Amarilli_2018",
            "Beame_2013"
          ],
          "hidden": false,
          "derived": true,
          "noPolyDescription": {
            "description": "uFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If dec-SDNNF compiles to uFBDD in polynomial time, then dec-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that dec-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.",
            "refs": [
              "Amarilli_2018",
              "Beame_2013"
            ],
            "derived": true
          },
          "quasiDescription": {
            "description": "dec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. dec-DNNF compiles to FBDD in at worst quasi-polynomial time \\citet{Beame_2013}. FBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from dec-SDNNF to uFBDD.",
            "refs": [
              "Amarilli_2018",
              "Beame_2013"
            ],
            "derived": true
          },
          "description": "First, we show no polynomial compilation exists.\nuFBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If dec-SDNNF compiles to uFBDD in polynomial time, then dec-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that dec-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.\n\nNow, we show a quasi-polynomial compilation exists.\ndec-SDNNF compiles to dec-DNNF in polynomial time \\citet{Amarilli_2018}. dec-DNNF compiles to FBDD in at worst quasi-polynomial time \\citet{Beame_2013}. FBDD compiles to uFBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from dec-SDNNF to uFBDD."
        },
        {
          "status": "no-poly-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015"
          ],
          "hidden": false,
          "derived": true,
          "noPolyDescription": {
            "description": "uOBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If dec-SDNNF compiles to uOBDD in polynomial time, then dec-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that dec-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.",
            "refs": [
              "Amarilli_2018",
              "Bollig_2018",
              "Beame_2015"
            ],
            "derived": true
          },
          "quasiDescription": {
            "description": "dec-SDNNF compiles to OBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. OBDD compiles to uOBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from dec-SDNNF to uOBDD.",
            "refs": [
              "Amarilli_2018",
              "Bollig_2018",
              "Beame_2015"
            ],
            "derived": true
          },
          "description": "First, we show no polynomial compilation exists.\nuOBDD compiles to nFBDD in polynomial time \\citet{Amarilli_2018}. If dec-SDNNF compiles to uOBDD in polynomial time, then dec-SDNNF compiles to nFBDD in polynomial time. This contradicts the fact that dec-SDNNF cannot compile to nFBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.\n\nNow, we show a quasi-polynomial compilation exists.\ndec-SDNNF compiles to OBDD in at worst quasi-polynomial time \\citet{Amarilli_2018,Bollig_2018,Beame_2015}. OBDD compiles to uOBDD in polynomial time \\citet{Amarilli_2018}. Therefore a quasi-polynomial compilation exists from dec-SDNNF to uOBDD."
        },
        {
          "status": "no-poly-quasi",
          "refs": [
            "Amarilli_2018",
            "Bollig_2018",
            "Beame_2015",
            "Darwiche_2002"
          ],
          "hidden": false,
          "derived": false,
          "noPolyDescription": {
            "description": "OBDD compiles to FBDD in polynomial time \\citet{Darwiche_2002}. If dec-SDNNF compiles to OBDD in polynomial time, then dec-SDNNF compiles to FBDD in polynomial time. This contradicts the fact that dec-SDNNF cannot compile to FBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.",
            "refs": [
              "Amarilli_2018",
              "Bollig_2018",
              "Beame_2015",
              "Darwiche_2002"
            ],
            "derived": true
          },
          "quasiDescription": {
            "description": "Theorem 2 of \\citet{Bollig_2018} shows that $SDNNF$ can be compiled into $nOBDD$ by adapting the compilation of \\citet{Beame_2015} from $DNNF$ to $nFBDD$; proposition 2 of \\citet{Bollig_2018} shows that this $nOBDD$ is unambiguous if the $SDNNF$ is deterministic. Additionally, the same compilation yields an $OBDD$ if the input is a $dec$-$SDNNF$ since there are no $\\vee$-gates that are not decision gates in a $dec$-$SDNNF$.",
            "refs": [
              "Amarilli_2018",
              "Bollig_2018",
              "Beame_2015"
            ],
            "derived": false
          },
          "description": "First, we show no polynomial compilation exists.\nOBDD compiles to FBDD in polynomial time \\citet{Darwiche_2002}. If dec-SDNNF compiles to OBDD in polynomial time, then dec-SDNNF compiles to FBDD in polynomial time. This contradicts the fact that dec-SDNNF cannot compile to FBDD in polynomial time \\citet{Amarilli_2018,Beame_2013}.\n\nNow, we show a quasi-polynomial compilation exists.\nTheorem 2 of \\citet{Bollig_2018} shows that $SDNNF$ can be compiled into $nOBDD$ by adapting the compilation of \\citet{Beame_2015} from $DNNF$ to $nFBDD$; proposition 2 of \\citet{Bollig_2018} shows that this $nOBDD$ is unambiguous if the $SDNNF$ is deterministic. Additionally, the same compilation yields an $OBDD$ if the input is a $dec$-$SDNNF$ since there are no $\\vee$-gates that are not decision gates in a $dec$-$SDNNF$."
        },
        {
          "status": "poly",
          "description": "As defined by \\citet{Amarilli_2018}, a $dec$-$SDNNF$ is simply a structured $dec$-$DNNF$, so discarding the v-tree completes the compilation.",
          "refs": [
            "Amarilli_2018"
          ],
          "derived": false
        },
        null,
        null,
        null
      ],
      [
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null
      ],
      [
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null,
        null
      ]
    ]
  },
  "separatingFunctions": [
    {
      "shortName": "Pairwise CNF",
      "name": "$\\Sigma_n = \\bigwedge_{i=0}^{n-1} \\left( x_{2i} \\vee x_{2i+1} \\right)$",
      "description": "Requires that in each pair $(x_{2i}, x_{2i+1})$, at least one is true. Dual to the Pairwise DNF.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "shortName": "Pairwise DNF",
      "name": "$\\Pi_n = \\bigvee_{i=0}^{n-1} \\left( x_{2i} \\wedge x_{2i+1} \\right)$",
      "description": "Requires that at least one pair $(x_{2i}, x_{2i+1})$ has both variables true. Dual to the Pairwise CNF.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "shortName": "Parity",
      "name": "Parity function",
      "description": "$O_n = \\bigoplus_{i=0}^{n-1} x_i$ has linear size $OBBD_<$ representations but exponential size CNF and DNF representations.",
      "refs": [
        "Bryant_1986"
      ]
    },
    {
      "shortName": "HWB",
      "name": "Hidden Weighted Bit",
      "description": "Let $w = \\sum_{i=1}^n x_i$ be the Hamming weight of the input. Then $HWB_n(x_1, \\ldots, x_n) = x_w$ (the $w$-th input bit). Has $OBDD$ size $2^{\\Omega(n)}$ but polynomial $SDD$ and $FBDD$ size.",
      "refs": [
        "Bryant_1986"
      ]
    },
    {
      "shortName": "$OR_n$",
      "name": "$OR_n = \\bigvee_{i=1}^{n} x_i$",
      "description": "Separates languages that compactly represent disjunctions from those that cannot.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "shortName": "Pairwise equivalence",
      "name": "$\\Sigma_n = \\bigwedge_{i=1}^n (x_i \\leftrightarrow y_i)$",
      "description": "Requires that each pair $(x_i, y_i)$ has equal truth values. An $OBDD_<$ with interleaved order $x_1 < y_1 < \\cdots < x_n < y_n$ is polynomial, but a separated order $x_1 < \\cdots < x_n < y_1 < \\cdots < y_n$ forces exponential size.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "shortName": "Clique",
      "name": "Clique Detection Instances",
      "description": "Tests whether a directed graph on $n$ vertices (encoded as $I \\in \\{0,1\\}^{n^2}$) contains a bidirectional clique of size $k$: $\\Sigma_{n,k}(I) = 1 \\iff I$ contains such a clique. Has $O(n^3)$ prime implicants but exponential $FBDD$ size for suitable $k$.",
      "refs": [
        "Darwiche_2002",
        "Wegener_1987"
      ]
    },
    {
      "shortName": "Sauerhoff",
      "name": "Sauerhoff function",
      "description": "Let $g_n: \\{0,1\\}^{2n} \\to \\{0,1\\}$ be the function evaluating to 1 if and only if the sum of its inputs is divisible by 3. The Sauerhoff function $S_n: \\{0,1\\}^{n^2} \\to \\{0,1\\}$ is defined on the $n \\times n$ matrix $X = (x_{i,j})$ as $S_n(X) = R_n(X) \\vee C_n(X)$, where $R_n, C_n : \\{0,1\\}^{n^2} \\to \\{0,1\\}$ are defined by $R_n(X) = \\bigplus_{i=1}^n g_n(x_{i1},x_{i2},...,x_{in}$ and $C_n(X) = R_n(X^T)$.",
      "refs": [
        "Sauerhoff_2003",
        "Bova_2016"
      ]
    },
    {
      "shortName": "JS",
      "name": "Jukna-Schnitger function",
      "description": "Tests triangle-freeness on graphs with respect to a fixed set of forbidden triangles $A \\subset T_n$. \\citet{Jukna_2002} show that for every $n$, there exists $A_n$ of size $O(n^2)$ such that any balanced rectangle cover of $JS_n^{A_n}$ has size $2^{\\Omega(n^2)}$. Has $PI$ size $O(n^2)$ but $DNNF$ size $2^{\\Omega(n^2)}$.",
      "refs": [
        "Jukna_2002"
      ]
    }
  ],
  "relationTypes": [
    {
      "id": "poly",
      "name": "Polynomial",
      "label": "$\\leq_p$",
      "description": "Polynomial compilation exists",
      "style": {
        "lineStyle": "solid",
        "width": 2,
        "targetStyle": {
          "arrow": "triangle",
          "dashed": false
        },
        "sourceStyle": {
          "arrow": "none",
          "dashed": false
        }
      },
      "defaultVisible": true
    },
    {
      "id": "no-poly-unknown-quasi",
      "name": "No Poly, Quasi Unknown",
      "label": "$\\not\\leq_p$ · $\\leq_q^?$",
      "description": "No polynomial compilation; quasi-polynomial unknown",
      "style": {
        "lineStyle": "solid",
        "width": 2,
        "targetStyle": {
          "arrow": "tee",
          "dashed": true
        },
        "sourceStyle": {
          "arrow": "none",
          "dashed": false
        }
      },
      "defaultVisible": true
    },
    {
      "id": "no-poly-quasi",
      "name": "No Poly, Quasi Exists",
      "label": "$\\not\\leq_p$ · $\\leq_q$",
      "description": "No polynomial compilation; quasi-polynomial exists",
      "style": {
        "lineStyle": "solid",
        "width": 2,
        "targetStyle": {
          "arrow": "tee",
          "dashed": false
        },
        "sourceStyle": {
          "arrow": "none",
          "dashed": false
        }
      },
      "defaultVisible": true
    },
    {
      "id": "unknown-poly-quasi",
      "name": "Poly Unknown, Quasi Exists",
      "label": "$\\leq_p^?$ · $\\leq_q$",
      "description": "Polynomial unknown; quasi-polynomial exists",
      "style": {
        "lineStyle": "solid",
        "width": 2,
        "targetStyle": {
          "arrow": "triangle-cross",
          "dashed": true
        },
        "sourceStyle": {
          "arrow": "none",
          "dashed": false
        }
      },
      "defaultVisible": true
    },
    {
      "id": "unknown-both",
      "name": "Unknown",
      "label": "$?$",
      "description": "Both polynomial and quasi-polynomial unknown",
      "style": {
        "lineStyle": "solid",
        "width": 2,
        "targetStyle": {
          "arrow": "square",
          "dashed": true
        },
        "sourceStyle": {
          "arrow": "none",
          "dashed": false
        }
      },
      "defaultVisible": true
    },
    {
      "id": "no-quasi",
      "name": "No Quasi",
      "label": "$\\not\\leq_q$",
      "description": "No quasi-polynomial compilation (implies no polynomial)",
      "style": {
        "lineStyle": "solid",
        "width": 2,
        "targetStyle": {
          "arrow": "square",
          "dashed": false
        },
        "sourceStyle": {
          "arrow": "none",
          "dashed": false
        }
      },
      "defaultVisible": true
    },
    {
      "id": "unknown-to-us",
      "name": "Unknown to Us",
      "label": "?",
      "description": "Not yet researched or documented",
      "style": {
        "lineStyle": "solid",
        "width": 2,
        "targetStyle": {
          "arrow": "circle",
          "dashed": true
        },
        "sourceStyle": {
          "arrow": "none",
          "dashed": false
        }
      },
      "defaultVisible": true
    }
  ],
  "operationLemmas": [
    {
      "id": "co-cd-me",
      "antecedent": [
        "CO",
        "CD"
      ],
      "consequent": "ME",
      "description": "CO and CD imply ME: First test consistency (polytime via CO). If inconsistent, return the empty set. Otherwise, build a decision tree of models by iterating over variables $x_1, \\ldots, x_n$ and using CD to test consistency of $\\Sigma | \\alpha \\land x_i$ and $\\Sigma | \\alpha \\land \\neg x_i$ for each leaf term $\\alpha$. Since one branch must succeed for consistent terms, the tree has $O(mn)$ tests where $m$ is the model count and $n$ is the variable count.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "co-cd-ce",
      "antecedent": [
        "CO",
        "CD"
      ],
      "consequent": "CE",
      "description": "CO and CD imply CE: To test whether sentence $\\Sigma$ entails non-valid clause $\\alpha$, i.e. $\\Sigma \\models \\alpha$, it suffices to test whether $\\Sigma | \\neg\\alpha$ is inconsistent.",
      "refs": [
        "Darwiche_2002",
        "Darwiche_2001a"
      ]
    },
    {
      "id": "va-cd-im",
      "antecedent": [
        "VA",
        "CD"
      ],
      "consequent": "IM",
      "description": "VA and CD imply IM: To test whether consistent term $\\alpha$ entails sentence $\\Sigma$, i.e. $\\alpha \\models \\Sigma$, test whether $\\neg\\alpha \\lor \\Sigma$ is valid. This is equivalent to $\\neg\\alpha \\lor (\\Sigma | \\alpha)$. Since $\\neg\\alpha$ and $\\Sigma | \\alpha$ share no variables, the disjunction is valid iff $\\neg\\alpha$ is valid or $\\Sigma | \\alpha$ is valid. Since $\\alpha$ is consistent, $\\neg\\alpha$ cannot be valid. Thus we test validity of $\\Sigma | \\alpha$, constructible in polytime via CD and testable in polytime via VA.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "eq-co",
      "antecedent": [
        "EQ"
      ],
      "consequent": "CO",
      "description": "EQ implies CO: $\\mathsf{true}$ and $\\mathsf{false}$ belong to every NNF subset. $\\Sigma$ is inconsistent iff it is equivalent to $\\mathsf{false}$.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "eq-va",
      "antecedent": [
        "EQ"
      ],
      "consequent": "VA",
      "description": "EQ implies VA: $\\mathsf{true}$ and $\\mathsf{false}$ belong to every NNF subset. $\\Sigma$ is valid iff it is equivalent to $\\mathsf{true}$.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "se-eq",
      "antecedent": [
        "SE"
      ],
      "consequent": "EQ",
      "description": "SE implies EQ: Sentences $\\Sigma_1$ and $\\Sigma_2$ are equivalent iff $\\Sigma_1 \\models \\Sigma_2$ and $\\Sigma_2 \\models \\Sigma_1$.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "ct-co",
      "antecedent": [
        "CT"
      ],
      "consequent": "CO",
      "description": "CT implies CO: Model counting (CT) requires enumerating all satisfying assignments. If a formula is inconsistent, it has zero models. Thus CT can determine CO by checking if the model count is zero.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "ct-va",
      "antecedent": [
        "CT"
      ],
      "consequent": "VA",
      "description": "CT implies VA: A formula is valid iff all $2^n$ assignments satisfy it. If we can count models in polytime (CT), we can check validity by testing if the count equals $2^n$.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "im-va",
      "antecedent": [
        "IM"
      ],
      "consequent": "VA",
      "description": "IM implies VA: A formula $\\Sigma$ is valid iff the complete term (all positive or all negative literals, i.e., any single model) implies $\\Sigma$. Since IM tests whether a consistent term implies the sentence, testing with a trivially consistent term gives validity.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "ce-co",
      "antecedent": [
        "CE"
      ],
      "consequent": "CO",
      "description": "CE implies CO: A formula $\\Sigma$ is inconsistent iff $\\Sigma \\models \\bot$, which is equivalent to $\\Sigma$ entailing the empty clause. Clause entailment (CE) can test this directly.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "me-co",
      "antecedent": [
        "ME"
      ],
      "consequent": "CO",
      "description": "ME implies CO: Model Enumeration requires outputting all models in time polynomial in the input size and number of models. In particular, it must determine whether any model exists (output the first model or halt with the empty set) in polynomial time, which is exactly the Consistency (CO) query.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "and-c-and-bc",
      "antecedent": [
        "AND_C"
      ],
      "consequent": "AND_BC",
      "description": "Conjunction implies bounded conjunction: bounded conjunction is a special case of conjunction where one operand has bounded size, so any language closed under conjunction is also closed under bounded conjunction.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "or-c-or-bc",
      "antecedent": [
        "OR_C"
      ],
      "consequent": "OR_BC",
      "description": "Disjunction implies bounded disjunction: bounded disjunction is a special case of disjunction where one operand has bounded size, so any language closed under disjunction is also closed under bounded disjunction.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "fo-sfo",
      "antecedent": [
        "FO"
      ],
      "consequent": "SFO",
      "description": "Forgetting implies singleton forgetting: singleton forgetting eliminates a single variable, which is a special case of forgetting an arbitrary set of variables.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "cd-or-bc-sfo",
      "antecedent": [
        "CD",
        "OR_BC"
      ],
      "consequent": "SFO",
      "description": "Conditioning and bounded disjunction imply singleton forgetting: to forget variable $x$ from $\\Sigma$, compute $\\Sigma|_{x=0}$ and $\\Sigma|_{x=1}$ via conditioning, then combine via $\\Sigma|_{x=0} \\lor \\Sigma|_{x=1}$ using bounded disjunction (one operand can serve as the bounded component).",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "not-c-and-c-or-c",
      "antecedent": [
        "NOT_C",
        "AND_C"
      ],
      "consequent": "OR_C",
      "description": "Negation and conjunction imply disjunction (De Morgan): $\\Sigma_1 \\lor \\Sigma_2 = \\lnot(\\lnot\\Sigma_1 \\land \\lnot\\Sigma_2)$. Negate both operands, conjoin, then negate the result.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "not-c-or-c-and-c",
      "antecedent": [
        "NOT_C",
        "OR_C"
      ],
      "consequent": "AND_C",
      "description": "Negation and disjunction imply conjunction (De Morgan): $\\Sigma_1 \\land \\Sigma_2 = \\lnot(\\lnot\\Sigma_1 \\lor \\lnot\\Sigma_2)$. Negate both operands, disjoin, then negate the result.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "not-c-and-bc-or-bc",
      "antecedent": [
        "NOT_C",
        "AND_BC"
      ],
      "consequent": "OR_BC",
      "description": "Negation and bounded conjunction imply bounded disjunction (De Morgan): $\\Sigma \\lor \\gamma = \\lnot(\\lnot\\Sigma \\land \\lnot\\gamma)$, where $\\lnot\\gamma$ (negation of a clause) is a term. Negate $\\Sigma$, conjoin with the term $\\lnot\\gamma$ via bounded conjunction, then negate.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "not-c-or-bc-and-bc",
      "antecedent": [
        "NOT_C",
        "OR_BC"
      ],
      "consequent": "AND_BC",
      "description": "Negation and bounded disjunction imply bounded conjunction (De Morgan): $\\Sigma \\land \\alpha = \\lnot(\\lnot\\Sigma \\lor \\lnot\\alpha)$, where $\\lnot\\alpha$ (negation of a term) is a clause. Negate $\\Sigma$, disjoin with the clause $\\lnot\\alpha$ via bounded disjunction, then negate.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "not-c-co-va",
      "antecedent": [
        "NOT_C",
        "CO"
      ],
      "consequent": "VA",
      "description": "Negation and consistency imply validity: $\\Sigma$ is valid iff $\\lnot\\Sigma$ is inconsistent. Negate via $\\lnot$C, then test consistency via CO.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "not-c-va-co",
      "antecedent": [
        "NOT_C",
        "VA"
      ],
      "consequent": "CO",
      "description": "Negation and validity imply consistency: $\\Sigma$ is consistent iff $\\lnot\\Sigma$ is not valid. Negate via $\\lnot$C, then test validity via VA.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "not-c-ce-im",
      "antecedent": [
        "NOT_C",
        "CE"
      ],
      "consequent": "IM",
      "description": "Negation and clausal entailment imply implicant testing: term $\\alpha$ implies $\\Sigma$ iff $\\lnot\\Sigma$ entails clause $\\lnot\\alpha$. Negate $\\Sigma$ via $\\lnot$C, then test clausal entailment of $\\lnot\\alpha$ (a clause) via CE.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "not-c-im-ce",
      "antecedent": [
        "NOT_C",
        "IM"
      ],
      "consequent": "CE",
      "description": "Negation and implicant testing imply clausal entailment: $\\Sigma$ entails clause $\\gamma$ iff term $\\lnot\\gamma$ implies $\\lnot\\Sigma$. Negate $\\Sigma$ via $\\lnot$C, then test whether $\\lnot\\gamma$ (a term) implies $\\lnot\\Sigma$ via IM.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "not-c-and-bc-co-se",
      "antecedent": [
        "NOT_C",
        "AND_BC",
        "CO"
      ],
      "consequent": "SE",
      "description": "Negation, bounded conjunction, and consistency imply sentential entailment: $\\Sigma_1 \\models \\Sigma_2$ iff $\\Sigma_1 \\land \\lnot\\Sigma_2$ is unsatisfiable. Negate $\\Sigma_2$ via $\\lnot$C, conjoin with $\\Sigma_1$ via $\\land$BC, then test consistency via CO.",
      "refs": [
        "Darwiche_2002"
      ]
    },
    {
      "id": "and-bc-sfo-cd",
      "antecedent": [
        "AND_BC",
        "SFO"
      ],
      "consequent": "CD",
      "description": "Bounded conjunction and singleton forgetting imply conditioning: $\\Sigma|\\gamma$ for term $\\gamma = l_1 \\land \\cdots \\land l_k$ is computed iteratively by $\\Sigma \\leftarrow \\exists x_i.(\\Sigma \\land l_i)$ for each literal $l_i$, using $\\land$BC then SFO.",
      "refs": [
        "Darwiche_2002"
      ]
    }
  ]
}
